@abc:C [C][]
@abc:L [L][]
@abc:LF [
][]
@abc:R [R][]
@abc:SP [ ][]
@abc:V [V][]
@abc:W [W][]
@abc:Z [Z][]
@abc:add [+][]
@abc:affine [f][]
@abc:apply [$][]
@abc:assert [K][]
@abc:c [c][]
@abc:compare [>][]
@abc:compose [o][]
@abc:condAp [?][]
@abc:copy [^][]
@abc:d0 [0][]
@abc:d1 [1][]
@abc:d2 [2][]
@abc:d3 [3][]
@abc:d4 [4][]
@abc:d5 [5][]
@abc:d6 [6][]
@abc:d7 [7][]
@abc:d8 [8][]
@abc:d9 [9][]
@abc:distrib [D][]
@abc:divMod [Q][]
@abc:drop [%][]
@abc:factor [F][]
@abc:intro0 [#][]
@abc:l [l][]
@abc:merge [M][]
@abc:mul [*][]
@abc:negate [-][]
@abc:quote ['][]
@abc:r [r][]
@abc:relevant [k][]
@abc:v [v][]
@abc:w [w][]
@abc:z [z][]
@ao:p [rwrzwll][]
@ao:add [{%ao:p} rr+l][]
@add [{%ao:add}][]
@anno:assoc [{&associative}][]
@anno:assoc.doc "Assert that arguments to an arity-2 function are associative.
~[v'c]
@anno:beqv [{&equivalent}][]
@anno:beqv.doc "Assert two blocks are behaviorally equivalent.
~[v'c]
@anno:commu [{&commutative}][]
@anno:commu.doc "Assert that arguments to an arity-2 function are commutative.
~[v'c]
@anno:eqv [{&≡}][]
@anno:eqv.doc "Assert two values (of any type) are structurally equivalent.
 This is very useful for automatic tests and safety analysis.
~[v'c]
@ao:dp [rw {%ao:p} wl][]
@ao:drop [r%][]
@ao:drop2 [{%ao:drop} {%ao:drop}][]
@ao:drop3 [{%ao:drop} {%ao:drop2}][]
@ao:drop4 [{%ao:drop2} {%ao:drop2}][]
@ao:drop5 [{%ao:drop2} {%ao:drop3}][]
@ao:drop6 [{%ao:drop3} {%ao:drop3}][]
@ao:drop7 [{%ao:drop3} {%ao:drop4}][]
@ao:drop8 [{%ao:drop4} {%ao:drop4}][]
@ao:drop9 [{%ao:drop4} {%ao:drop5}][]
@ao:nip [rw {%ao:drop} wl][]
@ao:dropd [{%ao:nip}][]
@ao:w [rrwll][]
@ao:dw [{&ns:ao:}rw{%ao:w}wl][]
@ao:x [rrwzlwl][]
@ao:dx [{&ns:ao:}rw{%ao:x}wl][]
@ao:literal [l][]
@ao:mul [{&ns:ao:}{%ao:p}rr*l][]
@ao:pw [{&ns:ao:}{%ao:p}{%ao:w}][]
@ao:wx [{&ns:ao:}{%ao:w}{%ao:x}][]
@c_ [vrwlcwlc][]
@math:divMod [{%ao:p} rrQll {%ao:wx}][]
@divMod [{%math:divMod}][]
@doc:ao:w [{&ns:ao:}"(x*y) -- (y*x)
~{%ao:literal}][]
@doc:meta:Loops 
"Loops in AO are ultimately expressed using fixpoint combinators. A loop will repeatedly copy and apply a block (which represents the body of the loop) until a terminating condition is observed. In practice, explicit loops should be avoided whenever possible, except when modeling collections types (streams, lists, etc.). Ultimately, AO should have the flavor of collection-oriented programming languages - i.e. very few loops exposed to programmers - despite the lack of built-in collection types.
 
 Compared to the recursive functions or built-in loops of more conventional programming languages, using fixpoint combinators is very awkward. Convenient loops are simply a low priority for AO's design. Instead, AO favors developing a few common collection types with collection-oriented words (which covers many use-cases for loops), plus incremental application models such that the outer loop is implicit.
 
 Explicit loops in AO are required to terminate. Due to the halting problem, termination cannot always be proven or disproven statically. However, a non-terminating loop is always a bug, and developers are expected to treat one thusly.
~[v'c]

@doc:meta:Math "Awelon Bytecode (ABC) has a built in number type for exact rational numbers, and a small set of primitive operators (`+*-/Q` for add, multiply, negate, reciprocal, divmod) for manipulating these numbers. This is suitable for basic arithmetic. In some cases, a runtime may use inexact number representations, guided by annotation... but exact math is the default.
 
 Awelon Object (AO) language provides convenient representation of numbers - e.g. decimal, hexadecimal, fractional. In addition, it is envisioned (though not yet practiced) that AO should make heavy use of units information - e.g. distinguishing 4 kilograms from 4 litres, i.e. as an alternative to conventional typing disciplines. Units are relatively easy to express in concatenative languages, e.g. the word `kilograms` might take a number off the stack and wrap it with the appropriate unit structure. 
 
 On the assumption that most AO math functions shall support operators, the 'primitive' math operations are named with prefix `.`, as in `.add` and `.mul`. In addition, there is a class of pure math functions that operate on pairs or single values, meant for use with process models and stream processing, which have the form `add\N` and `mul\N`, where N is the arity.
 
 Sadly, concatenative languages are not very nice for expressing sophisticated algebraic formula. The stack shuffling, duplication, and data plumbing can interfere greatly with comprehension compared to a more declarative approach. To address this we can feasibly leverage embedded DSLs and partial evaluation. Compare:
 
         drop dup dup .mul swap .abs rot3 dup .mul swap .sub .add
         drop [.square] [.abs] bi .neg [.square] dip .add
         "x y z → y^2 + x^2 - |y|" doTheMath
 
 These three lines essentially express the same behavior (assuming suitable implementations of each word), but the latter is decidedly more declarative and comprehensible. Unfortunately, it's still stuck in a nasty string. Long term, embedded DSLs should be able to leverage [embedded literal objects](http://awelonblue.wordpress.com/2014/07/22/embedded-literal-objects/) to achieve rich, compositional structure with various maths.
~[v'c]
@stack:dup [r^zlwl][]
@dup [{%stack:dup}][]
@dupd [rw {%dup} wl][]
@dupdd [rw {%dupd} wl][]
@elim1 [rvrwlcc][]
@elim1d [rw {%elim1} wl][]
@id [][]
@intro1 [vvrwlcl][]
@intro1d [rw {%intro1} wl][]
@l [rrwrzwlll][]
@l.doc "(x*(y*z)) -- ((x*y)*z)
~
@l_ [rwrzwll][]
@math:negate [r-l][]
@math:quot [{%ao:p} rrQ%l][]
@math:rem [{%ao:p} rrQw%l][]
@math:add 
@math:subtract [{%math:negate}{%math:add}][]
@negate [{%math:negate}][]
@nip2 [rw {%ao:drop2} wl][]
@nip3 [rw {%ao:drop3} wl][]
@nip4 [rw {%ao:drop4} wl][]
@swap [rwrwzwlwl][]
@over [{%dupd} {%swap}][]
@p.doc 
"y x -- (x*y)
~
@pick [rw {%over} wl {%swap}][]
@pick1st [{%dup}][]
@pick2nd [rw {%pick1st} wl {%swap}][]
@pick3rd [rw {%pick2nd} wl {%swap}][]
@pick4th [rw {%pick3rd} wl {%swap}][]
@pick5th [rw {%pick4th} wl {%swap}][]
@pick6th [rw {%pick5th} wl {%swap}][]
@pick7th [rw {%pick6th} wl {%swap}][]
@prim:fixpoint [[[^'ow^'zowvr$c]^'ow^'zowvr$c]w'o][]
@prim:fixpoint.direct [[^'o]o^'o][]
@prim:fixpoint.direct.doc 
"This is the simplest and most direct fixpoint combinator I've found for Awelon Bytecode. But, while it does the job, it has a major weakness: it doubles the function to which it is applied (i.e. so the logic is included twice). Thus, it is suitable only for relatively small functions and non-hierarchical structure. Further, this might not even offer any performance benefits once we account for recognizing common ABC subprograms.
~[v'c]
@prim:fixpoint.doc 
"A minimal fixpoint combinator.
     ([([a→b]*a)→b]*e)→([a→b]*e);
~[v'c]
@prim:fixpoint.sto [[^'ow^'zowvr$c]^'ow'o][]
@prim:fixpoint.sto.doc "This 'sto' version of fixpoint stands for 'static transport overhead'. The goal with static transport overhead is to have a very predictable, constant space cost fixpoint functions even for a naive interpretation. This is useful when we serialize fixpoint objects, or especially begin to work with hierarchical structures.
 
  Fpr @prim:fixpoint, I will use the expanded form to better match the bytecode that will commonly be seen on the wire. This may help in context optimization based on recognizing common subprograms.
~[v'c]
@prim:fst [vrw%c][]
@prim:fst.doc 
"(x*y)→x
~
@prim:snd [vr%c][]
@prim:snd.doc 
"(x*y)→y
~
@prim:swap [vrwlc][]
@prim:swap.doc 
"(x*y)→(y*x)
~
@r [rrrwzlwll][]
@r.doc "((x*y)*z) -- (x*(y*z))
~
@repeat.doc 
"a [a -- a] n -- a; repeat block `n` times
~[v'c]
@swapd [rw {%swap} wl][]
@rot [{%swapd}{%swap}][]
@roll [rw {%rot} wl {%swap}][]
@roll2 [{%swap}][]
@roll2d [{%swapd}][]
@roll3 [{%rot}][]
@rotd [rw {%rot} wl][]
@roll3d [{%rotd}][]
@roll4 [{%roll}][]
@rolld [rw {%roll} wl][]
@roll4d [{%rolld}][]
@roll5 [rw {%roll4} wl {%swap}][]
@roll5d [rw {%roll5} wl][]
@roll6 [rw {%roll5} wl {%swap}][]
@roll6d [rw {%roll6} wl][]
@roll7 [rw {%roll6} wl {%swap}][]
@roll7d [rw {%roll7} wl][]
@roll8 [rw {%roll7} wl {%swap}][]
@roll8d [rw {%roll8} wl][]
@roll9 [rw {%roll8} wl {%swap}][]
@roll9d [rw {%roll9} wl][]
@spin [{%swap}{%swapd}{%swap}][]
@stack:fst [rrw%l][]
@stack:l [rrwrzwlll][]
@stack:l.doc "(x*(y*z)) -- ((x*y)*z)
~
@stack:p.doc 
"y x -- (x*y)
~
@stack:r [rrrwzlwll][]
@stack:r.doc "((x*y)*z) -- (x*(y*z))
~
@stack:snd [rr%l][]
@stack:w [rrwll][]
@stack:w.doc "(x*y) -- (y*x)
~
@stack:x [rrwzlwl][]
@stack:x.doc 
"(x*y) -- y x
~
@subtract [{%math:subtract}][]
@tuck [{%dup} {%swapd}][]
@unit [{%intro1}][]
@unrot [{%swap}{%swapd}][]
@unroll [{%swap} rw {%unrot} wl][]
@unroll2 [{%swap}][]
@unroll2d [{%swapd}][]
@unroll3 [{%unrot}][]
@unrotd [rw {%unrot} wl][]
@unroll3d [{%unrotd}][]
@unroll4 [{%unroll}][]
@unrolld [rw {%unroll} wl][]
@unroll4d [{%unrolld}][]
@unroll5 [{%swap} rw {%unroll4} wl][]
@unroll5d [rw {%unroll5} wl][]
@unroll6 [{%swap} rw {%unroll5} wl][]
@unroll6d [rw {%unroll6} wl][]
@unroll7 [{%swap} rw {%unroll6} wl][]
@unroll7d [rw {%unroll7} wl][]
@unroll8 [{%swap} rw {%unroll7} wl][]
@unroll8d [rw {%unroll8} wl][]
@unroll9 [{%swap} rw {%unroll8} wl][]
@unroll9d [rw {%unroll9} wl][]
@v_ [vrwvrwlc][]
@v_.doc 
"(a*e)→((a*1)*e)
~[v'c]
@w_ [rwrwzwlwl][]
@x.doc 
"(x*y) -- y x
~
@z_ [rw {%w_} wl][]
