@integer l
@block l
@inner..abs #>[-vrw%c]?VRW[%]?WLCM
@.abs r{%inner..abs}l
@p rwrzwll
@.add {%p}rr+l
@addend.s.onElem rw'ovrwrwz'owlVc
@addend.s.onFini r%vr$c
@addend.s.step lwvvrwlcw$wD[{%addend.s.onElem}]?VRW[{%addend.s.onFini}]?WLCMc
@.firstfixfirst.v2 '[^'ow^'zowvr$c]^'owo
@.firstfixfirst {%.firstfixfirst.v2}
@.addend.s [{%addend.s.step}]{%.firstfixfirst}w'ow'o
@.app1 vvr$c
@.app1e vvrrz$lc
@.apply {%p}rr$l
@.apply1 r{%.app1e}l
@swap rwrwzwlwl
@.applyd {%swap}{%.apply}
@.assertFirstUnit vrvrwlcrwlc
@.assertUnit vvrwlcc
@w rrwll
@pw {%p}{%w}
@bind {%pw}rr'[l]wool
@.bapply [{%.apply}]{%block}{%bind}
@.bfirst r'[$]wol
@dup r^zlwl
@.rw rw
@.wl wl
@swapd {%.rw}{%swap}{%.wl}
@tuck {%dup}{%swapd}
@.bi {%tuck}{%.apply}{%.rw}{%.apply}{%.wl}
@.bidup {%dup}{%.rw}{%.apply}{%swap}{%.wl}{%.apply}{%swap}
@.bind {%pw}rr'ol
@.swap vrwlc
@compose {%pw}rrol
@composel {%swap}{%compose}
@.bind2nd [{%.swap}]{%block}{%composel}{%.bind}
@.bleft r'[v]o[?c]wol
@handStackSwap w
@hsw {%handStackSwap}
@put wrzl
@take {%hsw}{%put}{%hsw}
@x rrwzlwl
@.first {%take}{%x}{%put}{%.apply}{%p}
@.second {%take}{%pw}{%put}{%.first}{%pw}
@.both {%take}{%.first}{%put}{%.second}
@.bright r'[vVRW]o[?WLCc]wol
@.bsecond r'[vrw]o[$wlc]wol
@.curry [{%.bind}]{%block}{%bind}
@.inv 
@.mul {%p}rr*l
@.div {%.inv}{%.mul}
@wx {%w}{%x}
@.divMod {%p}rrQll{%wx}
@unrot {%swap}{%swapd}
@.left {%p}rr?l
@not rVRWLCl
@notd {%swap}{%not}{%swap}
@.right {%notd}{%.left}{%not}
@.either {%unrot}{%.left}{%swap}{%.right}
@distrib {%p}rrDl
@.eitherBind {%pw}{%distrib}r[rw%vrw'oc]?VRW[r%vrw'oc]?WLCl
@.firstfixfirst.v1 [^'o]o^'o
@.fixfirst r{%.firstfixfirst}l
@flatten.s.onElem wvrwrw'o{%.addend.s}vr$c
@.inR vVVRWLCc
@flatten.s.step wvvrwlcw$wD[{%flatten.s.onElem}]?VRW[%{%.inR}]?WLCMc
@.flatten.s [{%flatten.s.step}]{%.firstfixfirst}w'o
@fmap.s.onElem rz$vrwrw'owlc
@fmap.s.step lwvvrwlcw$wD[{%fmap.s.onElem}]?VRW[%]?WLCc
@.fmap.s [{%fmap.s.step}]w'o{%.firstfixfirst}w'o
@.fromStateSplitNext.r.next rrr%z$rz'olc
@fromStateSplitNext.r.split rrrw%z$rzw^zw'owzw'olc
@.fromStateSplitNext.r.step llvrD[{%.fromStateSplitNext.r.next}]?VRW[{%fromStateSplitNext.r.split}]?WLCMc
@.fromStateSplitNext.r {%pw}[{%.fromStateSplitNext.r.step}]{%block}{%.bind}{%.fixfirst}{%.bind}
@.fst vrw%c
@.gt {%p}rr>l
@.mirror VRWLC
@.snd vr%c
@.lte1 {%p}rr>[{%.fst}]?{%.mirror}[{%.snd}]?l
@.gt1 {%.lte1}{%not}
@trimBoolean.arity1e Fw%
@toBoolean.arity1e vvrwlcD{%trimBoolean.arity1e}
@toBoolean r{%toBoolean.arity1e}l
@.gtb {%.gt}{%toBoolean}
@.lt {%p}rrw>l
@.gte {%.lt}{%not}
@.gte1 {%p}rrw>[{%.snd}]?{%.mirror}[{%.fst}]?l
@.gteb {%.gte}{%toBoolean}
@.inL vVc
@.lt1 {%.gte1}{%not}
@.ltb {%.lt}{%toBoolean}
@.lte {%.gt}{%not}
@.lteb {%.lte}{%toBoolean}
@.neg r-l
@pmap.s.onElem rz$rz'ovrwrwz'owlc
@pmap.s.step wlwvvrwlcw$wD[{%pmap.s.onElem}]?VRW[%]?WLCc
@.pmap.s [{%pmap.s.step}]{%.firstfixfirst}w'ow'o
@.postbind_pw r[{%pw}]wol
@.prebind_l r[l]ol
@.quot {%p}rrQ%l
@.rem {%p}rrQw%l
@.square {%dup}{%.mul}
@.state.p0.step wvrwr$rz'olc
@.state.p0 [{%.state.p0.step}]{%block}{%.bind}{%.fixfirst}{%.bind}
@.sub {%.neg}{%.add}
@.tri {%tuck}{%.apply}{%.rw}{%.bi}{%.wl}
@rot {%swapd}{%swap}
@.tridup {%dup}{%.rw}{%.apply}{%rot}{%.wl}{%dup}{%.rw}{%.apply}{%rot}{%.wl}{%.apply}{%rot}
@intro1 vvrwlcl
@inR rVVRWLCl
@empty.l {%intro1}{%inR}
@inL rVl
@cons.l {%p}{%inL}
@LF {%empty.l}#10{%integer}{%cons.l}
@inRL {%inL}{%inR}
@LT {%intro1}{%inRL}
@literal l
@TODO.AO "Much to do about AO
  * functions for association lists, maps, records, or similar
   *   maybe support for tables, too; relational algebra
   *     ideally a DSL supporting composition, optimization, compilation
  * consider 'measured' trees, with arbitrary monoid to cache information
   * e.g. size information
  * persistent union-find
  * working with embedded binary data (alphabet a-z minus aeiou,vrwlc).
  * access to bytecodes: reflection/introspection
  * transpile ABC to JavaScript
  * functions for matrices and vector
  * look into FGL graph library (manipulating graphs with a zipper)
  * functions for sequences (finger-trees/ropes)
  * functions for parser combinators; grammar DSL
   *   should support derivative grammars & deep optimizations
  * AO bootstrap; optimizers and compilers for ABC, AO
   *   eventually do typechecking
   *   eventually get to AMBC
  * develop a colors/materials model? 
   *   named palette plus RGB? meh. 
   *   a DSL for mixing, lightening, and darkening colors?
   *   maybe a richer 'materials' model (cf. POV-ray) 
    *     with shine, roughness, transparency, etc.
    *     procedural texture generation, perlin noise
    *     automatic generation from images
    *     suitable for use in games...
  * functions for text, utf-8, binary, base64
   *   implement as stream transformers?
  * functions for kd-trees, geometries, scene-graphs
  * functions for textures, jpegs, gifs, compression and decompression
  * contraint models for staged dependency/policy/typeclass injection 
  * project euler? rosetta code? a simple tetris/breakout game?
   *   need a lot more performance, first!
  * simplified app type for quick integration with Haskell? (use plugins?)
  * 2D-3D scene-graphs based on enneatrees and zippers
  * secure pseduo-random number generators; probabilistic programs
  * math libs - linear algebra, symbolic maths
  * knowledge database or encyclopedia?
   *   unicode
   *   world data? (countries, flags, populations, maps)
 
 AO's design philosophy is actually similar to Wolfram's - that code should have easy access to vast quantities of useful, maintainable data. AO provides this access in the form of words in a very large dictionary.
~{%literal}
@TODO.RandomNumbers "To really support random numbers, I require a lot more work.
 
 I should be able to:
 
 * generate arbitrary K-bit words and fractionals (trivial!)
 * generate arbitrary uniforms (e.g. 6 sided dice)
 * model 'weighted' dice 
 
 A lot work exists in this area. Relevant keywords and articles:
 
 * sampling from a discrete distribution
 * Darts, Dice, and Coins: http://www.keithschwarz.com/darts-dice-coins/
 * Alias method
 * Vose's algorithm
~{%literal}
@abc:C C
@abc:L L
@abc:R R
@abc:V V
@abc:W W
@abc:Z Z
@abc:add +
@abc:affine f
@abc:apply $
@abc:assert K
@abc:block 
@abc:c c
@abc:compose o
@abc:condap ?
@abc:copy ^
@abc:d0 0
@abc:d1 1
@abc:d2 2
@abc:d3 3
@abc:d4 4
@abc:d5 5
@abc:d6 6
@abc:d7 7
@abc:d8 8
@abc:d9 9
@abc:decimal 
@abc:distrib D
@abc:divMod Q
@abc:drop %
@abc:factor F
@abc:gt >
@abc:integer 
@abc:l l
@abc:merge M
@abc:mul *
@abc:negate -
@abc:newZero #
@abc:quote '
@abc:r r
@abc:ratio 
@abc:relevant k
@abc:v v
@abc:w w
@abc:z z
@abcBase16Alphabet "bdfghjkmnpqstxyz
~{%literal}
@abs.arity1 v{%inner..abs}c
@roll {%.rw}{%rot}{%.wl}{%swap}
@dip rwrzvrwr$wlcl
@inline rvr$c
@action.eachUntil.l {%wx}{%roll}{%pw}{%rot}{%dip}{%wx}{%inline}
@dec r#1-+l
@dip2 rwrwrzlzvrwr$wlcrzlwl
@action.repeat {%dec}{%unrot}{%dip2}{%inline}
@add.arity2 vr+c
@unseal.stats r{.stats}l
@inc r#1+l
@copy {%dup}{%take}
@paste {%hsw}{%copy}{%hsw}
@seal.stats r{:stats}l
@add.stats {%take}{%unseal.stats}{%x}{%inc}{%swap}{%x}{%paste}{%.add}{%swap}{%put}{%dup}{%.mul}{%.add}{%pw}{%pw}{%seal.stats}
@addend.s [{%addend.s.step}]{%block}{%.fixfirst}{%.bind}{%.bind}
@affine rfl
@alignToFrac {%dup}rw{%.quot}wl{%.mul}
@and.b {%distrib}rVRW[c]?WLCL[v%]?l
@dx {%.rw}{%x}{%.wl}
@dupd {%.rw}{%dup}{%.wl}
@dp {%.rw}{%p}{%.wl}
@bindKVCmp.AATree {%dx}{%dupd}{%.bind}{%dp}
@node.insertKV.AATree {%dx}{%dx}{%dup}{%.apply}{%dp}{%dp}{&TODO}
@taked {%swap}{%take}
@hfix.v3 {%put}r[l{%take}]ol{%.fixfirst}{%take}
@hfix {%hfix.v3}
@hap {%put}{%inline}
@drop r%
@discard {%put}{%drop}
@empty.AATree {%intro1}{%inR}
@singleton.AATree {%empty.AATree}{%empty.AATree}{%inR}{%pw}{%pw}{%inL}
@leaf.insertKV.AATree {%discard}{%put}{%singleton.AATree}{%swap}{%inR}
@eitherBind {%.prebind_l}{%.rw}{%.prebind_l}{%.wl}{%.eitherBind}
@merge rMl
@if {%eitherBind}{%merge}{%inline}
@tree.insertKV.AATree [{%hap}]{%block}[{%leaf.insertKV.AATree}]{%block}{%if}
@apEnv.insertKV.AATree {%bindKVCmp.AATree}[{%node.insertKV.AATree}]{%block}{%bind}{%taked}{%take}{%hfix}{%tree.insertKV.AATree}
@apcar {%dx}{%.apply}{%p}
@apcaar {%dx}{%apcar}{%p}
@apcaaar {%dx}{%apcaar}{%p}
@apcaaaar {%dx}{%apcaaar}{%p}
@apcaaaaar {%dx}{%apcaaaar}{%p}
@dwx {%.rw}{%wx}{%.wl}
@apcaaaadr {%dwx}{%apcaaaar}{%pw}
@apcaaadr {%dwx}{%apcaaar}{%pw}
@apcaaadar {%dx}{%apcaaadr}{%p}
@apcaaaddr {%dwx}{%apcaaadr}{%pw}
@apcaadr {%dwx}{%apcaar}{%pw}
@apcaadar {%dx}{%apcaadr}{%p}
@apcaadaar {%dx}{%apcaadar}{%p}
@apcaadadr {%dwx}{%apcaadar}{%pw}
@apcaaddr {%dwx}{%apcaadr}{%pw}
@apcaaddar {%dx}{%apcaaddr}{%p}
@apcaadddr {%dwx}{%apcaaddr}{%pw}
@apcadr {%dwx}{%apcar}{%pw}
@apcadar {%dx}{%apcadr}{%p}
@apcadaar {%dx}{%apcadar}{%p}
@apcadaaar {%dx}{%apcadaar}{%p}
@apcadaadr {%dwx}{%apcadaar}{%pw}
@apcadadr {%dwx}{%apcadar}{%pw}
@apcadadar {%dx}{%apcadadr}{%p}
@apcadaddr {%dwx}{%apcadadr}{%pw}
@apcaddr {%dwx}{%apcadr}{%pw}
@apcaddar {%dx}{%apcaddr}{%p}
@apcaddaar {%dx}{%apcaddar}{%p}
@apcaddadr {%dwx}{%apcaddar}{%pw}
@apcadddr {%dwx}{%apcaddr}{%pw}
@apcadddar {%dx}{%apcadddr}{%p}
@apcaddddr {%dwx}{%apcadddr}{%pw}
@apcdr {%dwx}{%.apply}{%pw}
@apcdar {%dx}{%apcdr}{%p}
@apcdaar {%dx}{%apcdar}{%p}
@apcdaaar {%dx}{%apcdaar}{%p}
@apcdaaaar {%dx}{%apcdaaar}{%p}
@apcdaaadr {%dwx}{%apcdaaar}{%pw}
@apcdaadr {%dwx}{%apcdaar}{%pw}
@apcdaadar {%dx}{%apcdaadr}{%p}
@apcdaaddr {%dwx}{%apcdaadr}{%pw}
@apcdadr {%dwx}{%apcdar}{%pw}
@apcdadar {%dx}{%apcdadr}{%p}
@apcdadaar {%dx}{%apcdadar}{%p}
@apcdadadr {%dwx}{%apcdadar}{%pw}
@apcdaddr {%dwx}{%apcdadr}{%pw}
@apcdaddar {%dx}{%apcdaddr}{%p}
@apcdadddr {%dwx}{%apcdaddr}{%pw}
@apcddr {%dwx}{%apcdr}{%pw}
@apcddar {%dx}{%apcddr}{%p}
@apcddaar {%dx}{%apcddar}{%p}
@apcddaaar {%dx}{%apcddaar}{%p}
@apcddaadr {%dwx}{%apcddaar}{%pw}
@apcddadr {%dwx}{%apcddar}{%pw}
@apcddadar {%dx}{%apcddadr}{%p}
@apcddaddr {%dwx}{%apcddadr}{%pw}
@apcdddr {%dwx}{%apcddr}{%pw}
@apcdddar {%dx}{%apcdddr}{%p}
@apcdddaar {%dx}{%apcdddar}{%p}
@apcdddadr {%dwx}{%apcdddar}{%pw}
@apcddddr {%dwx}{%apcdddr}{%pw}
@apcddddar {%dx}{%apcddddr}{%p}
@apcdddddr {%dwx}{%apcddddr}{%pw}
@dpw {%.rw}{%pw}{%.wl}
@each.l.action {%wx}wlwl{%dpw}{%dip}{%wx}{%inline}
@elim1 rvrwlcc
@each.l.fini {%elim1}wl{%drop}wl{%drop}
@each.l.step wzw[{%each.l.action}]{%block}[{%each.l.fini}]{%block}{%if}
@each.l [{%each.l.step}]{%block}{%.bind}{%.fixfirst}{%inline}
@compressArgs {%dpw}[{%wx}]{%block}{%composel}
@apply1to1.stackHand.env rwrzvrwvvrrvrrz$wlcllccwlcl
@apply1to1.std.env {%apply1to1.stackHand.env}
@apply {%apply1to1.std.env}
@apply1to1 {%apply}
@apply2to1 {%compressArgs}{%apply1to1}
@apply3to1 {%compressArgs}{%apply2to1}
@fold.l [{%each.l}]{%block}{%apply3to1}
@reverseAppend.l [{%cons.l}]{%block}{%fold.l}
@reverse.l {%empty.l}{%swap}{%reverseAppend.l}
@append.l {%swap}{%reverse.l}{%reverseAppend.l}
@appendl.l {%swap}{%append.l}
@wrap.stackHand.env vvvr
@wrap.std.env {%wrap.stackHand.env}
@preApply {%wrap.std.env}
@unwrap.stackHand.env lccc
@unwrap.std.env {%unwrap.stackHand.env}
@postApply {%unwrap.std.env}
@applyWrap r[{%preApply}]o[{%postApply}]wol
@apply.alt {%applyWrap}{%.apply}
@apply0to0.stackHand.env rvvvrrvrrz$wlcllccc
@apply0to0.std.env {%apply0to0.stackHand.env}
@apply0to0 {%apply0to0.std.env}
@apply0to1.stackHand.env rvvvrrvrrz$wlcllccwlcl
@apply0to1.std.env {%apply0to1.stackHand.env}
@apply0to1 {%apply0to1.std.env}
@apply0to2 {%.postbind_pw}{%apply0to1}{%wx}
@apply0to3 {%.postbind_pw}{%apply0to2}{%wx}
@apply0to4 {%.postbind_pw}{%apply0to3}{%wx}
@apply0to5 {%.postbind_pw}{%apply0to4}{%wx}
@apply0to6 {%.postbind_pw}{%apply0to5}{%wx}
@apply0to7 {%.postbind_pw}{%apply0to6}{%wx}
@apply1to0.stackHand.env rwrzvrwvvrrvrrz$wlcllccc
@apply1to0.std.env {%apply1to0.stackHand.env}
@apply1to0 {%apply1to0.std.env}
@roll2 {%swap}
@apply1to0d {%roll2}{%apply1to0}
@apply1to1d {%roll2}{%apply1to1}
@apply1to2 {%.postbind_pw}{%apply1to1}{%wx}
@apply1to2d {%roll2}{%apply1to2}
@apply1to3 {%.postbind_pw}{%apply1to2}{%wx}
@apply1to3d {%roll2}{%apply1to3}
@apply1to4 {%.postbind_pw}{%apply1to3}{%wx}
@apply1to4d {%roll2}{%apply1to4}
@apply1to5 {%.postbind_pw}{%apply1to4}{%wx}
@apply1to5d {%roll2}{%apply1to5}
@apply1to6 {%.postbind_pw}{%apply1to5}{%wx}
@apply1to6d {%roll2}{%apply1to6}
@apply1to7 {%.postbind_pw}{%apply1to6}{%wx}
@apply1to7d {%roll2}{%apply1to7}
@apply2to0 {%compressArgs}{%apply1to0}
@roll3 {%rot}
@apply2to0d {%roll3}{%apply2to0}
@apply2to1d {%roll3}{%apply2to1}
@apply2to2 {%compressArgs}{%apply1to2}
@apply2to2d {%roll3}{%apply2to2}
@apply2to3 {%compressArgs}{%apply1to3}
@apply2to3d {%roll3}{%apply2to3}
@apply2to4 {%compressArgs}{%apply1to4}
@apply2to4d {%roll3}{%apply2to4}
@apply2to5 {%compressArgs}{%apply1to5}
@apply2to5d {%roll3}{%apply2to5}
@apply2to6 {%compressArgs}{%apply1to6}
@apply2to6d {%roll3}{%apply2to6}
@apply2to7 {%compressArgs}{%apply1to7}
@apply2to7d {%roll3}{%apply2to7}
@apply3to0 {%compressArgs}{%apply2to0}
@roll4 {%roll}
@apply3to0d {%roll4}{%apply3to0}
@apply3to1d {%roll4}{%apply3to1}
@apply3to2 {%compressArgs}{%apply2to2}
@apply3to2d {%roll4}{%apply3to2}
@apply3to3 {%compressArgs}{%apply2to3}
@apply3to3d {%roll4}{%apply3to3}
@apply3to4 {%compressArgs}{%apply2to4}
@apply3to4d {%roll4}{%apply3to4}
@apply3to5 {%compressArgs}{%apply2to5}
@apply3to5d {%roll4}{%apply3to5}
@apply3to6 {%compressArgs}{%apply2to6}
@apply3to6d {%roll4}{%apply3to6}
@apply3to7 {%compressArgs}{%apply2to7}
@apply3to7d {%roll4}{%apply3to7}
@apply4to0 {%compressArgs}{%apply3to0}
@roll5 {%.rw}{%roll4}{%.wl}{%swap}
@apply4to0d {%roll5}{%apply4to0}
@apply4to1 {%compressArgs}{%apply3to1}
@apply4to1d {%roll5}{%apply4to1}
@apply4to2 {%compressArgs}{%apply3to2}
@apply4to2d {%roll5}{%apply4to2}
@apply4to3 {%compressArgs}{%apply3to3}
@apply4to3d {%roll5}{%apply4to3}
@apply4to4 {%compressArgs}{%apply3to4}
@apply4to4d {%roll5}{%apply4to4}
@apply4to5 {%compressArgs}{%apply3to5}
@apply4to5d {%roll5}{%apply4to5}
@apply4to6 {%compressArgs}{%apply3to6}
@apply4to6d {%roll5}{%apply4to6}
@apply4to7 {%compressArgs}{%apply3to7}
@apply4to7d {%roll5}{%apply4to7}
@apply5to0 {%compressArgs}{%apply4to0}
@roll6 {%.rw}{%roll5}{%.wl}{%swap}
@apply5to0d {%roll6}{%apply5to0}
@apply5to1 {%compressArgs}{%apply4to1}
@apply5to1d {%roll6}{%apply5to1}
@apply5to2 {%compressArgs}{%apply4to2}
@apply5to2d {%roll6}{%apply5to2}
@apply5to3 {%compressArgs}{%apply4to3}
@apply5to3d {%roll6}{%apply5to3}
@apply5to4 {%compressArgs}{%apply4to4}
@apply5to4d {%roll6}{%apply5to4}
@apply5to5 {%compressArgs}{%apply4to5}
@apply5to5d {%roll6}{%apply5to5}
@apply5to6 {%compressArgs}{%apply4to6}
@apply5to6d {%roll6}{%apply5to6}
@apply5to7 {%compressArgs}{%apply4to7}
@apply5to7d {%roll6}{%apply5to7}
@apply6to0 {%compressArgs}{%apply5to0}
@roll7 {%.rw}{%roll6}{%.wl}{%swap}
@apply6to0d {%roll7}{%apply6to0}
@apply6to1 {%compressArgs}{%apply5to1}
@apply6to1d {%roll7}{%apply6to1}
@apply6to2 {%compressArgs}{%apply5to2}
@apply6to2d {%roll7}{%apply6to2}
@apply6to3 {%compressArgs}{%apply5to3}
@apply6to3d {%roll7}{%apply6to3}
@apply6to4 {%compressArgs}{%apply5to4}
@apply6to4d {%roll7}{%apply6to4}
@apply6to5 {%compressArgs}{%apply5to5}
@apply6to5d {%roll7}{%apply6to5}
@apply6to6 {%compressArgs}{%apply5to6}
@apply6to6d {%roll7}{%apply6to6}
@apply6to7 {%compressArgs}{%apply5to7}
@apply6to7d {%roll7}{%apply6to7}
@apply7to0 {%compressArgs}{%apply6to0}
@roll8 {%.rw}{%roll7}{%.wl}{%swap}
@apply7to0d {%roll8}{%apply7to0}
@apply7to1 {%compressArgs}{%apply6to1}
@apply7to1d {%roll8}{%apply7to1}
@apply7to2 {%compressArgs}{%apply6to2}
@apply7to2d {%roll8}{%apply7to2}
@apply7to3 {%compressArgs}{%apply6to3}
@apply7to3d {%roll8}{%apply7to3}
@apply7to4 {%compressArgs}{%apply6to4}
@apply7to4d {%roll8}{%apply7to4}
@apply7to5 {%compressArgs}{%apply6to5}
@apply7to5d {%roll8}{%apply7to5}
@apply7to6 {%compressArgs}{%apply6to6}
@apply7to6d {%roll8}{%apply7to6}
@apply7to7 {%compressArgs}{%apply6to7}
@apply7to7d {%roll8}{%apply7to7}
@applyStoS.stackHand.env rwvvrrwvrrz$wlcwllcc
@applyStoS.std.env {%applyStoS.stackHand.env}
@applyS {%applyStoS.std.env}
@applyd {%swap}{%apply}
@assert rKl
@inLd {%.rw}{%inL}{%.wl}
@t.assertBalanced.AATree {%take}[{%put}{%inline}{%inLd}{%inc}]{%block}[{%discard}{%inR}#{%integer}]{%block}{%if}
@inRd {%.rw}{%inR}{%.wl}
@rt.assertBalanced.AATree {%take}[{%put}{%inline}{%inLd}]{%block}[{%put}{%t.assertBalanced.AATree}{%inRd}]{%block}{%if}
@neq rwrzw>[vr>c]?Rl
@eq {%neq}{%not}
@assertEQ.n {%eq}{%assert}{%x}
@assertEQ1.n {%assertEQ.n}{%drop}
@n.assertBalanced.AATree {%take}{%wx}{%wx}{%paste}{%rt.assertBalanced.AATree}{%rot}{%put}{%t.assertBalanced.AATree}{%swapd}{%assertEQ1.n}{%take}{%p}{%pw}{%put}
@fixpoint.v4 {%.prebind_l}{%.fixfirst}
@fixpoint {%fixpoint.v4}
@r.assertBalanced.AATree [{%n.assertBalanced.AATree}]{%block}{%fixpoint}{%t.assertBalanced.AATree}{%drop}
@assertBalanced.AATree [{%r.assertBalanced.AATree}]{%block}{%apply1to1}
@unseal.rbt r{.rbt}l
@car {%x}{%dup}{%dp}
@cadr {%wx}{%car}{%dpw}
@n.color.rbt {%cadr}
@hapc {%paste}{%inline}
@black.assertBalanced.rbt {%wx}{%wx}{%x}{%hapc}{%rot}{%hap}{%swapd}{%assertEQ1.n}{%inc}{%dpw}{%dpw}{%dpw}
@black.rbt {%intro1}{%inL}
@seal.rbt r{:rbt}l
@seald.rbt {%.rw}{%seal.rbt}{%.wl}
@t.color.rbt {%unseal.rbt}[{%black.rbt}{%inLd}]{%block}[{%n.color.rbt}{%inRd}]{%block}{%if}{%seald.rbt}
@mirror {%not}
@assertInL {%mirror}{%assert}
@assertBlack.rbt {%t.color.rbt}{%assertInL}{%elim1}
@red.assertBalanced.rbt {%wx}{%wx}{%x}{%assertBlack.rbt}{%hapc}{%rot}{%assertBlack.rbt}{%hap}{%swapd}{%assertEQ1.n}{%dpw}{%dpw}{%dpw}
@fst rrw%l
@condSelect_ {%p}{%distrib}r[rwl]?FMw%l{%fst}
@if_ {%condSelect_}{%inline}
@n.assertBalanced.rbt {%n.color.rbt}[{%black.assertBalanced.rbt}]{%block}[{%red.assertBalanced.rbt}]{%block}{%if_}
@t.assertBalanced.rbt {%unseal.rbt}[{%discard}{%inL}#{%integer}]{%block}[{%n.assertBalanced.rbt}{%inRd}]{%block}{%if}{%seald.rbt}
@h.assertBalanced.rbt [{%t.assertBalanced.rbt}]{%block}{%take}{%hfix}{%hap}
@assertBalanced.rbt {%h.assertBalanced.rbt}{%drop}
@assertBoolean rVR[{%.assertUnit}]?W[{%.assertUnit}]?WLCl
@gte {%.gte}
@assertGTE {%gte}{%assert}{%x}
@assertGTEz #{%integer}{%assertGTE}{%drop}
@assertInteger r#+l
@assertNatural {%assertGTEz}{%assertInteger}
@lt {%.lt}
@assertLT {%lt}{%assert}{%wx}
@assertChar {%assertNatural}#1114112{%integer}{%assertLT}{%drop}
@assertEQ {%pw}rr{&≡}ll{%wx}
@assertEQ1 {%assertEQ}{%drop}
@assertEQ1d {%swapd}{%assertEQ1}{%swap}
@assertEQ1d.n {%swapd}{%assertEQ1.n}{%swap}
@rotd {%.rw}{%rot}{%.wl}
@assertEQ1dd {%rotd}{%assertEQ1}{%unrot}
@assertEQ1dd.n {%rotd}{%assertEQ1.n}{%unrot}
@rolld {%.rw}{%roll}{%.wl}
@unroll {%swap}{%.rw}{%unrot}{%.wl}
@assertEQ1ddd {%rolld}{%assertEQ1}{%unroll}
@assertEQ1ddd.n {%rolld}{%assertEQ1.n}{%unroll}
@assertEQz #{%integer}{%assertEQ.n}{%drop}
@assertEmpty.l {%assert}{%inR}
@gt {%.gt}
@assertGT {%gt}{%assert}{%x}
@assertGTz #{%integer}{%assertGT}{%drop}
@assertInR {%assert}
@assertIsolated r{&isolated}l
@lte {%.lte}
@assertLTE {%lte}{%assert}{%wx}
@assertLTEz #{%integer}{%assertLTE}{%drop}
@assertLTz #{%integer}{%assertLT}{%drop}
@assertNEQ.n {%neq}{%assert}[vrwlc]{%block}{%.left}{%merge}{%x}
@assertNEQz #{%integer}{%assertNEQ.n}{%drop}
@assertNatural+ {%assertGTz}{%assertInteger}
@assertNonEmpty.l {%mirror}{%assert}{%inL}
@assertNumber #{%integer}{%.add}
@assertOctet {%assertNatural}#256{%integer}{%assertLT}{%drop}
@assertProb {%assertGTEz}#1{%integer}{%assertLTE}{%drop}
@assertProd {%w}{%w}
@assertPure r{&pure}l
@assertSafe r{&safe}l
@assertSum {%mirror}{%mirror}
@over {%dupd}{%swap}
@zip2 {%dx}{%x}{%swapd}{%p}{%dp}
@zipRRA.l.jcons {%zip2}{%swapd}{%cons.l}{%swap}{%wx}{%roll}{%inline}
@zipRRA.l.openA {%swap}[{%zipRRA.l.jcons}]{%block}[{%inR}{%swap}{%inL}{%roll}{%drop}]{%block}{%if}
@zipRRA.l.openB {%unroll}[{%zipRRA.l.openA}]{%block}[{%inR}{%roll}{%drop}]{%block}{%if}
@zipRRA.l.inner [{%zipRRA.l.openB}]{%block}{%fixpoint}{%inline}
@zipRevRemApp.l [{%zipRRA.l.inner}]{%block}{%apply3to3}
@zipRevRem.l {%empty.l}{%unrot}{%zipRevRemApp.l}
@zipRem.l {%zipRevRem.l}{%rot}{%reverse.l}{%unrot}
@assertTextEQ1 {%over}{%zipRem.l}{%assert}{%elim1}{%assert}{%elim1}[{%wx}{%assertEQ1.n}{%drop}]{%block}{%each.l}
@assertTextEQ1d {%swapd}{%assertTextEQ1}{%swap}
@assertUniform {%assertGTEz}#1{%integer}{%assertLT}{%drop}
@assertUnit r{%.assertFirstUnit}l
@asynch r{&asynch}l
@count.stats {%unseal.stats}{%x}{%copy}{%p}{%seal.stats}{%put}
@sum.stats {%unseal.stats}{%wx}{%x}{%copy}{%p}{%pw}{%seal.stats}{%put}
@averageNZ.stats {%count.stats}{%take}{%sum.stats}{%put}{%.div}
@average.stats {%count.stats}#{%integer}{%gt}[#{%integer}]{%block}[{%averageNZ.stats}]{%block}{%if_}
@doc.CompositionIsFirstPrinciple "Every compositional model consists of a trinity: components, operators, and properties. Compositional operators are algebraically closed; they combine two components into a third component. Compositional properties are invariant or inductive over the operators, i.e. `P(x*y)=F(P(x),'*',P(y))`. To the extent the properties `P` are useful and the function `F` is simple, we can reason about the composite based on the components. A set of components may be domain specific (such as diagrams, documents, sounds, and scene-graphs) or more general purpose (such as functions, arrows, matrices, grammars).
 
 Effective use of composition often requires domain-specific tradeoffs between the three aspects. For example, by limiting what components we talk about (just diagrams) we can achieve more useful properties (e.g. bounding areas, efficient occlusion) and more operators (add, scale, rotate, translate, etc.). It is possible to switch between compositional models primarily by staging them, such that the output of one compositional model is translated to a component in another compositional model. 
 
 Composition is useful as a foundation for scalability and modularity. Compositional properties enable developers to reason about components without deep knowledge of the implementation details. Composition operators are also convenient due to their uniformity, i.e. we aren't forced to develop or learn a new ad-hoc language or interface for every object. The uniformity and compositional properties can lead to useful intuitions. In comparison, non-compositional models require an ever deeper knowledge of the dependencies to reason about behavior, and ever more ad-hoc and problem-specific glue code to integrate solutions.
 
 Many models favored in conventional programming practice - including state machines, records, process loops, nominative types, conventional conditional expressions, even parametric abstraction - are not compositional. Fortunately, compositional alternatives are available. Grammars can operate as state machines (via parsing). Datalog or relations can generalize records. Processes can be compositional if we instead model them as partial and incremental (i.e. small-step processes; `µP.a→(P*b)`). Nominative types can be replaced with structural types. If/then/else and ad-hoc pattern-case conditional expressions can be replaced with a structural sum types. Ad-hoc parametric abstraction can often be replaced with staging and a reader monad.
 
 Awelon project strongly favors compositional models and designs. This should be reflected in AO's dictionaries and ontologies. I ask that all AO developers embrace composition as first design principle, pervasively, with priority over most other features.
 
 AO is designed to serve as a relatively generic compositional layer, to enable integration or translation of domain-specific models. AO's words are themselves software components. AO's compositional properties - especially causal commutativity, spatial idempotence, substructural types, and capability security - are very useful in this role. AO is also designed to mitigate common weaknesses of deeply layered abstractions by aggressive use of partial evaluation, dependent type analysis, and program search.
~{%literal}
@neq1 {%neq}r[{%.snd}]?VRWR[{%.fst}]?W[{%.snd}]?WLWLCl
@eq1 {%neq1}{%not}
@eq1m {%eq1}[vMc]{%block}{%.left}
@neq1m {%eq1m}{%not}
@wrapfn {%swapd}{%compose}{%compose}
@wrapCons.mapReverseAppend.l [{%dip}]{%block}{%bind}[{%swap}]{%block}[{%swap}{%cons.l}]{%block}{%wrapfn}
@mapReverseAppend.l {%wrapCons.mapReverseAppend.l}{%each.l}
@mapReverse.l {%empty.l}{%unrot}{%mapReverseAppend.l}
@pushrv.partition.l [{%dx}{%cons.l}{%p}]{%block}[{%dwx}{%cons.l}{%pw}]{%block}{%if}
@partitionAppendReverse.l {%unrot}{%pw}{%swap}[{%pushrv.partition.l}]{%block}{%fold.l}{%wx}
@partitionReverse.l {%empty.l}{%empty.l}{%rot}{%partitionAppendReverse.l}
@partitionWith.l {%mapReverse.l}{%partitionReverse.l}
@nip {%.rw}{%drop}{%.wl}
@dropd {%nip}
@filterWith.l {%partitionWith.l}{%dropd}
@remove.l [{%neq1m}]{%block}{%bind}{%filterWith.l}
@nub.l.action {%x}{%copy}{%remove.l}{%swap}{%apply}{%put}{%cons.l}
@nub.l.step {%swap}[{%nub.l.action}]{%block}[{%nip}{%inR}]{%block}{%if}
@nub.l [{%nub.l.step}]{%block}{%fixpoint}{%apply}
@ltb {%.ltb}
@keep {%dupd}{%dip}
@wrapObserver.b [{%keep}]{%block}{%bind}[{%distrib}[c]{%block}{%.left}[c]{%block}{%.right}]{%block}{%compose}
@partitionBy.l {%wrapObserver.b}{%partitionWith.l}
@bi* [{%dip}]{%block}{%dip}{%inline}
@bidup {%dup}{%bi*}
@nonEmpty.sortBy.l {%x}{%copy}{%rot}{%bind}{%partitionBy.l}{%swap}{%rot}{%bidup}{%put}{%cons.l}{%append.l}
@drop2 {%drop}{%drop}
@nip2 {%.rw}{%drop2}{%.wl}
@step.sortBy.l {%rot}[{%nonEmpty.sortBy.l}]{%block}[{%nip2}{%inR}]{%block}{%if}
@sortBy.l [{%step.sortBy.l}]{%block}{%bind}{%fixpoint}{%apply}
@bench.docmanip1 {%doc.CompositionIsFirstPrinciple}{%nub.l}[{%ltb}]{%block}{%sortBy.l}
@bench.docmanip2 {%doc.CompositionIsFirstPrinciple}[{%ltb}]{%block}{%sortBy.l}{%nub.l}
@drop3 {%drop}{%drop}{%drop}
@repeat.step {%rot}{%dup}#{%integer}{%gt}[{%drop3}]{%block}[{%action.repeat}]{%block}{%if_}
@repeat {%assertNatural}{%.rw}[{%repeat.step}]{%block}{%bind}{%fixpoint}{%.wl}{%swap}{%inline}
@bench.repeat100k #{%integer}[#4{%integer}{%.add}]{%block}#100000{%integer}{%repeat}#400000{%integer}{%assertEQ1.n}
@bench.repeat10M #{%integer}[#4{%integer}{%.add}]{%block}#10000000{%integer}{%repeat}#40000000{%integer}{%assertEQ1.n}
@bench.repeat10k #{%integer}[#4{%integer}{%.add}]{%block}#10000{%integer}{%repeat}#40000{%integer}{%assertEQ1.n}
@bench.repeat1M #{%integer}[#4{%integer}{%.add}]{%block}#1000000{%integer}{%repeat}#4000000{%integer}{%assertEQ1.n}
@bi [{%keep}]{%block}{%dip}{%inline}
@bi.blockFree {%rot}{%dup}{%dp}{%swap}{%rot}{%dip}{%wx}{%inline}
@dup2 {%pw}{%dup}{%dwx}{%wx}
@keep2 {%.rw}{%dup2}{%pw}{%.wl}{%dip}{%wx}
@bi2 [{%keep2}]{%block}{%dip}{%inline}
@bi2* [{%dip2}]{%block}{%dip}{%inline}
@bi2dup {%dup}{%bi2*}
@dup3 {%pw}{%pw}{%dup}{%dwx}{%dwx}{%wx}{%wx}
@keep3 {%.rw}{%dup3}{%pw}{%pw}{%.wl}{%dip}{%wx}{%wx}
@bi3 [{%keep3}]{%block}{%dip}{%inline}
@dip3 {%dpw}{%dip2}{%wx}
@bi3* [{%dip3}]{%block}{%dip}{%inline}
@bi3dup {%dup}{%bi3*}
@bicons.unzipReverseAppend.l {%wx}{%swapd}{%cons.l}{%unrot}{%cons.l}{%swap}
@bind2 {%bind}{%bind}
@bind2nd [{%swap}]{%block}{%composel}{%bind}
@bind3 {%bind}{%bind}{%bind}
@bind3rd [{%unrot}]{%block}{%composel}{%bind}
@bind4 {%bind}{%bind}{%bind}{%bind}
@bind4th [{%unroll}]{%block}{%composel}{%bind}
@dupfst {%x}{%dup}{%dp}
@bindK.insertKV.bst {%.rw}{%dupfst}{%.wl}{%.bind}
@bindK.insertKV.rbt {%.rw}{%dupfst}{%.wl}{%.bind}
@bindK.insertKV.t23 {%.rw}{%dupfst}{%.wl}{%.bind}
@mul2 r#2*l
@pushBit.bitListToWord [{%mul2}]{%block}[{%mul2}{%inc}]{%block}{%if_}
@bitListToWordK.pushBit {%wx}{%.rw}{%pushBit.bitListToWord}{%.wl}
@mul2d rw{%mul2}wl
@bitListToWordK.step [{%bitListToWordK.pushBit}]{%block}[{%inR}{%mul2d}]{%block}{%if}
@bitListToWordK #{%integer}{%unrot}[{%bitListToWordK.step}]{%block}{%swap}{%repeat}{%drop}
@bitListToOctet #8{%integer}{%bitListToWordK}
@chr:0 #48{%integer}
@chr:1 #49{%integer}
@bitToChar [{%chr:0}]{%block}[{%chr:1}]{%block}{%if_}
@map.l {%mapReverse.l}{%reverse.l}
@bitListToText [{%bitToChar}]{%block}{%map.l}
@bitListToWord #{%integer}{%swap}[{%pushBit.bitListToWord}]{%block}{%each.l}
@take2 {%take}{%take}
@discard2 {%hsw}{%drop2}{%hsw}
@forCount.s.stopOnCount {%discard2}
@put2 {%put}{%put}
@forCount.s.onElem {%wx}{%put}{%dec}{%put2}{%dip3}{%inline}
@empty.s [vvrwlcVVRWLCc]{%block}
@forCount.s.stopOnElem {%elim1}{%empty.s}{%put}{%discard2}
@forCount.s.tryElem {%take}{%intro1}{%.applyd}[{%forCount.s.onElem}]{%block}[{%forCount.s.stopOnElem}]{%block}{%if}
@forCount.s.step {%take2}{%dup}#{%integer}{%gt}[{%forCount.s.stopOnCount}]{%block}[{%forCount.s.tryElem}]{%block}{%if_}
@forCount.s {%assertNatural}{%swap}[{%forCount.s.step}]{%block}{%bind}{%fixpoint}{%inline}
@inner.take.s {%empty.l}{%unrot}[{%cons.l}]{%block}{%swap}{%forCount.s}
@take.s {%inner.take.s}{%drop}{%swap}{%reverse.l}
@taking.s.step {%take.s}[{%inL}{%p}{%inL}]{%block}[{%inR}{%dropd}]{%block}{%if}
@fromState.s.step z$wD[vrwrwz'owlc]?VRW[%]?WLCc
@fromState.s [{%fromState.s.step}]{%block}{%.bind}{%.fixfirst}{%.bind}
@fromStateE.s {%applyWrap}{%fromState.s}
@taking.s {%assertNatural+}[{%taking.s.step}]{%block}{%bind}{%fromStateE.s}
@fmap.s [{%fmap.s.step}]{%block}{%.bind}{%.fixfirst}{%.bind}
@fmapE.s {%applyWrap}{%fmap.s}
@map.s {%fmapE.s}
@bitStreamToOctetStream #8{%integer}{%taking.s}[{%bitListToOctet}]{%block}{%map.s}
@bitStreamToText [{%bitToChar}]{%block}{%map.s}
@bitStreamToWordKStream {%copy}{%taking.s}{%put}[{%bitListToWordK}]{%block}{%bind}{%map.s}
@n.blackHeight.AATree {%wx}{%x}{%put}{%inline}{%dp}{%dpw}
@t.blackHeight.AATree {%take}[{%n.blackHeight.AATree}{%inLd}{%inc}]{%block}[{%discard}{%inR}#{%integer}]{%block}{%if}
@blackHeight.AATree [{%t.blackHeight.AATree}]{%block}{%fixpoint}{%apply1to2}
@n.blackHeight.rbt {%wx}{%wx}{%x}{%hap}{%dp}{%dpw}{%dpw}{%take}{%n.color.rbt}[{%hsw}{%inc}{%hsw}]{%block}[]{%block}{%if_}{%put}
@t.blackHeight.rbt {%unseal.rbt}[{%discard}{%inL}#{%integer}]{%block}[{%n.blackHeight.rbt}{%inRd}]{%block}{%if}{%seald.rbt}
@blackHeight.rbt [{%t.blackHeight.rbt}]{%block}{%take}{%hfix}{%hap}
@decd rw{%dec}wl
@body.repeatUntil {%dip2}{%decd}{%inline}
@not.b rVRWLCl
@consd.l {%swap}{%dp}{%inLd}
@part.spanRAP.l {%x}{%put}{%.apply}[{%cons.l}{%discard}]{%block}[{%consd.l}{%put}{%inline}]{%block}{%if}
@open.spanRAP.l {%swap}{%take2}[{%part.spanRAP.l}]{%block}[{%inR}{%discard2}]{%block}{%if}
@spanRevAppP.l {%applyWrap}[{%open.spanRAP.l}]{%block}{%bind}{%fixpoint}{%apply2to2}
@spanRevP.l {%empty.l}{%unrot}{%spanRevAppP.l}{%swap}
@spanP.l {%spanRevP.l}{%reverse.l}
@span.l {%wrapObserver.b}{%spanP.l}
@break.l [{%not.b}]{%block}{%compose}{%span.l}
@breakP.l [{%mirror}]{%block}{%compose}{%spanP.l}
@breakRevP.l [{%not.b}]{%block}{%compose}{%spanRevP.l}
@unroll2 {%swap}
@bury1 {%unroll2}
@unroll2d {%swapd}
@bury1d {%unroll2d}
@unroll3 {%unrot}
@bury2 {%unroll3}
@unrotd {%.rw}{%unrot}{%.wl}
@unroll3d {%unrotd}
@bury2d {%unroll3d}
@unroll4 {%unroll}
@bury3 {%unroll4}
@unrolld {%.rw}{%unroll}{%.wl}
@unroll4d {%unrolld}
@bury3d {%unroll4d}
@unroll5 {%swap}{%.rw}{%unroll4}{%.wl}
@bury4 {%unroll5}
@unroll5d {%.rw}{%unroll5}{%.wl}
@bury4d {%unroll5d}
@unroll6 {%swap}{%.rw}{%unroll5}{%.wl}
@bury5 {%unroll6}
@unroll6d {%.rw}{%unroll6}{%.wl}
@bury5d {%unroll6d}
@unroll7 {%swap}{%.rw}{%unroll6}{%.wl}
@bury6 {%unroll7}
@unroll7d {%.rw}{%unroll7}{%.wl}
@bury6d {%unroll7d}
@unroll8 {%swap}{%.rw}{%unroll7}{%.wl}
@bury7 {%unroll8}
@unroll8d {%.rw}{%unroll8}{%.wl}
@bury7d {%unroll8d}
@unroll9 {%swap}{%.rw}{%unroll8}{%.wl}
@bury8 {%unroll9}
@unroll9d {%.rw}{%unroll9}{%.wl}
@bury8d {%unroll9d}
@c$ [c]$
@c_ vrwlcwlc
@v_ vrwvrwlc
@r_ rrwzlwl
@w_ rwrwzwlwl
@l_ rwrzwll
@c__ {%v_}{%r_}{%w_}{%l_}{%c_}{%w_}{%l_}{%c_}
@v__ {%v_}{%r_}{%w_}{%v_}{%r_}{%w_}{%l_}{%c_}
@z_ {%.rw}{%w_}{%.wl}
@r__ {%r_}{%r_}{%w_}{%z_}{%l_}{%w_}{%l_}
@w__ {%r_}{%w_}{%r_}{%w_}{%z_}{%w_}{%l_}{%w_}{%l_}
@l__ {%r_}{%w_}{%r_}{%z_}{%w_}{%l_}{%l_}
@c___ {%v__}{%r__}{%w__}{%l__}{%c__}{%w__}{%l__}{%c__}
@caar {%x}{%car}{%dp}
@caaar {%x}{%caar}{%dp}
@caaaar {%x}{%caaar}{%dp}
@caaaaar {%x}{%caaaar}{%dp}
@caaaadr {%wx}{%caaaar}{%dpw}
@caaadr {%wx}{%caaar}{%dpw}
@caaadar {%x}{%caaadr}{%dp}
@caaaddr {%wx}{%caaadr}{%dpw}
@caadr {%wx}{%caar}{%dpw}
@caadar {%x}{%caadr}{%dp}
@caadaar {%x}{%caadar}{%dp}
@caadadr {%wx}{%caadar}{%dpw}
@caaddr {%wx}{%caadr}{%dpw}
@caaddar {%x}{%caaddr}{%dp}
@caadddr {%wx}{%caaddr}{%dpw}
@cadar {%x}{%cadr}{%dp}
@cadaar {%x}{%cadar}{%dp}
@cadaaar {%x}{%cadaar}{%dp}
@cadaadr {%wx}{%cadaar}{%dpw}
@cadadr {%wx}{%cadar}{%dpw}
@cadadar {%x}{%cadadr}{%dp}
@cadaddr {%wx}{%cadadr}{%dpw}
@caddr {%wx}{%cadr}{%dpw}
@caddar {%x}{%caddr}{%dp}
@caddaar {%x}{%caddar}{%dp}
@caddadr {%wx}{%caddar}{%dpw}
@cadddr {%wx}{%caddr}{%dpw}
@cadddar {%x}{%cadddr}{%dp}
@caddddr {%wx}{%cadddr}{%dpw}
@cdr {%wx}{%dup}{%dpw}
@cdar {%x}{%cdr}{%dp}
@cdaar {%x}{%cdar}{%dp}
@cdaaar {%x}{%cdaar}{%dp}
@cdaaaar {%x}{%cdaaar}{%dp}
@cdaaadr {%wx}{%cdaaar}{%dpw}
@cdaadr {%wx}{%cdaar}{%dpw}
@cdaadar {%x}{%cdaadr}{%dp}
@cdaaddr {%wx}{%cdaadr}{%dpw}
@cdadr {%wx}{%cdar}{%dpw}
@cdadar {%x}{%cdadr}{%dp}
@cdadaar {%x}{%cdadar}{%dp}
@cdadadr {%wx}{%cdadar}{%dpw}
@cdaddr {%wx}{%cdadr}{%dpw}
@cdaddar {%x}{%cdaddr}{%dp}
@cdadddr {%wx}{%cdaddr}{%dpw}
@cddr {%wx}{%cdr}{%dpw}
@cddar {%x}{%cddr}{%dp}
@cddaar {%x}{%cddar}{%dp}
@cddaaar {%x}{%cddaar}{%dp}
@cddaadr {%wx}{%cddaar}{%dpw}
@cddadr {%wx}{%cddar}{%dpw}
@cddadar {%x}{%cddadr}{%dp}
@cddaddr {%wx}{%cddadr}{%dpw}
@cdddr {%wx}{%cddr}{%dpw}
@cdddar {%x}{%cdddr}{%dp}
@cdddaar {%x}{%cdddar}{%dp}
@cdddadr {%wx}{%cdddar}{%dpw}
@cddddr {%wx}{%cdddr}{%dpw}
@cddddar {%x}{%cddddr}{%dp}
@cdddddr {%wx}{%cddddr}{%dpw}
@cmd.test zwl{%.apply}{%x}rwz
@fromList.s.step D[vrwrwz'owlc]?VRW[%]?WLCc
@fromList.s [{%fromList.s.step}]{%block}{%.fixfirst}{%.bind}
@compareStreams.ab {%dx}{%x}{%swapd}{%pw}{%put}{%.apply}[{%drop}{%put}{%inline}]{%block}[{%inR}{%discard}{%nip2}]{%block}{%if}
@compareStreams.a~b {%drop2}{%discard2}{%intro1}{%inR}{%inR}
@compareStreams.a {%put}[{%compareStreams.ab}]{%block}[{%compareStreams.a~b}]{%block}{%if}
@compareStreams.b~a {%drop2}{%discard2}{%intro1}{%inL}{%inR}
@compareStreams.~ab {%drop2}{%discard2}{%intro1}{%inL}
@compareStreams.~a {%put}[{%compareStreams.b~a}]{%block}[{%compareStreams.~ab}]{%block}{%if}
@compareStreams.step {%swap}{%take2}{%intro1}{%.applyd}{%take}{%intro1}{%.applyd}[{%compareStreams.a}]{%block}[{%compareStreams.~a}]{%block}{%if}
@compareStreams [{%compareStreams.step}]{%block}{%bind}{%fixpoint}{%inline}
@compareLists {%take}{%fromList.s}{%take}{%fromList.s}{%put2}{%compareStreams}
@rawCompareNumbers' vrw>[vr>c]?Rc
@e.toOrd VRWRW[v%]?W[v%]?LW[v%]?LC
@toOrd.arity1 v{%e.toOrd}c
@rawCompareNumbers {%rawCompareNumbers'}{%toOrd.arity1}
@compareNumbers {%pw}[{%rawCompareNumbers}]{%block}{%.apply}
@compareOnStackToRawCompare [{%wx}]{%block}{%composel}{%applyWrap}
@compareProds {%.rw}{%.rw}{%dx}{%x}{%swapd}{%pw}{%dpw}{%.wl}{%.apply}[{%drop}{%.wl}{%.apply}]{%block}[{%inR}{%.wl}{%drop}]{%block}{%if}
@compareSums.ll {%pw}{%.wl}{%.apply}{%.wl}{%drop}
@compareSums.rl {%drop2}{%.wl}{%drop}{%.wl}{%drop}{%intro1}{%inR}{%inR}
@compareSums.ql {%.rw}[{%.wl}{%compareSums.ll}]{%block}[{%.wl}{%compareSums.rl}]{%block}{%if}
@compareSums.lr {%drop2}{%.wl}{%drop}{%.wl}{%drop}{%intro1}{%inL}{%inR}
@compareSums.rr {%pw}{%.wl}{%drop}{%.wl}{%.apply}
@compareSums.qr {%.rw}[{%.wl}{%compareSums.lr}]{%block}[{%.wl}{%compareSums.rr}]{%block}{%if}
@compareSums {%.rw}{%.rw}[{%compareSums.ql}]{%block}[{%compareSums.qr}]{%block}{%if}
@toOrd r{%e.toOrd}l
@compareTexts [{%rawCompareNumbers'}]{%block}{%compareLists}{%toOrd}
@compareUnits c{%.inL}
@compile r{&compile}l
@compose.p0.step vrwrwr$rwzw$zrz'ozw'olc
@compose.p0 [{%compose.p0.step}]{%block}{%.fixfirst}{%.bind}{%.bind}
@composel.p0 {%swap}{%compose.p0}
@condSelect {%p}{%distrib}r[rwl]?l{%merge}{%x}{%fst}
@fullFactor rFMll{%x}
@condSwap {%p}{%distrib}r[rwl]?l{%fullFactor}{%wx}
@cons.s {%p}{%inL}r'[c]wol
@constant.s [v^lVc]{%block}{%fromState.s}
@counter.splitReverseN.l {%swap}{%dup}#1{%integer}{%lt}{%swapd}
@eachUntil.l.cond {%swap}{%dip3}{%roll}[{%action.eachUntil.l}]{%block}[{%nip2}{%inL}]{%block}{%if_}
@nip3 {%.rw}{%drop3}{%.wl}
@eachUntil.l.step {%roll}[{%eachUntil.l.cond}]{%block}[{%nip3}{%inR}]{%block}{%if}
@eachUntil.l [{%eachUntil.l.step}]{%block}{%bind2}{%fixpoint}{%inline}
@inner.splitReverseN.l {%swap}{%empty.l}{%swap}[{%cons.l}{%decd}]{%block}[{%counter.splitReverseN.l}]{%block}{%eachUntil.l}{%swap}{%rot}
@splitReverseN.l {%assertNatural}[{%inner.splitReverseN.l}]{%block}{%apply2to3}
@splitReverse.l {%splitReverseN.l}{%drop}
@copy.l {%splitReverse.l}{%copy}{%reverseAppend.l}{%put}{%reverse.l}
@copy2 {%dup2}{%take2}
@take3 {%take2}{%take}
@copy3 {%dup3}{%take3}
@dup4 {%pw}{%pw}{%pw}{%dup}{%dwx}{%dwx}{%dwx}{%wx}{%wx}{%wx}
@take4 {%take3}{%take}
@copy4 {%dup4}{%take4}
@dup5 {%pw}{%pw}{%pw}{%pw}{%dup}{%dwx}{%dwx}{%dwx}{%dwx}{%wx}{%wx}{%wx}{%wx}
@take5 {%take4}{%take}
@copy5 {%dup5}{%take5}
@dup6 {%pw}{%pw}{%pw}{%pw}{%pw}{%dup}{%dwx}{%dwx}{%dwx}{%dwx}{%dwx}{%wx}{%wx}{%wx}{%wx}{%wx}
@take6 {%take5}{%take}
@copy6 {%dup6}{%take6}
@dup7 {%pw}{%pw}{%pw}{%pw}{%pw}{%pw}{%dup}{%dwx}{%dwx}{%dwx}{%dwx}{%dwx}{%dwx}{%wx}{%wx}{%wx}{%wx}{%wx}{%wx}
@take7 {%take6}{%take}
@copy7 {%dup7}{%take7}
@incd rw{%inc}wl
@state.p0 r[{%preApply}{%wx}]o[{%pw}{%postApply}]wol{%.state.p0}
@countFrom.p0 [{%drop}{%dup}{%incd}]{%block}{%state.p0}
@count.p0 #1{%integer}{%countFrom.p0}
@counterFrom.p0 [rw{%dup}{%incd}wl{%pw}]{%block}{%state.p0}
@counter.p0 #1{%integer}{%counterFrom.p0}
@curry [{%bind}]{%block}{%bind}
@curry2 [{%bind}{%curry}]{%block}{%bind}
@curry3 [{%bind}{%curry2}]{%block}{%bind}
@curry4 [{%bind}{%curry3}]{%block}{%bind}
@debugPrintRaw r[{&debugPrintRaw}]$l
@debugPrintText r[{&debugPrintText}]$l
@dec.arity1 v#1-+c
@decimal 
@div2 r#5{%integer}#1{%integer}{%decimal}r*l
@roundToFrac {%dup}rw{%div2}{%.add}wl{%alignToFrac}
@decimal12 #1000000000000{%integer}{%.inv}{%roundToFrac}
@decimal6 #1000000{%integer}{%.inv}{%roundToFrac}
@delay.p0.step vrwrwz'olc
@delay.p0 [{%delay.p0.step}]{%block}{%.fixfirst}{%.bind}
@dig1 {%roll2}
@roll2d {%swapd}
@dig1d {%roll2d}
@dig2 {%roll3}
@roll3d {%rotd}
@dig2d {%roll3d}
@dig3 {%roll4}
@roll4d {%rolld}
@dig3d {%roll4d}
@dig4 {%roll5}
@roll5d {%.rw}{%roll5}{%.wl}
@dig4d {%roll5d}
@dig5 {%roll6}
@roll6d {%.rw}{%roll6}{%.wl}
@dig5d {%roll6d}
@dig6 {%roll7}
@roll7d {%.rw}{%roll7}{%.wl}
@dig6d {%roll7d}
@dig7 {%roll8}
@roll8d {%.rw}{%roll8}{%.wl}
@dig7d {%roll8d}
@roll9 {%.rw}{%roll8}{%.wl}{%swap}
@dig8 {%roll9}
@roll9d {%.rw}{%roll9}{%.wl}
@dig8d {%roll9d}
@dip0 {%inline}
@dip1 {%dip}
@dip4 {%dpw}{%dip3}{%wx}
@dip5 {%dpw}{%dip4}{%wx}
@dip6 {%dpw}{%dip5}{%wx}
@dip7 {%dpw}{%dip6}{%wx}
@dip8 {%dpw}{%dip7}{%wx}
@dirLeft.z.rbt {%intro1}{%inL}
@dirRight.z.rbt {%intro1}{%inR}
@discard3 {%hsw}{%drop3}{%hsw}
@drop4 {%drop}{%drop}{%drop}{%drop}
@discard4 {%hsw}{%drop4}{%hsw}
@drop5 {%drop2}{%drop3}
@discard5 {%hsw}{%drop5}{%hsw}
@drop6 {%drop3}{%drop3}
@discard6 {%hsw}{%drop6}{%hsw}
@false.b {%intro1}{%inL}
@trimBoolean r{%trimBoolean.arity1e}l
@distribInL {%false.b}{%swap}{%distrib}{%trimBoolean}
@distribInLd {%.rw}{%distribInL}{%.wl}
@distribInR {%distribInL}{%mirror}
@distribInRd {%.rw}{%distribInR}{%.wl}
@div2.arity1 v#5{%integer}#1{%integer}{%decimal}r*c
@div2d rw{%div2}wl
@divMod.arity2 vrwQwlc
@l rrwrzwlll
@dl {%.rw}{%l}{%.wl}
@doc..abs "N(a) -- N(|a|)
~{%literal}
@doc..add "N(b) N(a) -- N(a+b)
~{%literal}
@doc..addend.s "(a`S*(a`S*e))→(a`S*e); addend streams (ABC layer stack)
~{%literal}
@doc..app1 "[1→y]→y
~{%literal}
@doc..app1e "[1→y]*e → y*e
~{%literal}
@doc..apply1 "[1→y] -- y
~{%literal}
@doc..assertFirstUnit "(1*e)→(1*e); assert first value is unit
~{%literal}
@doc..assertUnit "1→1; assert singular value is unit
~{%literal}
@doc..bapply "[x→x'] -- [((x*s)*e)→((x'*s)*e)]
~{%literal}
@doc..bfirst "[x→x'] -- [(x*y)→(x'*y)]
~{%literal}
@doc..bi "a a (a→b) -- b b
~{%literal}
@doc..bidup "a a [a→b] -- b b; raw 'bidup'
~{%literal}
@doc..bind "x [(x*y)→z] -- [y→z]; bind argument into pair
~{%literal}
@doc..bind2nd "y [(x*y)→z] -- [x→z]; bind second argument in pair
~{%literal}
@doc..bleft "[x→x'] -- [(x+y)→(x'+y)]
~{%literal}
@doc..both "(a*b) [a→a'] [b→b'] -- (a'*b')
~{%literal}
@doc..bright "[y→y'] -- [(x+y)→(x+y')]
~{%literal}
@doc..bsecond "[y→y'] -- [(x*y)→(x*y')]
~{%literal}
@doc..curry "[(x*y)→z] -- [x→[y→z]]; curry pair argument
~{%literal}
@doc..divMod "N(a) N(b) -- N(r) N(q) where a=q*b+r and r in (b,0] or [0,b)
~{%literal}
@doc..either "(a + b) [a→a'] [b→b'] -- (a' + b')
~{%literal}
@doc..eitherBind "(a+b) [(a*e)→e'] [(b*e)→e'] -- ([e→e']+[e→e'])
~{%literal}
@doc..first "(a*b) [a→a'] -- (a'*b)
~{%literal}
@doc..firstfixfirst "([([a→b]*a)→b]*e)→([a→b]*e); a minimal fixpoint
~{%literal}
@doc..fixfirst "[([a→b]*a)→b] -- [a→b]; fixpoint first argument in pair
~{%literal}
@doc..fmap.s "([a → b] * (a`S * e))→(b`S * e); map stream primitive
~{%literal}
@doc..fromStateSplitNext.r "A slightly more primitive variation of `fromStateSplitNext.r`.
 
     st [st→(st*st)] [st→(st*n)] -- n`PRG
 
 This operates on raw inputs, rather than using the 'apply' environment.
~{%literal}
@doc..fst "(x*y)→x
~{%literal}
@doc..gt "a b -- ((a*b) + (b*a)); a > b?; for numbers a,b
~{%literal}
@doc..gt1 "a x -- (a + a); a > x?; for numbers a,x
~{%literal}
@doc..gtb "a x -- Bool; a > x?; for numbers a,x
~{%literal}
@doc..gte "a b -- ((a*b) + (b*a)); a ≥ b?; for numbers a,b
~{%literal}
@doc..gte1 "a x -- (a + a); a ≥ x?; for numbers a,x
~{%literal}
@doc..gteb "a x -- Bool; a ≥ x?; for numbers a,x
~{%literal}
@doc..inL "a→(a+0); primitive inL
~{%literal}
@doc..inR "a→(0+a); primitive inR
~{%literal}
@doc..left "(a + b) [a→a'] -- (a' + b); apply block on left condition
~{%literal}
@doc..lt "a b -- ((b*a) + (a*b)); a < b?; for numbers a,b
~{%literal}
@doc..lt1 "a x -- (a + a); a < x?; for numbers a,x
~{%literal}
@doc..ltb "a x -- Bool; a < x?; for numbers a,x
~{%literal}
@doc..lte "a b -- ((b*a) + (a*b)); a ≤ b?; for numbers a,b
~{%literal}
@doc..lte1 "a x -- (a + a); a ≤ x?; for numbers a,x
~{%literal}
@doc..lteb "a x -- Bool; a ≤ x?; for numbers a,x
~{%literal}
@doc..mirror "(a+b)*e→(b+a)*e
~{%literal}
@doc..mul "N(b) N(a) -- N(a*b)
~{%literal}
@doc..neg "N(a) -- N(-a)
~{%literal}
@doc..pmap.s "([a↣b]*(a`S*e))→(b`S*e); fold process over stream in primitive environment
~{%literal}
@doc..prebind_l "[((a*s)*e)→e'] -- [(a*(s*e))→e']
~{%literal}
@doc..quot "just the quotient from .divMod
~{%literal}
@doc..rem "just the remainder from .divMod
~{%literal}
@doc..right "(a + b) [b→b'] -- (a + b'); apply block on right condition
~{%literal}
@doc..rw "((a*s)*e)→(s*(a*e)); simpler version of 'take' if we don't need environment other than stack
~{%literal}
@doc..second "(a*b) [b→b'] -- (a*b')
~{%literal}
@doc..snd "(x*y)→y
~{%literal}
@doc..square "N(a) -- N(a^2)
~{%literal}
@doc..state.p0 "A stateful process can be modeled as a pure function that, in addition to its normal input and output, receives a state value and outputs an updated state value. This must be coupled with an initial state.
 
     st [(st*a) → (st*b)] -- [a ↣ b]
 
 Most stateful behaviors can be expressed this way.
~{%literal}
@doc..sub "N(a) N(b) -- N(a-b)
~{%literal}
@doc..swap "(x*y)→(y*x); primitive swap
~{%literal}
@doc..tri "a a a (a→b) -- b b b
~{%literal}
@doc..tridup "a a a [a→b] -- b b b; raw 'tridup'
~{%literal}
@doc..wl "(s*(a*e))→((a*s)*e); simpler version of 'put' if we don't need environment other than stack
~{%literal}
@doc.AATree "The AA tree is a refinement on red-black binary search tree developed by and named for Arne Anderson. The idea is simple: allow red children only on the right hand side. The resulting tree corresponds to a 2-3 B-tree. Compared to red-black trees, a few extra balancing operations are required... but they are simpler. Compared to 2-3 trees, there are fewer node types.
 
 * the root is black
 * all leaves are black
 * all left-hand children are black
 * every red child has two black children
 
 Shorthand Type: elem`AATree
 
 We have several options for representing AA trees in Awelon project. For example, we could specialize red nodes based on them having only black children. We could potentially take advantage of all nodes on a level having the same number of children. But, keeping the KISS principle in mind like a mantra, I'll be using a uniform representation in this case:
 
         Root:  Tree
         Tree:  Node + Unit
         RTree: Node + Tree
         Node:  Elem * (Tree * RTree)
 
 In a properly balanced tree, we will be able to assert that a red node's right child is always black, or that the black-height from root to every leaf is equivalent.
 
 Thoughts on balancing the AA tree without height information: after insert or delete, the balance will *at most* be off by one. Potentially, we can take advantage of this by tracking balance on the return from insert or delete.
 
 NOTE: The AA tree is not fully implemented at the moment. I'm having some difficulty with implementing it without keeping the full 'level' metadata used in Arne Anderson's paper, and I'd rather not be manipulating or comparing numbers for the tree structure itself. For now, please consider this data structure to be in a half-implemented limbo; I'll instead try two-three trees (under suffix `.t23`) or red-black trees (under suffix `.rbt`). 
~{%literal}
@doc.ABC16toN16 "convert an ABC base16 character to an integer in 0..15
~{%literal}
@doc.BinaryData "Raw binary data can represent sensor inputs, controller outputs, compressed audio or visual information, cipher texts, cryptographic signatures, and more. Embedding binaries in Awelon Bytecode (ABC) is convenient, e.g. allowing partial evaluation and secure distribution through ABC's resource model. Awelon project uses a simple strategy for efficient storage and transmission of embedded binary data:
 
 1. encode binary data in a base16 alphabet
 2. special compression pass for base16 data
 
 The compression format is very simple: header byte 0xF8, length byte L (0..253), followed by L+3 bytes of data. This will be decompressed into (L+3)*2 base16 characters. If the symbol 0xF8 appeared normally, we could escape that as 0xF8 0xFE. However, 0xF8 won't ever be encountered if compressing UTF-8 or ABC. This results in 0.8% overhead for compressing large embedded binaries, and breaks even with base64 encodings at just 6 bytes. The base16 compression is followed by a more conventional compression, but the total worst-case expansion will be under 2.4% for large binaries.
 
 The base16 alphabet for ABC is not the standard `0-9a-f`. Instead we use:
 
     bdfghjkmnpqstxyz            i.e. `a-z` minus `aeiou` and `vrwlc`
 
 This alphabet avoids interference with other Awelon bytecodes or natural language text. Any large string of ABC's base16 characters is most likely intended for binary processing. There is also very little risk of spelling offensive words. The compression pass is case sensitive; lower case only.
 
 Note: This encoding only affects storage and bandwidth costs. For processing purposes, ABC must still work with strings or streams of base16 characters. Processing of base16 strings may eventually (in the very long term) be accelerated by a few ABCD functions.
~{%literal}
@doc.BinariesInABC {%doc.BinaryData}
@doc.BinarySearchTree "This is a simple implementation of a binary search tree. Representation:
 
         T: 1 + N
         N: (e * (T * T))
         (currently sealed by {:bst})
         shorthand: e`BST
 
 This tree is freely allowed to grow imbalanced. Unfortunately, it will be imbalanced very often in practice, e.g. when inserting nodes in sorted order. But this binary search tree can serve a useful role as a prototype for comparing other binary search tree implementations, and for getting started with associative arrays (maps).
~{%literal}
@doc.Blocks "A block in AO consists of code wrapped in square brackets, of form: `[put swap take]` or `[2 add]`. The meaning of a block is a first-class function that may be applied later. Blocks are essential in AO for:
 
 * representing loop behaviors by copying and applying blocks
 * modeling conditional behavior, apply block on just one branch
 * direct models of higher order programs and behavioral abstraction
 * transporting access and authority to resources and side-effects
 
 Best practices for use of blocks have not fully been established. Awelon project favors compositional abstractions to such an extent that use of ad-hoc parametric abstraction is discouraged. (See @doc.FirstPrincipleIsComposition.) My expectation is that blocks will be de-emphasized for behavioral abstraction in favor of indirect mechanisms - e.g. structured DSLs, symbolic expressions, free monads, staged programming. In this sense, AO would discourage conventional 'functional programming' in favor of a more 'language oriented programming'.
 
 Nonetheless, blocks remain essential for loops, effects, and conditions. Also, blocks make an effective compilation target, an alternative to interpretation, and they can help an embedded DSL model corner cases.
 
 Blocks can be composed.  Composition working together with quotation can also model such features as partial, concurrent, and conditional application.
 
         compose :: [x→y] [y→z] -- [x→z]      (sequential)
         bind    :: x [x--y] -- [--y]         (partial)
         .bind   :: x [(x*y)→z] -- [y→z]      (partial)
         .bfirst :: [x→y] -- [(x*e)→(y*e)]    (concurrent)
         .bleft  :: [x→y] -- [(x+e)→(y+e)]    (conditional)
 
 Some readers might be familiar with the notions of 'first' and 'left' from John Hughes' arrow model, which was an important foundation for AO and RDP. The primitive forms of '.curry' and '.bfirst', etc.. aren't very useable in the standard environment, but derived forms will also be available. 
 
 In addition, blocks may be constructed by quotation of a value:
 
         quote   :: (Quotable x) ⇒ x -- [-- x]
         unquote :: [-- x] -- x
 
 After construction, blocks can be applied in various ways. Developers will mostly use 'apply', which applies a block to the current environment except for the hand. Items in the current hand are hidden. But there are other operations that include (potentially) useful patterns for data hiding and application.
 
         .apply  :: x [x→y] -- y ; apply block to just top object on stack
         .applyd :: [x→y] x -- y ; apply block under object
         apply  :: x [x--y] -- y ; apply block to just top object on stack
           provides a clean environment, just one object on stack
         applyd :: [x--y] x -- y ; apply block under top object on stack
         applyNtoM :: takes N arguments on stack, generates M results on stack
           provides a clean environment, just N objects on stack, just M results at end
         applyNtoMd :: applyNtoM with block below the N arguments
         applyS :: apply to full stack (hiding rest of environment)
         dip    :: h [] -- ; apply block to all except top element on stack
         dip2   :: h1 h2 [] -- ; apply block to all except top two elements
         hdip   :: [] -- ; apply block hiding current hand 
         inline :: [] -- ; apply block as if inline (hand is visible)
         keep   :: x [x -- y] -- y x; copies element on stack
 
 The set of application words will undoubtedly evolve with experience and convenience in mind.
 
 TODO: separate the standard environment model from the apply model (as much as possible)
~{%literal}
@doc.Boolean "A boolean, in AO, is simply a sum of unit values: 1 + 1. By AO's conventions, a value in the left indicates 'false' or 'needs work', while a value in the right indicates 'true' or 'done'. It is this sense of true meaning done that many collection types (lists, streams, maybe, etc.) tend to use the right value for empty.
 
 Sums typically exist either by construction (e.g. representing different data constructors) or as a result of testing whether one number is greater than another. Booleans are more often the result of observation, since they're very lossy (aptly described as 'boolean blindness'). Words for manipulating booleans will use suffix `.b`.
~{%literal}
@doc.C.abc "((a+0)*e)→(a*e); elim void right
~{%literal}
@doc.CausalCommutativity "AO assumes causal commutativity. Any two subprograms can commute if they don't have a data-dependency relationship (i.e. where the output of one subprogram computes an input to another). This assumption is naturally enforced by the ABC primitives, but must additionally be enforced by whatever effectful capabilities are granted to the AO program.
 
 Causal commutativity is a valuable basis for many optimizations, and also for parallelism. Independent subprograms can be computed in parallel. Synchronization becomes implicit when results from parallel subprograms are used together for a side-effect.
~{%literal}
@doc.ConcurrencyInAO "AO has a natural capacity for parallelism (see @doc.CausalCommutativity). Concurrency is related, but is a different concept from parallelism. With concurrency, we have independently specified subprograms interacting in a shared environment. 
 
 To model concurrent behavior, AO developers need only to model the shared environment and interaction - e.g. to model message queues, registrations, and so on. This sort of explicit concurrency is explored with the incremental processes model (abstractly, `µP.[a→(P*b)]`). Implicit concurrency is also feasible, but only for an effects model that respects causal commutativity and spatial idempotence, such as Reactive Demand Programming (RDP).
 
 Parallel or concurrent behavior in AO tends to be fully deterministic. Non-determinism is possible, but must be expressed explicitly. Implicit non-determinism is incompatible with spatial idempotence (see @doc.SpatialIdempotence). An [oracle machine](http://en.wikipedia.org/wiki/Oracle_machine) could feasibly observe race-conditions, i.e. modeling each race as a unique, stateful resource.
~{%literal}
@doc.ConditionalBehavior "Awelon expresses conditional behavior using sum types. A sum type, `(a + b)`, indicates a value that is either left in `a` or right in `b`. A boolean, having exactly two values, can be modeled as `(1 + 1)` where 1 is the unit type (having exactly one value). Though, for various reasons, Awelon does not encourage use of booleans. Many useful data structures are also modeled with sums, e.g. a list is modeled with type `µL.((a*L)+1)`, or an optional value with `(a+1)`.
 
 Sum types can be computed by comparing numbers (via ABC operator `>`) or building more sophisticated observations above this primitive. Sums may also be returned from effectful observations or actions. By convention, the 'right' side of a sum is often punned with 'true', 'success', or 'complete' depending on the context. That is just a mnemonic, though; the formal semantics of sums is purely structural.
 
 Conditional behavior is expressed by applying a block to just the left or right side of a sum (via ABC operator `?`). The block may be affine (no copy), but must not be relevant (no drop). In addition, values may be explicitly distributed into a sum, or extracted from it. Conventional if/then/else behavior is modeled by distributing two programs then conditionally extracting one of them.
~{%literal}
@doc.DataMaps "A 'map' in computer science typically refers to an abstract, finite collection of (key, value) pairs where each key appears at most once in the collection. Other terms used for the same or similar ideas include 'dictionary' and 'associative array'. Typical operations on maps include:
 
     add, remove, or update (key, value) pairs
     lookup value given the key, or test if key exists
     compose two maps in various ways (join, union, etc.)
     stream or list processing of (key*value) pairs
 
 A map is typically implemented using balanced binary search trees or hashtables. In this case, for AO words of the `.m` suffix, we'll ultimately be favoring a self-balancing tree with worst-case O(lg N) operations. The map as a whole will additionally track a key comparison function `(K*K)→Ord` and encapsulate everything behind a discretionary `{:m}` sealer (to prevent accidental manipulations).
 
 Representation:
 
         ((K*V)`Tree * [(K*K)→Ord]){:m}      underlying data structure
         (k,v)`M                             shorthand type descriptor
         (currently prototyped with naive binary search tree)
 
 While keys must have homogeneous value type for comparisons, the values may have heterogeneous and substructural types, e.g. dependent upon the key. Maps may be used to model ad-hoc record types.
 
 Many related types can be trivially modeled above maps, including multi-maps (via collection type for values), sets (unit values), and multi-sets (counter values). But maps are not always ideal, e.g. if developers have a large collection of maps all using the same keys then some sort of table-based data structure would be more appropriate. If keys share a lot of structure, then a trie may be more appropriate. If keys represent spatial coordinates, a kd-tree may be more appropriate. I would love to have a wide array of moderately specialized data structures for common use-cases.
 
 The current implementation uses a plain old (imbalanced) binary search tree, more to get us started. It's easy to come back later and upgrade the tree data structure.
~{%literal}
@doc.Deletion.t23 "Deletion in 2-3 trees always starts with a leaf. If the node to be deleted isn't a leaf, we can always swap the node with its in-order successor, which will always be a leaf. Though, this is ultimately yet another factor that increases the size of the deletopm logic.
 
 After we delete a node, the result is either a proper tree or a "hole", a tree with no keys and just one child tree. The job is then reduced to repairing this hole. There are a few different 'repair' cases:
 
 1) Borrow from a sibling with 3 children.
 
                9                 7
              /   \     ...     /   \    
            4 7    _           4     9
           a b c   d          a b   c d
 
 2) Borrow from parent with 3 children.
 
                 4   9                  6
               /   |   \     ...      /   \
              2    6    _           2 4    9
             a b  c d   e          a b c  d e
 
 3) Single sibling with two children: propagate hole upwards.
 
               9                 _
             /   \      ...      |
            4     _             4 9
           a b    c            a b c
 
 4) If the hole reaches the root, delete the hole.
 
 If we count specific cases for each location, this adds up to about fifteen cases. I'd really prefer not to implement fifteen cases in AO, so I'll be seeking a lighter weight self-balancing tree. Hopefully, red-black trees are lighter weight.
~{%literal}
@doc.ElasticProcesses "The simple process model has a few severe weaknesses with respect to modeling 'elastic' behaviors, where the number of outputs may be different from the number of inputs. In particular, examples such as filtering, parsing, or pretty printing are difficult to represent. 
 
 A slightly more sophisticated process model can help model these behaviors. It works as follows:
 
 * Every process is in one of two states: producing or waiting.
   * If waiting, a process can handle a new input.
   * If producing, a process can be asked for a new output.
 * Upon receiving input, a process may change states.
 * We frequently need to handle a termination of inputs.
 * We frequently want to short-circuit processing. 
 
 The elastic process model combines some features of streams and some features of processes. The basic type, modeled in AO and lacking the termination feature, is roughly of the form:
 
          µP.([a→P] + [1→(P*b)])
              wait    produce
 
 To support termination, we generalize this just a little:
 
         ∀t.µP.([(a+t)→P] + [1→((P*b)+t)])
 
 In this model, we terminate by receiving or producing `t`. But we can't short circuit yet, since we don't know what `t` will be. To further support short-circuiting, we could simply specialize type `t` with a known type, such as unit.
 
         ∃t,t'.µP.([(a+t)→P] + [1→((P*b)+t')])
 
 This allows us to abort with a known type `t` (perhaps unit, or perhaps a success/failure status indicator) before observing all the available `a` values. This last option also transparently subsumes the earlier cases, i.e. any process polymorphic in termination type cannot short-circuit, and terminal type `0` corresponds to the first case via `(a+0)` and `((P*b)+0)`. The flexible type of `t` also allows some other useful patterns, such as returning unprocessed inputs.
 
 For now, we'll be favoring the latter variation.
 
         the type:    ∃t,t'.µP.([(a+t)→P] + [1→((P*b)+t')])
         shorthand:   [(a+t) ↬ (b+t')]           (↬ U+21AC)
         word suffix: .px
 
 We'll just call it an elastic process from `a` to `b`. 
 
 More sophisticated process models are also viable, e.g. if I wish to support putback/lookahead, non-determinism, or integration with an effects or messaging model. These elastic processes may be understood as a middle ground on the expressiveness scale - but, importantly, much more expressive than simple processes, which in turn are more expressive than functions.
~{%literal}
@doc.Filesystem "As command line utilities, aoi and ao offer some operations for working with the local filesystem through the power block. This is rather ad-hoc and minimal. Filesystem operations are asynchronous, meaning the powerblock is returned immediately even if the effect takes longer. Reads and writes to the same filename are serialized. A filename is given as text. 
 
 Several variations of read and write are provided for:
 
 * text files - read UTF-8 to text, or write text to UTF-8
 * binary files - read or write ABC's base16 binary format
 * ABC files - read or write an arbitrary [a→b] block (via introspection)
 
 At the moment, the whole file is read or written at once. I may eventually provide variations for incremental processing (i.e. streams), though I hope to deprecate the ao and aoi command line utilities before I get that far.
 
 The filesystem is a legacy resource with a lot of weaknesses, such as poor support for atomic updates, history, reactivity, data types, encapsulation, abstraction, composition, computation, procedural generation... and so on. Developers are encouraged to instead favor persistent state resource and environment models. Those will be much more portable to Awelon runtime environments in a distributed system.
 
 See also: `doc.BinariesInABC`.
~{%literal}
@doc.Hands "In AO, the hand is modeled as a second stack. It can be used as a temporary storage for deep operations on the current stack, and also serves as an efficient semantic clipboard for ad-hoc data shuffling.
 
     (currentStack * (hand * ... ))
 
 Developers can:
 
 * take item from stack into hand
 * put top item from hand onto stack
 * data plumbing similar to regular stack
 * discard a value from the hand
 * copy an item from the stack into hand
 * paste an item in the hand onto the stack
 * swap the current stack with the hand
 * apply a tool from the hand 
 
 In addition, hands are stable when developers use navigational metaphors, i.e. to operate in different workspaces or environments. Also, hands are hidden by some operations, such as `apply`.
 
 AO encourages a "clean hands" policy: most words should have a neutral effect on the hand, and not affect or observe the values already held by it. The exception is words like `take` and `put` where the purpose is to manipulate the hand. Some common words, such as `apply`, will hide the hand, which will enforce a clean hands policy for a lot of subprograms.
 
 Developers could use named stacks in place of hands, but doing so is a lot more expensive in most cases. Named stacks are really intended for long term stable storage.
~{%literal}
@doc.HigherOrderZippers "Zippers are a first derivative on a data structure. However, higher derivatives are also very useful. For example, first derivative can focus on a single character in text, but second derivative models an expandable selection of text. In a scene graph, such could model a mobile bounding volume. I don't grasp third derivatives yet, but my intuition is that it can help structurally abstract sweeps or convolutions, e.g. the process of casting a ray through a scene-graph.
~{%literal}
@doc.L.abc "((a+(b+c))*e)→(((a+b)+c)*e); associate sum left
~{%literal}
@doc.LF "text containing only a newline
~{%literal}
@doc.Lists "Lists in Awelon project languages are modeled using a recursive type: 
 
     λa.µL.((a*L)+1)       shorthand: a`L
 
 Awelon will eventually support some form of typeful descriptions, e.g. in a manner similar to 'test.' and 'doc.' words. Meanwhile, a list type is implied and inferred, encoded in the operations over lists. 
 
 Lists are simplistic and awkward data structures:
 
 * access to middle or end of a large list is expensive
 * very large lists can be expensive to hold in memory
 * iterative operations on a list tend to reverse the list
 * direct list processing is not incremental or compositional
 
 The primary feature of lists is they have a simple normal form. Also, text literals in AO or ABC are shorthand for a list of small integers, in the range 0 to 1114111, corresponding to Unicode code points. List processing is common for at least that reason. 
 
 Rather than directly process a list, an often better approach is to translate the list into another structure - e.g. a stream or sequence - process it, then (if necessary) translate it back. 
~{%literal}
@doc.Lists.todo "* compare length up to a given number (length up to N, returning (N+n(<N))?
 * find, elem, text processing - might be better to pursue a proper
    model of grammars, i.e. such that lists can be split, tokenized, etc.
    But support for 'words' and 'unwords' etc. might be useful.
 * association lists (.al?)
 * list to/from stream
~{%literal}
@doc.Loops "Loops in AO are ultimately expressed using fixpoint combinators. A loop will repeatedly copy and apply a block (which represents the body of the loop) until a terminating condition is observed. In practice, explicit loops should be avoided whenever possible, except when modeling collections types (streams, lists, etc.). Ultimately, AO should have the flavor of collection-oriented programming languages - i.e. very few loops exposed to programmers - despite the lack of built-in collection types.
 
 Compared to the recursive functions or built-in loops of more conventional programming languages, using fixpoint combinators is very awkward. Convenient loops are simply a low priority for AO's design. Instead, AO favors developing a few common collection types with collection-oriented words (which covers many use-cases for loops), plus incremental application models such that the outer loop is implicit.
 
 Explicit loops in AO are required to terminate. Due to the halting problem, termination cannot always be proven or disproven statically. However, a non-terminating loop is always a bug, and developers are expected to treat one thusly.
~{%literal}
@doc.Math "Awelon Bytecode (ABC) has a built in number type for exact rational numbers, and a small set of primitive operators (`+*-/Q` for add, multiply, negate, reciprocal, divmod) for manipulating these numbers. This is suitable for basic arithmetic. In some cases, a runtime may use inexact number representations, guided by annotation... but exact math is the default.
 
 Awelon Object (AO) language provides convenient representation of numbers - e.g. decimal, hexadecimal, fractional. In addition, it is envisioned (though not yet practiced) that AO should make heavy use of units information - e.g. distinguishing 4 kilograms from 4 litres, i.e. as an alternative to conventional typing disciplines. Units are relatively easy to express in concatenative languages, e.g. the word `kilograms` might take a number off the stack and wrap it with the appropriate unit structure. 
 
 On the assumption that most AO math functions shall support operators, the 'primitive' math operations are named with prefix `.`, as in `.add` and `.mul`. In addition, there is a class of pure math functions that operate on pairs or single values, meant for use with process models and stream processing, which have the form `add\N` and `mul\N`, where N is the arity.
 
 Sadly, concatenative languages are not very nice for expressing sophisticated algebraic formula. The stack shuffling, duplication, and data plumbing can interfere greatly with comprehension compared to a more declarative approach. To address this we can feasibly leverage embedded DSLs and partial evaluation. Compare:
 
         drop dup dup .mul swap .abs rot3 dup .mul swap .sub .add
         drop [.square] [.abs] bi .neg [.square] dip .add
         "x y z → y^2 + x^2 - |y|" doTheMath
 
 These three lines essentially express the same behavior (assuming suitable implementations of each word), but the latter is decidedly more declarative and comprehensible. Unfortunately, it's still stuck in a nasty string. Long term, embedded DSLs should be able to leverage [embedded literal objects](http://awelonblue.wordpress.com/2014/07/22/embedded-literal-objects/) to achieve rich, compositional structure with various maths.
~{%literal}
@doc.N16toABC16 "convert an integer in 0..15 to the associated ABC character
~{%literal}
@doc.NamingConventions "AO makes heavy use of naming conventions. Common prefixes suggest automatic processing or type information. For example, 'doc.' indicates documentation for a word, and 'test.' indicates automatic testing in a mockup environment, and 'id.' indicates that a given expression should be equivalent to identity for all the types it accepts. Conversely, suffixes connote context. A suffix might identify a specific framework, project, spreadsheet, or programmer.
 
 Multi-part words unfortunately make plain-text AO verbose, noisy, and difficult to read. 
 
 The intention is to mitigate this issue at the editor. A set of rules (configurable per user, view, or project) shall translate common prefixes and suffixes into rendering with colors and styles and possible icons. For example, `foo.x` and `foo.y` might render the same text (just `foo`) but with different colors for the `x` vs. `y` context. Similarly, fuzzy autocomplete mechanisms in the editor can eliminate need to fully write out large words. `foo.x` might be found by typing just `fx`.
~{%literal}
@doc.Ordinal "An ordinal comparison takes two values and returns a simple ordering:
 
         k`Compare is (k*k)→Ord
         Ord is (EQ+(LT+GT))
             represented as (1+(1+1))
 
 Here, `EQ` represents that two values are equivalent (or unordered). `LT` and `GT` indicate a less-than or greater-than ordering, assuming the normal irreflexive and transitive properties one should expect from those relationships. Ordinals can avoid a lot of rework when comparing complex objects, such as lists or streams. In many cases, e.g. when working with keys in a map, we'll assume that elements are totally ordered.
~{%literal}
@doc.Processes "A process model describes an interactive behavior. 
 
 A simple process model:
 
         µP.[a → (P * b)]               shorthand: [a ↣ b] (using U+21A3)
 
 In each interactive step, this process receives an input of type `a` and outputs a `b` along with the updated process. More generally, this process might be dependently typed. Further, the expected input and output types may evolve over interactive steps, e.g. type state, protocols, handshakes. 
 
 This process model composes in useful ways:
 
         (a ↣ b) *(b ↣ c)  → (a ↣ c)                Sequential
         (a ↣ a')*(b ↣ b') → ((a*b) ↣ (a'*b'))      Concurrent
         (a ↣ a')*(b ↣ b') → ((a+b) ↣ (a'+b'))      Conditional
 
 Processes can also model most object oriented programming patterns, modulo those that rely heavily on aliasing. We can also model environments, e.g. organizations of named processes that can communicate via messages, which may have their own compositions. Processes are a relatively generic approach to programming.
 
 This simple process model has several severe weaknesses:
 
 1. cannot model analysis (1:N) of inputs
 2. cannot model synthesis (N:1) of inputs
 3. cannot model filtering of inputs
 4. cannot short-circuit or terminate
 5. opaque; hinders structural optimizations
 
 These concerns should eventually be addressed by subsequent models, such as ElasticProcesses. However, KISS principle applies. Despite these limitations, the simple process model can be useful. The simple process model proposed here will be developed under suffix `.p0`, and may easily coexist with more sophisticated models. More sophisticated models include elastic processes  and [machines](https://dl.dropboxusercontent.com/u/4588997/Machines.pdf). I think it may be useful to model machine composition.
~{%literal}
@doc.R.abc "(((a+b)+c)*e)→((a+(b+c))*e); associate sum right
~{%literal}
@doc.RandomNumberGeneration "A pseudo-random number generator (PRNG) provides a deterministic stream of seemingly random numbers derived from an initial seed. The basic 'uniform' PRNG is like rolling a fair die, producing discrete values in a fixed range without bias. Nice qualities for a PRNG are bounded space requirements, a very large cycle (such that applications never cycle in practice), and efficient performance. There are also applications for 'secure' PRNGs, whose state or future outputs cannot be guessed from past outputs.
 
 Non-uniform distributions are also valuable, but can usually be computed from a uniform distribution. The bulk of a useful random number library will focus on translating uniform distributions into other interesting values or distributions. 
 
 The proposed PRNG is based on a simple object oriented interface:
 
     interface n`PRG:
        next  :: n`PRG → (n`PRG * n)
        split :: n`PRG → (n`PRG * n`PRG)
 
 Here, we generalize on number type `n`, and we aren't necessarily assuming a uniform distribution. However, we might say that the simplest PRNG interface should generate a sequence of uniformly distributed simple numbers. And there are no numbers simpler than 'zero or one' - booleans. The ability to 'split' the generator can be valuable for non-sequential computations, e.g. involving parallelism or laziness or tree-like data structures.
 
     type PRNG = (1+1)`PRG
 
 The other sensible option would be a uniform number in the range [0,1). However, we cannot actually implement such a generator, at least without modeling numbers as a lazy stream of digits or similar. For ABC numbers, we'll always have some finite precision, e.g. the 53-bit precision of IEEE-754.
 
 AO is not object oriented, but we can encode object interfaces as dependently typed functional closures:
 
     'next' is encoded as false (unit in left)
     'split' is encoded as true (unit in right)
     type n`PRG = µR.[next→(R*n) | split→(R*R)]
 
 In practice, we'll mostly construct PRNGs in terms of simple state+methods:
 
     fromStateSplitNext.r :: st [st -- st st] [st -- st n] -- n`PRG
                                (on split)    (on next)
  
 And we'll access it using simple next and split functions:
 
     split.r :: n`PRG -- n`PRG n`PRG
     next.r  :: n`PRG -- n     n`PRG
 
 AO doesn't have a 'global' random number generator. It is feasible to tuck a PRNG into the multi-stack environment or power block. However, as a general rule, a subprogram that uses randomness (even pseudo-randomness) should be explicit about it, and require the client to explicitly provide the random source. The idea is that a client of a random component should be able to systematically explore and test different outcomes by controlling the random number generator.
~{%literal}
@doc.RedBlackTree "The red-black tree is a balanced binary search tree developed by Rudolph Bayer in 1972. Balance is guaranteed by ensuring that the number of 'black' nodes on a path from the root to every leaf is equal, while allowing some flexibility of structure is achieved by allowing alternating nodes on a path to be painted red. The guarantee of O(lg N) manipulations is achieved by guaranteeing that red nodes have only black children, i.e. such that the longest path in the tree (mixed red and black) is no longer than twice the shortest path in the tree.
 
 A red-black tree corresponds to a 2-4 B-tree. Compared to other self-balancing binary search trees, red-black trees have the nice property of a highly uniform structure. This makes it easier to write zippers, traversals, and hopefully results in less special-case logic (e.g. compared to a direct implementation of a B-tree) for insertion and deletion. 
 
 Proposed representation:
 
         Node:  (elem * (Color * (Tree * Tree)))   
         Tree:  1 + Node                            leaf+node
         Color: 1 + 1                               black+red
 
         shorthand: e'RBT
 
 This representation might be sealed to resist accidental manipulation (see `seal.rbt`).
 
 Here I'm using a boolean per node to indicate color. This should minimize interference for code that is independent of color, such as fmap, counting, streaming. One goal, at the moment, is to keep tree balancing lightweight - in the sense of requiring relatively little ABC. 
 
 Note: for the moment, this is implemented as just a binary search tree.
~{%literal}
@doc.ShorthandDataShuffling "A few short data shufflers for an object on the stack, to compactly support simple manipulations. These operations include:
 
         p :: y x -- (x*y)
         x :: (x*y) -- y x
         w :: (x*y) -- (y*x)
         l :: (a*(b*c)) -- ((a*b)*c)
         r :: ((a*b)*c) -- (a*(b*c))
         wc :: (a*(b*c)) -- (b*(a*c))
         zc :: (a*(b*(c*d))) -- (a*(c*(b*d)))
 
  Common combinations are also defined, such as `pw` and `wx`, which pair or extract the second element. The meaning for `w` is not quite the same as the ABC under the hood, corresponding to a simple pair-swap behavior. But it's very useful to avoid unit allocations.
~{%literal}
@doc.SpatialIdempotence "Spatial idempotence is an assumption in AO: if a subprogram is computed many times, it must each time return the same result and have no additional side-effects beyond computing it once. This assumption can be enforced through the effects model. However, it is often enforced by affine types to simply prevent expressing of an effect more than once. 
~{%literal}
@doc.StandardEnvironment "AO has many similarities with stack-based programming languages, such as Forth, Factor, and Joy. However, the environment for AO is a value structured primarily of pairs. A stack can be modeled above pairs, but isn't the default. Further, in AO it is necessary to explicitly model the heap and other environmental structures if we want them.
 
 A viable option is to pair the stack with an extended environment:
 
         (stack * environment)
 
 Here the stack serves the normal role for Forth-like programming. The environment might then contain auxilliary stacks, a modeled filesystem or database, an inventory or user model, and other content. In a Claw view of AO code, texts, blocks, and numbers would be pushed to the stack (e.g. by words `literal`, `block`, and `integer`). This ensures the extended environment remains at a stable location, accessible to other words.
 
 The shape of the environment is not built into the AO language. Rather, shared conventions and de-facto standards will dominate, with words in the dictionary implicitly favoring a given environment. The Claw view of AO supports namespaces (e.g. via `#foo:`) to support secondary environment models.
 
 I've experimented with multiple environment models, 
 The stack-hand environment is  is convenient for a lot of use cases. It simply introduces one auxilliary stack, the 'hand'.
 
 At the moment, the most frequently used environment shape just adds one auxillary stack, which I call the "hand". This takes the following form:
 
         (stack * (hand * unit))
 
 Developers can then `take` items from the stack to the hand, or `put` items from the hand to the stack, or sometimes use a copy & paste metaphor. The hand provides both a useful location to stash intermediate values, and a clipboard. Forth frequently uses the return stack in a similar manner. The unit value on the right can be replaced by further environment extensions.
 
 The following environment was developed early on, by thought experiment:
 
         (stack * (hand * (power * ((name * namespace) * unit)))) (DEPRECATED)
 
 Where:
 
   stack: the current stack, where most operations apply
   hand: the hand, auxillary stack, useful as temporary store & clipboard
   power: a powerblock, to observe or influence real world
   name: label of current stack, used when switching stacks
   namespace: stack of (label*value) pairs for workspaces and registers
 
 However, this hasn't seen more than shallow use in the dictionary and would be easy to replace. One concern with the above environment is that namespace manipulation is relatively difficult to optimize compared to anonymous data shuffling. Also, it's challenging to isolate subprograms or reuse them in a new context due to the embedded labels. At this time, I think this experimental environment should be deprecated.
 
 I'm considering a multi-stack environment with a linear space of anonymous stacks, using `stepLeft` and `stepRight` motions to navigate from one stack to another. One might render this in a REPL using something like:
 
         ____v__________    hand: 6 3 8
          1  3  7  5  4     
          2  4  8  2  6     
             5  9     1
             6
 
        > put stepRight take 0
 
              
         _______v_______    hand: 7 3 8
          1  6  0  5  4     
          2  3  8  2  6     
             4  9     1
             5
             6
 
 This is trivial to model with an additional pair of stacks, one containing stacks to the left and one containing stacks to the right. In addition to motion, we'd have the ability to create a new stack to the left or right, or erase one. The resulting environment, extending the main environment at this time, would have structure:
 
        (stack * (hand * ((stacksLeft*stacksRight) * unit))
 
 This would provide all the space a user needs for normal computations, i.e. without feeling squeezed into a single stack. As demonstrated above, it can also be easy to render in a REPL or on a screen... perhaps even has a bit of a video game feel. Extensions like the namespace would remain possible.
 
 Additionally, there may be more benefit in extending the 'hand' concept to be a full 'user' model, with potential concepts like inventory, equipment, preferences and rules. It might be useful to shift the labeled objects into the user model, clarifying that labels are pet names for a given agent rather than part of the environment.
 
         (stack * ((hand*user) * ((stacksLeft*stacksRight) * unit))
            or perhaps optimize access to hand
            and generalize separation of user and environment
         (stack * (hand * ((stacksLeft * stacksRight) * (extUser * extEnv))))
 
 Clearly, AO hasn't settled on a 'standard' environment. This will be left open for further exploration. But the hope is that we'll eventually settle on something that strikes a good balance of simplicity, performance, and convenience.
~{%literal}
@doc.Streams "A stream is an incremental sequence of values. The incremental nature gives stream processing a few advantages for reasoning about space requirements when processing very long running streams. 
 
     µS.[1→((elem*S)+1)]            shorthand: elem`S
 
 This model of streams uses the block to capture the incremental computation of the next element, and exhibits the structure of a list. These streams are also allowed to terminate, by returning unit in the right. Most uses of simple streams are for data structure processing; termination is expected. 
 
 The simple streams model isn't ideally efficient, especially with deep composition. A more sophisticated streams model or stream builder might support some rich, symbolic optimizations. There are also useful variations on the model, e.g. augmenting queries and results with time information to limit query depth or support more interesting interleave. But the simple stream model has useful applications (e.g. incremental data processing, or compilation target for integration) and remains worth developing.
 
 Words for this simple stream model use suffix `.s`
~{%literal}
@doc.Transducer "Transducers are a simple model for *eager* processing of collections, which abstracts the step function. For a full explanation, see the [Strangeloop presentation 1](https://www.youtube.com/watch?v=6mTbuzafcII). Hickey's preliminary model for transducers:
 
          step       :: [(val * state) → state]
          transducer :: [step → step]
 
 With this model, given a state and collection of values, we could return a final state. But several features are missing here. First, we have no way to short-circuit and indicate we're done processing. Second, we have no way to represent stateful behaviors. If we add those features, we end up with something closer to:
 
          step' :: µStep . ∀state. [(arg*state)→((Step*state) + done)]
 
 At this point, we need fixpoint behaviors to model stateful steps. And we still need completion or initialization. Hickey's transducers are seeming very ad-hoc. Should I continue to develop transducers? I'm leaning towards 'no', at least not in full. But [elastic processes](doc/ElasticProcesses) should cover most of the same use cases.
~{%literal}
@doc.TwoThreeTree "The 2-3 Tree is a balanced B-tree in which every node has one or two data elements, inner nodes have either two or three children and all children are at the same depth.
 
 A proposed representation:
 
         T  :: (E + (N2 + N3))
         E  :: unit
         N2 :: (T * (a * T)) 
         N3 :: (T * (a * N2)) 
 
         SHORTHAND:  e'T23
 
 The cost of a 2-3 tree is dealing with three types at every step, which results in relatively bulky logic with a lot of conditionals. This should work well enough even if it's a bit heavy, and 2-3 trees are ultimately the basis for the 2-3 finger trees for sequences. But it might be worth exploring red-black trees and other models to see if any of them prove a bit more lightweight.
~{%literal}
@doc.ValueSealing "AO allows seal/unseal actions to be hard-coded using inline ABC. These are represented as:
 
         {:foo} :: (a*e) → ((foo:a)*e)  seal value with 'foo'
         {.foo} :: ((foo:a)*e) → (a*e)  unseal value with 'foo'
 
 A sealed value is like wrapping a letter in an envelope. In case of discretionary sealers like `{:foo}`, this envelope isn't very secure, but you can at least prevent accidental dependencies on the underlying data - and it's easy to search for all code that unseals a value.
 
 For secure value sealing, we shall utilize symbol `$`, as follows:
 
         {:format$leftKey}              seal value cryptographically
         {.format$rightKey}             unseal cryptographic sealed value
         {$format}                      indicate cryptographically sealed value
 
 The default format, whatver is chosen, won't need to be spelled out. I would like to favor a public/private key model for asymmetric encryption, i.e. such that a holder of just the sealer cannot unseal values, and a holder of just the unsealer cannot seal values. I haven't worked out the details. But ECC does seem promising.
 
 Serializations of sealed values:
 
         #42{:foo}                      discretionary sealed value
         ["cipherText\n~c]f{$fmt}       cryptographically sealed affine value
 
 Discretionary sealers are simply serialized to bytecode as normal, then sealed again on the remote VM. The data remains accessible for introspection, reflection, and debugging. Discretionary sealers serve many useful roles such as resisting accidental data couplings, aiding a typechecker, or providing hints to a rendering or representation system.
 
 The cryptographic case is much more strongly protected. The cipher text is the result of compressing and encrypting the bytecode that will regenerate the data. The cipher text is embedded in the ABC stream as a binary (cf. `doc.BinariesInABC`). The text is further wrapped in a block so we may apply all the substructural properties relevant to the now opaque data (affine, relevant, expirations, etc.). Finally, the cryptographic text block is sealed with `{$format}` to forbid manipulations until unsealed. 
 
 Cryptographic sealers are intended mostly to support rights amplification and other security patterns. Value sealing is complementary to object capability security, and together object capabilities and value sealing can model most security policies. A dictionary may restrict what tokens are permitted, e.g. to ensure portability. Cryptographic sealers and sealed values will usually not be included directly in a dictionary.
~{%literal}
@doc.W.abc "((a+(b+c))*e)→((b+(a+c))*e); swap sum first
~{%literal}
@doc.Z.abc "((a+(b+(c+d)))*e)→((a+(c+(b+d)))*e); swap sum second
~{%literal}
@doc.Zipper.AATree "A simple zipper data structure - a `(focus*context)` pair, where the focus is a tree node and the context is a list representing a path back to root. Each element in the context includes enough directional information to restore the original tree. Possible representation for context nodes:
 
                           right on
                  left     red or black
          Elem * (RTree + (Tree + Tree))
 
 Where we're holding onto the tree whose path we did not take. Alternatively, the Elem type could be pre-distributed through the sum types. I'm not sure it makes a real difference one way or the other.
~{%literal}
@doc.Zipper.rbt "A zipper to walk a red-black tree. In this case, we have a 'focus' (a particular subtree) and our context is a list of steps back to root. A step has type:
 
         Step :: (Dir * (Color * (e * Tree)))
         Dir :: Left() + Right(); direction of Step (tree is opposite child)
         Context :: List of Step (empty is at root)
         Zipper :: (Tree * Context)
 
         Shorthand e'Z.RBT
 
 A focus and a list of steps is sufficient to rebuild the tree. More importantly, it should also be sufficient (or nearly so, perhaps with a small amount of extra context) to *rebalance* the tree while rebuilding it, i.e. since we can always see the colors of the next couple nodes.
~{%literal}
@doc.Zippers "The zipper data structure was described by Gérard Huet in 1997. It enables navigation and modification of tree-structured data in a purely functional context. At any time, the original tree structure can be recovered with the modifications. For Awelon project, zippers should be widely useful for modeling user navigation through a programming environment, and also for compositional manipulation of tree structures. Zippers must generally be specialized for each data structure.
~{%literal}
@doc.abc:V "(a*e)→((a+0)*e); intro void right
~{%literal}
@doc.abcBase16Alphabet "alphabet used to encode binary data in ABC in base16, representing digits 0..15
~{%literal}
@doc.abs.arity1 "N(a)→N(|a|)
~{%literal}
@doc.add.abc "(N(a)*(N(b)*e))→(N(a+b)*e); add numbers
~{%literal}
@doc.add.arity2 "(N(a)*N(b))→N(a+b)
~{%literal}
@doc.add.stats "stats number -- stats
~{%literal}
@doc.addend.s "a`S a`S -- a`S; compose streams end-to-end (stream at top of stack runs last)
~{%literal}
@doc.aff.abc "([x→y]*e)→([x→y]f*e); adds affine (no copy) attribute to block
~{%literal}
@doc.affine "mark block on stack as affine (not Copyable)
~{%literal}
@doc.alignToFrac "Align a number near an arbitrary fraction. For example:
 
     1/3 1/100 roundToFrac =  33/100
     2/3 1/100 alignToFrac =  66/100
     227 10    alignToFrac =  220
 
     number frac -- number(aligned) remainder
 
 Note: no special handling for negative numbers
~{%literal}
@doc.ambiguous.abc "(EXPERIMENTAL)
 
 There are plans for AO to express ambiguous behavior using a syntactic (foo|bar) construct. This would indicate that the program is either foo or bar. Ideally, the program would be selected based on type safety (i.e. if 'foo' doesn't make sense in context, exclude it), and the remaining choices would be selected heuristically. Heuristics would be based on attribute annotations and perhaps stability (favoring choices that worked well in the past).
 
 Developers could then refine the choices in many ways: 
 
 * by modifying code to add or remove choices
 * by modifying attribute annotations
 * by modifying the heuristic scoring algorithm
 * by favoring simpler and more precise types
 
 The potential utility of ambiguous code is to express a large space of possible programs, and shift the burden to the compiler to pick a suitable program in context. This can feasibly result in robustly adaptable code. But it comes with risks of high overheads and more challenging failure modes.
~{%literal}
@doc.and.b "Bool Bool -- Bool; are both arguments true?
~{%literal}
@doc.ap.abc "([a→a']*(a*e))→(a'*e); apply
~{%literal}
@doc.apcar "Apply a function to just a particular element of a structure.
 
         apcar :: (a*b) [a→a'] -- (a'*b)
         apcdr :: (a*b) [b→b'] -- (a*b')
         apcadr :: (a*(b*c)) [b→b'] -- (a*(b'*c))
 
~{%literal}
@doc.apcdr {%doc.apcar}
@doc.append.l "a1`L a2`L -- (a1 before a2)`L; append two lists
~{%literal}
@doc.apply "x [x -- y] -- y; apply in limited environment (just 'x' on stack)
~{%literal}
@doc.applyWrap "[a -- b] -- [a→b]; apply 1:1 stack function in `apply` environment
~{%literal}
@doc.assert "Awelon offers a primitive to assert that a condition is not false, i.e. that `(a + b)` is certainly not in `a`. (This isn't to say the condition is in `b`. The assertion itself might be dead code.) Since the condition after a successful assertion is not false, we eliminate the sum type and just continue with `b`.
 
     assert :: (a + b) -- b
 
 Assertions are useful to model preconditions, postconditions, contracts; to support inference of dependent types; and for automatic testing (test. words). Ideally, an assertion can be proven statically and removed from the runtime code. If an assertion cannot be proven, a compiler is free to issue a warning. A runtime failure will halt the program as quickly and cleanly as feasible while maintaining performance. (Explicit capabilities may allow confinement of subprogram failure.)
 
 Specialized assertions can be constructed above the basic assert, e.g. to test numbers or text labels. Search for words whose name starts with `assert` to find some appropriate for your purpose.
~{%literal}
@doc.assert.abc "((a+b)*e)→(b*e); assert
 
 Assertions are ideally validated at compile-time, i.e. representing dependent type declarations or contracts. It is preferable that developers be warned when assertions cannot be proven. A runtime assertion failure will halt the AO or ABC program as quickly and cleanly as readily feasible without significantly compromising simplicity or performance. 
 
 It is feasible to run sub-programs in partitions, such that failure only takes out a partition and not the entire program. However, to discourage dependence upon this technique, it is usually a generally a controlled effect provided through the powerblock.
~{%literal}
@doc.assertBalanced.AATree "Assert than an AA tree is properly balanced, meaning that the number of black nodes is equal between root and every leaf.
 
         a`AATree -- a`AATree
 
 This will assert that the height of each subtree is balanced until we reach root.
~{%literal}
@doc.assertBalanced.rbt "Assert that a red-black tree has the same black-height on every path, and that red nodes have only black children. These two invariants ensure that a red-black tree is 'balanced' in the sense that the longest path from root to leaf is no longer than twice the shortest path, and thus no more than 2*lg(N) steps. 
 
         e'RBT -- e'RBT   (does not alter input)
 
~{%literal}
@doc.assertBalanced.t23 "a'T23 -- a'T23; assert 2-3 tree is balanced
~{%literal}
@doc.assertBoolean "Bool -- Bool; enforces true boolean (1+1)
~{%literal}
@doc.assertEQ "a a -- a a; (annotation) assert equivalence 
 
         {&≡} :: (a*(a*e))→(a*(a*e))
           ^ that's U+2261 (dec 8801)
 
 This asserts that the two arguments should be equivalent. As an annotation, this has no observable impact on a valid program, but it may cause some invalid programs to be rejected at compile time or fail at run time.
 
 For blocks, the notion of equivalence is a little fuzzy because behavioral equivalence is undecidable in the general case. At the very least, an implementation must pass structurally equivalent blocks (i.e. same underlying ABC code).
~{%literal}
@doc.assertEQ1 "as `assertEQ`, then drop the top copy (common)
~{%literal}
@doc.assertEQ1d "x y x -- x y; assert top x equivalent to bottom x
~{%literal}
@doc.assertEQ1d.n "N(x) N(y) N(x) -- N(x) N(y); assert x's are equal, useful for testing
~{%literal}
@doc.assertInL "(a+b) -- a; see `doc.assert`
~{%literal}
@doc.assertInR "(a+b) -- b; see `doc.assert`
~{%literal}
@doc.assertIsolated "The `{&isolated}` annotation declares that a block should not contain or mention any machine-specific capabilities, meaning that it does not contain any tokens other than annotations, sealers, unsealers, and dynamically linked resources that are themselves isolated. Isolation is NOT the same as purity. An isolated function may cause effects so long as it receives effectful capabilities as arguments. By design, every function in the AO language is isolated.
 
         {&isolated} :: (block * e) → (block * e)
         assertIsolated :: block -- block
 
 Isolation is not difficult to enforce dynamically or statically. Of course, as with all annotations, enforcement is strictly optional. In addition to enforcing isolation, the declaration can support optimizers by allowing them to assume isolation.
~{%literal}
@doc.assertLT "N N -- N N; e.g. `3 4 assertLT` will pass; identity behavior
~{%literal}
@doc.assertPure "The `{&pure}` annotation declares that a block should neither observe or influence world state when evaluated. Similar to isolation, the block may use annotations, sealers, unsealers, and dynamically linked resources. However, purity doesn't imply the block is isolated, rather that it simply doesn't use any of the capabilities it can access.
 
         {&pure} :: (block * e) → (block * e)
         assertPure :: block -- block
 
 In the absence of a Haskell-like type system, purity is relatively difficult to statically validate compared to isolation. Purity requires a fairly precise analysis of data flow, and is frequently 'viral' by implying requirements on the arguments. That said, purity isn't especially difficult to enforce dynamically, e.g. by sandboxing a computation. In addition to enforcing purity, a purity declaration can support optimizers by allowing them to assume purity. However, if all you want is the optimizations, you should consider `assertSafe` instead of `assertPure`.
~{%literal}
@doc.assertSafe "The `{&safe}` annotation declares that a block should not influence world state in any significant manner. I'm using the word 'safe' here in the same sense that W3C describes the HTTP methods GET and HEAD to be safe. Compared to purity, safety is a strictly weaker property. Safe but impure computations may observe world state. 
 
         {&safe} :: (block * e) → (block * e)
         assertSafe :: block -- block
 
 Similar to purity, safety can be difficult to validate statically, but is not especially difficult to enforce dynamically. Declaration of safety can also support optimizers. Safety allows optimizations such as dead code elimination and a restricted form of lazy evaluation (where laziness might be restricted to a particular transaction). This complements ABC's universal properties of causal commutativity and spatial idempotence.
~{%literal}
@doc.assertSorted.t23 "(k*v)'T23 [(k*k)→Ord] -- (k*v)'T23; assert 2-3 tree is sorted
~{%literal}
@doc.assertTextEQ1 "text text -- text; assert two texts are equal
~{%literal}
@doc.asynch "The `{&asynch}` annotation indicates that a block should be evaluated in parallel, allowing the rest of the computation to move on until the result is needed. This will generally be implemented in a promise pipelining style. ABC's causal commutativity feature ensures this parallelism is safe, that parallelism is constrained only by dependencies between values.
 
         {&asynch} :: (block*e)→(block*e)
         asynch    :: block -- block (on AO stack)
 
 However, a little warning: `{&asynch}` is not like threads or processes in procedural code. Asynchronous blocks will not be able to communicate with one another, and are required to terminate. We'll frequently wait for all asynchronous child computations to terminate before returning a result, or before moving on to the next transaction or paragraph.
~{%literal}
@doc.bi "apply two blocks to one argument.
 
        [p] [q] bi 
           is equivalent to
        [p] keep q
 
~{%literal}
@doc.bi* "apply 2 blocks each to 1 respective input
~{%literal}
@doc.bi2 "apply two blocks each to same two arguments.
 
     [p] [q] bi2 
        is equivalent to
     [p] keep2 q
 
~{%literal}
@doc.bi2* "apply 2 blocks each to 2 respective inputs
~{%literal}
@doc.bi2dup "apply a single block to two pairs of inputs
~{%literal}
@doc.bi3 "apply two blocks each to same three arguments
~{%literal}
@doc.bi3* "apply 2 blocks each to 3 respective inputs
~{%literal}
@doc.bi3dup "apply a single block to two triples of inputs
~{%literal}
@doc.bidup "apply a single block to two different inputs
~{%literal}
@doc.bind "x [x -- z] -- [-- z]; bind argument onto stack
~{%literal}
@doc.bind2nd "x [x y -- z] -- [y -- z]
~{%literal}
@doc.bind3rd "w [w x y -- z] -- [x y -- z]
~{%literal}
@doc.bind4th "v [v w x y -- z] -- [w x y -- z]
~{%literal}
@doc.bindK.insertKV.bst "(k*v) [(k*k)→Ord] -- (k*v) [k→Ord]
~{%literal}
@doc.bindK.insertKV.t23 "(k*v) [(k*k)→Ord] -- (k*v) [k→Ord]
~{%literal}
@doc.bindKVCmp.AATree "(k*v) [(k*k)→Ord] -- (k*v) [k→Ord]
~{%literal}
@doc.bitListToText "(1+1)`L -- text; e.g. of form "01100001"
~{%literal}
@doc.bitListToWord "(1+1)`L -- N(word); word size implicit from list
~{%literal}
@doc.bitListToWordK "(1+1)`L K(width) -- N(word); take or fill K bits from list
~{%literal}
@doc.bitStreamToOctetStream "(1+1)`S -- octet`S
~{%literal}
@doc.bitStreamToText "(1+1)`S -- char`S; characters '0' and '1'
~{%literal}
@doc.bitStreamToWordKStream "(1+1)`S K(width) -- wordK`S
~{%literal}
@doc.blackHeight.AATree "Compute height of tree in black nodes (assuming correct balance).
 
         a`AATree -- a`AATree Nat
 
 This takes O(height) = O(lg N) time, and serves as a rough estimate of size.
~{%literal}
@doc.blackHeight.rbt "e'RBT -- e'RBT Nat; count black nodes from root to leftmost leaf
~{%literal}
@doc.block.abc "A block is simply a finite sequence of ABC. A literal block may be represented in ABC using square brackets like so: `[vrwlc]`. This constructs a first-class function: [vrwlc] :: e → [(a*b)→(b*a)] * e
~{%literal}
@doc.break.l "a`L [pred(a--PseudoBool)] -- a(rem)`L a`L; split prefix for which predicate does not hold
~{%literal}
@doc.breakP.l "a`L [a--(b+a)] -- a`L b`L; split longest sequence of `b` results (on left)
~{%literal}
@doc.breakRevP.l "a`L [a--(b+a)] -- a`L b(rev)`L
~{%literal}
@doc.buryM "The buryN combinators bury the top element from the stack, reversing the corresponding digN operation. This is perhaps a better name than 'unroll'.
~{%literal}
@doc.c.abc "(a*1)→a; elim unit right
~{%literal}
@doc.c_ "((a*1)*e)→(a*e); ~ `[%c]$`
~{%literal}
@doc.car "In the Lisp tradition, there are functions `car` and `cdr` that respectively access the first and second elements of a pair. The names derive from ancient operational semantics - contents of the address register vs. contents of the destination register. There is a series of related functions, such as `caar` and `caddar` that can access deeper structures. These are convenient, so they are replicated in AO albeit assuming the main argument is on the stack. 
 
         car :: (a*b) -- (a*b) a; copyable a
         cdr :: (a*b) -- (a*b) b; copyable b
         cadr :: (a*(b*c)) -- (a*(b*c)) b; copyable b
 
 Note that these directly reflect the Lisp versions, i.e. `(cadr x) = (car (cdr x))`. However, AO does not copy the intermediate structures, so only the actual target must be copyable. We carry this out up to a limited depth (which can always be expanded). This has a weakness of not being very composable, but it can occasionally be convenient. 
 
 We also have families of related functions, such as `setcar!` from Scheme, albeit without aliasing, and `wcar` to swap a value, `apcar` to apply a pure function to a deep value, and `dpcar` to apply a function to the environment with just one element from the data structure (hiding the rest).
~{%literal}
@doc.cdr {%doc.car}
@doc.cmd.test "msg -- result; (io) call powerblock in standard location
~{%literal}
@doc.color.rbt "e'RBT -- e'RBT color; copy color of red-black tree
~{%literal}
@doc.comp.abc "([x→y]*([y→z]*e))→([x→z]*e); compose blocks/functions
~{%literal}
@doc.compareLists "k`L k`L [k`Compare] -- Ord; compare lists item by item
~{%literal}
@doc.compareNumbers "Num Num -- Ord
~{%literal}
@doc.compareOnStackToRawCompare "[k k -- Ord] -- [(k*k)→Ord]
~{%literal}
@doc.compareProds "(a1*b1) (a2*b2) [a`Compare] [b`Compare] -- Ord
~{%literal}
@doc.compareStreams "k`S k`S k`Compare] -- Ord; compare streams item by item
~{%literal}
@doc.compareSums "(a1+b1) (a2+b2) [a`Compare] [b`Compare] -- Ord
~{%literal}
@doc.compareTexts "text text -- Ord; compare texts lexicographically by codepoint order
~{%literal}
@doc.compareUnits "1 1 -- Ord
~{%literal}
@doc.compile "The `{&compile}` annotation can support explicit compilation. It operates on a block of bytecode and transparently returns a compiled version of that block, with intention to improve performance. This is potentially very useful for staged metaprogramming and other contexts where we might compose a hundred small blocks at runtime. Of course, any benefits must be weighed against the overhead for compiling and linking the code.
 
         {&compile} :: (block*e)→(block*e) 
         compile    :: block -- block (on AO stack)
 
 Static compilation is also useful, of course. Dynamic compilation can translate to static compilation via partial evaluation. Also see use of the `{&static}` annotation.
~{%literal}
@doc.compose "[x→y] [y→z] -- [x→z]; compose functions
~{%literal}
@doc.compose.p0 "[a ↣ b] [b ↣ c] -- [a ↣ c]; compose two processes
~{%literal}
@doc.composel "[y→z] [x→y] -- [x→z]; compose on left
~{%literal}
@doc.condSelect "(a+b) x y -- a x OR b y; select one value, and merge the other
~{%literal}
@doc.condSelect_ "(a+b) x y -- x (if in a) OR y (if in b); select value and drop condition
~{%literal}
@doc.condSwap "conditional swap; swap top two arguments if third in right
~{%literal}
@doc.condap.abc "([a→a']*((a+b)*e))→((a'+b)*e); conditional application
 
 The block in this case cannot be relevant or linear; i.e. it must be droppable, because the block will be dropped in the 'b' condition.
~{%literal}
@doc.cons.l "a`L a -- a`L; add element to list
~{%literal}
@doc.cons.s "a`S a -- a`S; add element at head of stream
~{%literal}
@doc.consd.l "a`L b a -- a`L b; add element to list
~{%literal}
@doc.constant.s "a -- a`S; (copyable a); infinite stream with a single value
~{%literal}
@doc.copy "copy object from top of stack into hand (copy/paste metaphor)
~{%literal}
@doc.copy.abc "(a*e)→(a*(a*e)); copy; requires copyable a
~{%literal}
@doc.copy.l "a`L N -- a(orig)`L a(first N)`L; copy first N elements of list
~{%literal}
@doc.count.p0 "-- [a ↣ N]; (droppable a); as counter, but drop input
~{%literal}
@doc.countFrom.p0 "N -- [a ↣ N]; (droppable a); as counterFrom, but drop input
~{%literal}
@doc.counter.p0 "-- [a ↣ (N*a)]; add index to output (starting from 1)
~{%literal}
@doc.counterFrom.p0 "N -- [a ↣ (N*a)]; add index with initial value
~{%literal}
@doc.curry "[x--z] -- [x--[--z]]; curry stack argument
~{%literal}
@doc.d0.abc "(N(x)*e)→(N(10x+0)*e); digit
~{%literal}
@doc.d1.abc "(N(x)*e)→(N(10x+1)*e); digit
~{%literal}
@doc.d2.abc "(N(x)*e)→(N(10x+2)*e); digit
~{%literal}
@doc.d3.abc "(N(x)*e)→(N(10x+3)*e); digit
~{%literal}
@doc.d4.abc "(N(x)*e)→(N(10x+4)*e); digit
~{%literal}
@doc.d5.abc "(N(x)*e)→(N(10x+5)*e); digit
~{%literal}
@doc.d6.abc "(N(x)*e)→(N(10x+6)*e); digit
~{%literal}
@doc.d7.abc "(N(x)*e)→(N(10x+7)*e); digit
~{%literal}
@doc.d8.abc "(N(x)*e)→(N(10x+8)*e); digit
~{%literal}
@doc.d9.abc "(N(x)*e)→(N(10x+9)*e); digit
~{%literal}
@doc.debugPrintRaw "annotation to print top value from stack to stderr
~{%literal}
@doc.debugPrintText "annotation to print top text on stack to stderr (as text)
~{%literal}
@doc.decimal12 "round number to decimal with twelve places past decimal point
~{%literal}
@doc.decimal6 "round number to decimal with six places past decimal point
~{%literal}
@doc.delay.p0 "a -- [a ↣ a]; delays input one step; initial output provided
~{%literal}
@doc.digN "The digN combinators are perhaps a better name for roll, since it more clearly connotates that we're dragging some value upwards from the depths of the stack. digN will correspond to roll(N-1); we're accessing the Nth element under the top of the stack.
 
         dig3 :: d c b a -- c b a d
 
 The reverse operation is buryN. The 'digNd' combinators will dip below the top element on the stack.
~{%literal}
@doc.dip "..a b [..a -- ..a'] -- ..a' b; inline function, except hiding top element of stack
~{%literal}
@doc.discard "drop and destroy value in hand
~{%literal}
@doc.distrib "(a + b) c -- ((c*a) + (c*b))
~{%literal}
@doc.distrib.abc "(a*((b+c)*e)→(((a*b)+(a*c))*e); distribute
~{%literal}
@doc.distribInL "a -- (a + a); in left; as `inL` but preserves x's type info in right
~{%literal}
@doc.distribInR "b -- (b + b); in right; as `inR` but preserves x's type info in left
~{%literal}
@doc.divMod.abc "(N(divisor)*(N(dividend)*e))→(N(remainder)*(N(quotient)*e)) ;
   such that: quotient * divisor + remainder = dividend
              quotient is integral
              remainder/divisor is a proper fraction (in [0,1)).
~{%literal}
@doc.divMod.arity2 "(N(a)*N(b))→(N(q)*N(r)); a = qb+r; q integral, r between 0 and b
~{%literal}
@doc.dpcar "Apply a function to an element deep in a data structure, hiding the rest of the data structure. In this case, the 'dp' corresponds to the `dip` function, which usually hides one item on the stack; we're instead hiding the structure surrounding the target. Ad-hoc results may be returned through the environment.
 
         dpcar :: ..s (a*b) [..s a -- ..s' a'] -- ..s' (a'*b)    
         dpcdr :: ..s (a*b) [..s b -- ..s' b'] -- ..s' (a*b')    
         dpcadr :: ..s (a*(b*c)) [..s b -- ..s' b'] -- ..s' (a*(b'*c))
 
 I'm curious whether this pattern will actually prove useful or not. 
~{%literal}
@doc.drop "(Droppable x) ⇒ x -- 
~{%literal}
@doc.drop.abc "(a*e)→e; drop; requires droppable a
~{%literal}
@doc.drop.l "a`L N -- a`L; drop first N elements of list (or result in empty list, if N >= length)
~{%literal}
@doc.drop2 "(Droppable x,y) ⇒ x y -- 
~{%literal}
@doc.drop3 "(Droppable x,y,z) ⇒ x y z -- 
~{%literal}
@doc.drop4 "(Droppable w,x,y,z) ⇒ w x y z -- 
~{%literal}
@doc.dup "(Copyable x) ⇒ x -- x x
~{%literal}
@doc.dup2 "(Copyable x,y) ⇒ x y -- x y x y
~{%literal}
@doc.dup3 "(Copyable x,y,z) ⇒ x y z -- x y z x y z
~{%literal}
@doc.dup4 "(Copyable w,x,y,z) ⇒ w x y z -- w x y z w x y z
~{%literal}
@doc.dupd "(Copyable x) ⇒ x y -- x x y
~{%literal}
@doc.dupfst "(x*y) -- (x*y) x; see also 'car' (family of similar functions)
~{%literal}
@doc.dupsnd "(x*y) -- (x*y) y; see also 'cdr' (family of similar functions)
~{%literal}
@doc.each.l "a`L [a --] --; apply block to each element in list
~{%literal}
@doc.foreach.s "Sequentially process every element from a finite stream. The type is roughly:
 
     ..b a`S [..b a -- ..b] -- ..b
 
 That is, we apply the same function with each element of the stream in the current AO environment. A non-terminating stream would cause divergence, and is an error, though it's ultimately up to the developer to avoid this error.
~{%literal}
@doc.each.s {%doc.foreach.s}
@doc.eachUntil.l "a`L [a --] [-- Bool] -- a(rem)`L; each with short circuit (on true)
~{%literal}
@doc.eachWhile.l "a`L [a --] [-- Bool] -- a(rem)`L; each with short circuit (on false)
~{%literal}
@doc.eitherBind "(a+b) [..e a -- ..e'] [..e b -- ..e'] -- ([..e--..e']+[..e--..e'])
~{%literal}
@doc.elemAt.l "a`L N -- (a+1); copyable a; N in 1..length; returns in right if list is too short
~{%literal}
@doc.elemAtHead.l "a`L -- a`L (a+1); copyable a; copies first element in list (if any)
~{%literal}
@doc.elim1 "Unit -- 
~{%literal}
@doc.empty.AATree "-- elem`AATree
~{%literal}
@doc.empty.bst "-- e`BST
~{%literal}
@doc.empty.l "empty list (has same structure as 'true')
~{%literal}
@doc.empty.m "[(k*k)→Ord] -- (k,v)`M; create a new, empty map
~{%literal}
@doc.empty.rbt " -- e'RBT
~{%literal}
@doc.empty.s "-- a`S; add empty stream to stack
~{%literal}
@doc.empty.t23 "-- e'T23
~{%literal}
@doc.emptyNumMap.m "-- (Num,v)`M; create a map keyed by numbers
~{%literal}
@doc.emptyTextMap.m "-- (Text,v)`M; create a map keyed by text
~{%literal}
@doc.enum "a [a ix -- a] n m -- a; apply with ix in range [n,m].
~{%literal}
@doc.enum.s "-- num`S; enumerate from 1..infinity
~{%literal}
@doc.enumFrom.s "start -- num`S; enumerate from start..infinity
~{%literal}
@doc.enumx "a [a ix -- a] n m -- a; apply with ix in range [n,m).
~{%literal}
@doc.eq "a b -- ((LT(a*b) + GT(b*a)) + EQ(b*a)); for numbers a,b
~{%literal}
@doc.eq1 "a x -- ((a(<x) + a(>x)) + a(=x)); for numbers a,x
~{%literal}
@doc.eq1m "a x -- (a(≠x) + a(=x)); for numbers a,x
~{%literal}
@doc.eqb "a b -- Bool; a = b?; for numbers a,b
~{%literal}
@doc.eqv.mapTwice.compMap "Rewriting from a composition of map operations to a map of compositions is a difficult challenge for an optimizer. And proving this is difficult for a prover. In general, if developers need this sort of optimization, they should be using a staged programming model that symbolically constructs the map operations, i.e. initially constructing a free, logical list/stream.
~{%literal}
@doc.error.test "errMsg --; (io) emit message then fail
~{%literal}
@doc.exit.z.rbt "e'Z.RBT -- e'RBT; rebuild tree from zipper (assuming balance)
~{%literal}
@doc.exitrb.z.rbt "e'Z.RBT -- e'RBT; exit a zipper while rebalancing
~{%literal}
@doc.factor.abc "(((a*b)+(c*d))*e)→((a+c)*((b+d)*e)); partial factor
~{%literal}
@doc.factorial.fixpoint "mostly this is a test for fixpoint :)
~{%literal}
@doc.fibonacci "N -- fib(N); the 'hello world' of functional programming ;)
~{%literal}
@doc.filterBy.l "a`L [a--Bool] -- a`L; Copyable&Droppable a
~{%literal}
@doc.filterBy.s "a`S [a -- Bool] -- c`S; Copyable & Droppable a
~{%literal}
@doc.filterWith.l "a`L [a--(b+c)] -- c`L; Droppable b
~{%literal}
@doc.filterWith.s "a`S [a -- (b+c)] -- c`S; Droppable b
~{%literal}
@doc.findKV.bst "(k*v)`BST k [(k*k)→Ord] -- (k*v)`BST ((k*v)+1); (copyable k,v)
~{%literal}
@doc.findKV.rbt "Copy a `(k*v)` pair from a red-black binary search tree.
 
         (k*v)'RBT k [(k*k)→Ord] -- (k*v)'RBT ((k*v)+1)
 
 If no such key exists, a value is returned in the right.
~{%literal}
@doc.first.p0 "[a ↣ a'] -- [(a*b) ↣ (a'*b)]; process first argument
~{%literal}
@doc.fixpoint "This fixpoint combinator binds a function to receive itself (in fixpoint form) as an argument on the stack. Fixpoint enables expression of recursive behavior.
 
        [foo] fixpoint
            is equivalent to
        [[foo] fixpoint foo]
            is equivalent to
        [[[foo] fixpoint foo] foo]
 
 When invoked, the function `foo` has access to itself (in fixpoint form) as a block on the stack. 
 
 Loops are expressed this way in Awelon to avoid reliance on a namespace, to support streaming programs and AO's simple 'inline everything' semantics. Unfortunately, expressing loops in this manner is relatively awkward for humans, and a direct interpretation will be less efficient than a stored program's jump based loops. The performance issue can be mitigated by a compiler. The awkwardness should be avoided by developing libraries for collection-oriented programming, such that most loops become implicit to processing of collections.
 
 NOTE: Loops in Awelon are required to terminate. The proof burden for termination ultimately falls on the programmer, but a compiler or linter is allowed to issue errors if it can prove non-termination, or warnings if it cannot prove termination. Long running behaviors in Awelon project are modeled with an *implicit* top-level loop, e.g. with RDP or a process object.
~{%literal}
@doc.flatten.s "(a`S)`S -- a`S; flatten a stream of streams
~{%literal}
@doc.fmap.AATree "Apply a function to all data elements in tree. 
 
         a`AATree [a→b] -- b`AATree
 
 Note: if this affects the key values, it is the developer's responsibility to
 preserve a sorted ordering.
~{%literal}
@doc.fmap.bst "x`BST [x→y] -- y`BST
~{%literal}
@doc.fmap.s "a`S [a → b] -- b`S; map a pure function over a stream
~{%literal}
@doc.fmap.t23 "a'T23 [a→b] -- b'T23; apply function to every element
~{%literal}
@doc.fmapE.s "a`S [a -- b] -- b`S; map function in basic `apply` environment
~{%literal}
@doc.fold.l "x a`L [x a -- x] -- x; process each element in constrained environment
~{%literal}
@doc.forCount.l "a`L [a--] count -- a`L count(rem); take and operate on list up to count times
~{%literal}
@doc.forCount.s "a`S [a--] count -- a`S count(rem)
~{%literal}
@doc.foreach.l {%doc.each.l}
@doc.fromLeaf.rbt "unit -- elem'RBT
~{%literal}
@doc.fromList.arity1.s "a`L → a`S; stream to list (without environment)
~{%literal}
@doc.fromList.s "a`L -- a`S; treat a list as a stream
~{%literal}
@doc.fromNode.rbt "(elem*(Color*(Tree*Tree))) -- elem'RBT
~{%literal}
@doc.fromState.s "s [s → ((a*s)+1)] -- a`S; stream from state/stepper function
~{%literal}
@doc.fromStateE.s "s [s -- ((a*s)+1)] -- a`S; stream from state/stepper in apply environment
~{%literal}
@doc.fromStateSplitNext.r "The simplest way to think about a PRNG is as a state with a pair of functional methods, split and next, which output an updated state.
 
     st [st -- st st] [st -- st n] -- n`PRG
         split         next
 
 The fixpoint trappings are then abstracted away. 
 The split and next methods will operate in the 'apply' environment.
~{%literal}
@doc.toList.arity1.s "a`S → a`L; list to stream (without environment)
~{%literal}
@doc.fromStream.arity1.l {%doc.toList.arity1.s}
@doc.toList.s "a`S -- a`L; extract a list from a finite stream
~{%literal}
@doc.fromStream.l {%doc.toList.s}
@doc.fst "(x*y) -- x
~{%literal}
@doc.fullFactor "((a+b)+(a'+d)) -- (b+d) a
~{%literal}
@doc.fullSwapEnv "E(dest) -- E(origin); swap current & reified environments (note: user model is also swapped).
~{%literal}
@doc.grow.gt.n2.insertKV.t23 "T1 kv1 (T2*(kv2*T3)) -- N3
~{%literal}
@doc.grow.gtk2.n3.insertKV.t23 "t0 kv0 t1 kv1 (t2*(kv2*t3)) -- N2; split right
~{%literal}
@doc.grow.lt.n2.insertKV.t23 "(kv2*T3) (T1*(kv1*T2)) -- N3
~{%literal}
@doc.grow.ltk1.n3.insertKV.t23 "(kv1*(t2*(kv2*t3))) (t0*(kv0*t1)) -- N2; split left
~{%literal}
@doc.grow.ltk2.n3.insertKV.t23 "t0 kv0 (kv2*t3) (t1*(kv1*t2)) -- N2; split middle
~{%literal}
@doc.gt.abc "(x₁*(x₂*e))→(((x₂*x₁)+(x₁*x₂))*e); compare (greater than)
 
 Not all values are comparable. Just enough is comparable to compare texts: numbers with numbers, sums with sums, products with products and unit with unit. Taking left as false and right as true, comparisons are transitive and irreflexive.
~{%literal}
@doc.hap "same as 'put inline'; apply a function in the hand to the environment
~{%literal}
@doc.hapc "same as 'paste inline'; non-destructively apply function in hand to environment
~{%literal}
@doc.height.t23 "a'T23 -- a'T23 Nat; find height of balanced 2-3 tree
~{%literal}
@doc.hfix "Fixpoint the function in the hand, such that a function remains recursively available in the hand during evaluation. Intended for use with `hap` or `hapc`, potentially within an 'apply' environment. It is a common data plumbing pattern to 'take' a recursive function, since we often wish to work with some other values before applying a function recursively and the hand is a convenient place to stash the function.
~{%literal}
@doc.id "a→a; same as whitespace
~{%literal}
@doc.if "The 'if' function enables developers to conveniently model conditional behavior. It operates by selecting a block then invoking it. A few variations of 'if' are provided based on whether you need access to the conditional, and whether you wish to keep it.
 
         if  :: ..a (L+R) [..a L -- ..b] [..a R -- ..b] -- ..b
         if_ :: ..a (L+R) [..a -- ..b]   [..a -- ..b]   -- ..b
         ifk :: ..a (L+R) [..a L -- ..b] [..a R -- ..b] -- ..b (L+R)
         ifd :: ..a (L+R) [..a -- ..b]   [..b -- ..b]   -- ..b (L+R)
                          on left/false  on right/true  
 
 Only `if` and `if_` can be used where tail-call optimization is needed.
 
 The main weakness of 'if' behaviors is that they're difficult to extend or compose. They're effectively 'closed' syntactically. Developers are under pressure to push a lot of logic into those blocks. ABC is based on sum types (L+R) to better support composition of conditional behavior, but to leverage sum types requires alternative idioms (such as incremental processes or RDP). 
~{%literal}
@doc.if_ "..a (L+R) [..a -- ..b]   [..a -- ..b]   -- ..b      ; see @doc.if
~{%literal}
@doc.ifd "..a (L+R) [..a -- ..b]   [..a -- ..b]   -- ..b (L+R); see @doc.if
~{%literal}
@doc.ifk "..a (L+R) [..a L -- ..b] [..a R -- ..b] -- ..b (L+R); see @doc.if
~{%literal}
@doc.import.ao "default root import for `ao` executable. See @doc.ao.utility .
~{%literal}
@doc.import.bits "functions for working with bits and bytes and fixed-width words
~{%literal}
@doc.import.compiledWords "contains compilation directives; see `doc.prefix.compile!`
~{%literal}
@doc.import.random "pseudo random number generators
~{%literal}
@doc.import.std "viable starting point for AO dictionaries
~{%literal}
@doc.inL "a -- (a + 0); wrap 'a' in failure, mark false, on the left
~{%literal}
@doc.inLL "a -- ((a+0)+0); in left-left
~{%literal}
@doc.inLR "a -- ((0+a)+0); in left-right
~{%literal}
@doc.inR "b -- (0 + b); wrap 'b' in success, mark true, in the right
~{%literal}
@doc.inRL "a -- (0+(a+0)); in right-left
~{%literal}
@doc.inRR "a -- (0+(0+a)); in right-right
~{%literal}
@doc.indexOf.l "a`L [a -- Bool] -- a`L (n+1); copyable a
~{%literal}
@doc.insert.m "Insert an element into a map, replacing an existing element if necessary.
 
         (k,v)`M (k*v) -- (k,v)`M ((k*v)+1)
 
 If an element with the given key already exists, it is replaced and the older pair will be returned. Use `insert_.m` to drop the replaced value.
~{%literal}
@doc.insertK.m "(k,v)`M k -- (k,v)`M ((k*v)+1); insert (k*unit) into map (using map as set)
~{%literal}
@doc.insertKV.AATree "Insert or replace a `(key*value)` data element in an AA tree.
 
        (k*v)`AATree (k*v) [(k*k)→Ord] -- (k*v)`AATree ((k*v)+1)
 
 The key type, in this case, must be copyable, but the value type may be linear. The ordinal comparison function should be consistent with the ordering already used in the tree, i.e. all inserts should use the same totally ordered comparison function. If the element already exists, it will be replaced and the old `(k*v)` pair will be returned. We'll allow that the keys might not be identical; they only need to be equivalent as far as the ordinal comparison function is concerned.
 
 The current representation of AATree does not keep extra data regarding 'level', so this creates a few challenges for the balancing operation. Relevantly, there are multiple cases to handle. If we end up replacing a node, the balance is not affected. If we insert a node, the balance may be impacted, or might not be. It isn't clear to me, at the moment, how to best model this. 
~{%literal}
@doc.insertKV.bst "Insert a `(k*v)` pair, given an ordinal function for keys.
 
         (k*v)`BST (k*v) [(k*k)→Ord] -- (k*v)`BST ((k*v)+1)
 
 In case we replace an existing entry, the old value is removed and returned.
~{%literal}
@doc.insertKV.rbt "Insert a value into a red-black binary search tree. 
 
         (k*v)'RBT (k*v) [(k*k)→Ord] -- (k*v)'RBT ((k*v)+1)
 
 The trick is to rebalance the tree after insert, ensuring that the tree is never imbalanced.
~{%literal}
@doc.insertKV.t23 "Insert or replace a value in a binary search tree. Returns an updated tree and the replaced element.
 
         (k*v)'T23 (k*v) [(k*k)→Ord] -- (k*v)'T23 ((k*v)+1)
 
 Inserting may grow the tree. See `doc.tree.insertKV.t23` for details.
~{%literal}
@doc.insertK_.m "(k,v)`M k -- (k,v)`M; insert (k*unit) into map (using map as set)
~{%literal}
@doc.insert_.m "(k,v)`M (k*v) -- (k,v)`M; insert then drop prior value (if any)
~{%literal}
@doc.intro1 " -- Unit
~{%literal}
@doc.invocations.abc "ABC can call out to the environment by using special curly brace operators of the form `{foo}`. This will invoke the environment with token 'foo' and the tacit value. ABC cannot forge the token, i.e. no primitive ABC operators permit moving from "foo" as text to `{foo}` as an operator. 
 
 It is recommended that implementations for open systems favor cryptographically secure text - i.e. encrypted or signed text (via HMAC or PKI). Consequently, the text between the curly braces is often called "capability text". When wrapped in a block like `[{foo}]`, these invocations become first-class, transferrable and cryptographically securable capabilities.
 
 AO permits hard-wiring a few classes of invocations. Specifically:
 
 * `{&foo}` - annotations; to tweak performance or support debugging or typing
 * `{:foo}` - value sealing; ad-hoc discretionary sealers act as type wrappers
 * `{.foo}` - unseal a value previously sealed with {:foo}
 
 AO can also indirectly utilize `{#resourceId}` separate compilation and linking, via `compile!foo` directives. Resource identifiers are derived from the secure hash of the bytecode and of its compressed, encrypted distribution form.
 
 ABC may additionally establish other standard capability types, e.g. to support true sealers, uniqueness sources, or homomorphic encryption. But most capabilities are specific - i.e. indicating authority to observe or influence a specific resource on a specific machine.
~{%literal}
@doc.inx.z.rbt "Insert a value at current location in a zipper, then exit the zipper. Will replace current value, or add a leaf value. The exit will rebalance the tree.
 
         e'Z.RBT e -- e'RBT (e+1)
 
 If a value is replaced, the old element is returned.
~{%literal}
@doc.l "(x*(y*z)) -- ((x*y)*z)
~{%literal}
@doc.l.abc "(a*(b*c))→((a*b)*c); associate left
~{%literal}
@doc.l_ "((a*(b*c))*e)→(((a*b)*c)*e); ~ `[%l]$`
~{%literal}
@doc.lazy "The `{&lazy}` annotation suggests that a computation involving a block should be delayed until we know the result is needed. However, it's a weak suggestion. If you really want laziness, you should model it explicitly, e.g. capturing computations with quotation and composition.
 
         {&lazy} :: (block * e) → (block * e)
         lazy :: block -- block
 
 Note that `{&lazy}` implies `{&safe}`. Annotations, including `{&lazy}`, are not permitted to affect observable behavior of programs, and safety is necessary to ensure that laziness doesn't impact observable behavior. See `assertSafe`.
~{%literal}
@doc.left.p0 "[a ↣ a'] -- [(a+b) ↣ (a'+b)]; process left argument
~{%literal}
@doc.lefts.s "Filter a stream, keeping only the left elements.
 
     (a+b)`S -- a`S     (requires droppable b)
 
 In the general case, this is unsafe... e.g. if we filter an infinite stream where all the elements might be in the right, we'll diverge, which is an error. Developers must be careful with filtering of simple streams.
~{%literal}
@doc.length.l "a`L -- a`L length; return length of list
~{%literal}
@doc.lift.p0 "[a → b] -- [a ↣ b]; function to process
~{%literal}
@doc.linear "mark block on stack as linear (neither Copyable nor Droppable)
~{%literal}
@doc.lookupKV.AATree "Copy an element from the AA tree, after looking it up by key.
 
         (k*v)`AATree k [(k*k)→Ord] -- (k*v)`AATree ((k*v)+1)
 
 The tree is not modified by this operation.
~{%literal}
@doc.map.l "a`L [a -- b] -- b`L; apply block modifying each element in list
~{%literal}
@doc.map.p0 "[a -- b] -- [a ↣ b]; function (apply env) to process
~{%literal}
@doc.map.s {%doc.fmapE.s}
@doc.mapP.l "a`L [a -- b] -- b`L; map elements in limited `apply` environment
~{%literal}
@doc.merge "(a + a') -- a; a and a' must be future compatible
~{%literal}
@doc.merge.abc "((a+a')*e → (a*e); merge
 
 In this case, a and a' must be "future compatible." This doesn't imply the exact same type, and typecheckers may need to track type a and a' together for some steps before fully merging them.
~{%literal}
@doc.mkCompareLists "[(a*a)→Ord] -- [(a`L * a`L)→Ord]
~{%literal}
@doc.mkCompareNums "-- [Num`Compare]; raw number comparisons
~{%literal}
@doc.mkCompareProds "[a`Compare] [b`Compare] -- [(a*b)`Compare]
~{%literal}
@doc.mkCompareStreams "[(a*a)→Ord] -- [(a`S * a`S)→Ord]
~{%literal}
@doc.mkCompareSums "[a`Compare] [b`Compare] -- [(a+b)`Compare]
~{%literal}
@doc.mkCompareTexts "-- [(text*text)→Ord]
~{%literal}
@doc.mkCompareUnits "-- [1`Compare]; trivial, always equal
~{%literal}
@doc.mul.abc "(N(a)*(N(b)*e))→(N(a*b)*e); multiply numbers
~{%literal}
@doc.mul.arity2 "(N(a)*N(b))→N(a*b)
~{%literal}
@doc.n.stdgen.r "seed -- n`PRG; the number generator underlying stdgen.r
~{%literal}
@doc.nand.b "Bool Bool -- Bool; is at least one argument false?
~{%literal}
@doc.neg.abc "(N(a)*e)→(N(-a)*e); additive inverse
~{%literal}
@doc.neg.arity1 "N(a)→N(0-a)
~{%literal}
@doc.neq "a b -- (EQ(b*a) + (LT(a*b) + GT(b*a))); for numbers a,b
~{%literal}
@doc.neq1 "a x -- (a(=x) + (a(<x) + a(>x))); a ≠ x?; for numbers a,x
~{%literal}
@doc.neq1m "a x -- (a(=x) + a(≠x)); for numbers a,x
~{%literal}
@doc.neqb "a b -- Bool; a ≠ b?; for numbers a,b
~{%literal}
@doc.newZero.abc "e→(N(0)*e); intro number 0
~{%literal}
@doc.next.r "n`PRG -- n     n`PRG
~{%literal}
@doc.next_s1.stdgen.r "From Haskell code:
     k1   = s1 `quot` 53668
     s1'  = 40014 * (s1 - k1 * 53668) - 12211 * k1
     s1'' = if s1' < 0 then s1' + 2147483563 else s1'
 
 These are all magic numbers to me. I haven't studied the underlying generators. 
 
 But I do observe that:
 
     2147483563 = (40014 * 53668) + 12211
     2147483563 is prime
     12211 is prime
     (s1 - k1*53668) is the same as the modulus/remainder
 
 We want `s1 -- s1''`.
~{%literal}
@doc.next_s2.stdgen.r "From Haskell code:
     k2   = s1 `quot` 52774
     s2'  = 40692 * (s2 - k2 * 52774) - 3791 * k2
     s2'' = if s2' < 0 then s2' + 2147483399 else s2'
~{%literal}
@doc.nip "(Droppable x) ⇒ x y -- y
~{%literal}
@doc.nip2 "(Droppable x,y) ⇒ x y z -- z
~{%literal}
@doc.nodeLeft.z.rbt "(e*(c*(l*r))) -- (l * (L*(c*(e*r))) )
~{%literal}
@doc.nodeRight.z.rbt "(e*(c*(l*r))) -- (r * (R*(c*(e*r))) )
~{%literal}
@doc.not.b "Bool -- Bool; invert boolean
~{%literal}
@doc.nub.l "remove duplicate values from list
~{%literal}
@doc.nubBy.l "a`L [eq(a a -- Bool)] -- a`L; value a, provide eq function
~{%literal}
@doc.null.l "a`L -- a`L Bool; test whether a list is empty without modifying it
~{%literal}
@doc.numbers.abc "ABC slightly favors legibility over parsimony. One aspect of this regards how numbers are represented, using decimal digits instead of binary. ABC uses eleven basic number operators:
 
     # :: e → N(0) * e  (constructs a new number)
     0 :: N(x) * e → N(10x + 0) * e
     1 :: N(x) * e → N(10x + 1) * e
     2 :: N(x) * e → N(10x + 2) * e
     ...
     9 :: N(x) * e → N(10x + 9) * e
 
 This design enables natural numbers to be expressed legibly, as in `#42` constructing the number 42. Richer numbers must be modeled using operations on or compositions of integers.
~{%literal}
@doc.octetStreamToBitStream "octet`S -- bool`S (bigendian bit orientation)
~{%literal}
@doc.or.b "Bool Bool -- Bool; is at least one argument true?
~{%literal}
@doc.ordCase "Ord [onEQ] [onLT] [onGT] -- onEQ (or onLT or onGT, depending on Ordinal
~{%literal}
@doc.ordSelect "Ord onEQ onLT onGT -- onEQ (or onLT or onGT, depending on Ordinal)
~{%literal}
@doc.over "(Copyable x) ⇒ x y -- x y x
~{%literal}
@doc.p "y x -- (x*y)
~{%literal}
@doc.paintItBlack.rbt "e'RBT -- e'RBT; red node to black node
~{%literal}
@doc.paintItRed.rbt "e'RBT -- e'RBT; black node to red node (no effect on leaf)
~{%literal}
@doc.paragraph.abc "Paragraphs in ABC are an informal concept for stream processing of ABC. The ABC stream is broken (heuristically) into reasonably sized chunks called paragraphs. The stream processor will favor executing a whole number of paragraphs at a time.  Expressing a paragraph is trivial: LF LF (10 10) in the ABC stream. The formal meaning is just identity.
 
 Using paragraphs offers many advantages for performance, maintenance, and predictable partial failure. The environment can often be kept in a 'clean' condition between paragraphs, suitable for rendering, and eliminating some bulky intermediate constructs that would otherwise be kept in memory. Typechecking can often occur at paragraph boundaries, and side-effects can often be delayed such that paragraphs represent atomic failure boundaries.
 
 In practice, if paragraphs are too large there may be issues with buffering. I think most ABC stream readers should be expected to readily support paragraphs of 32 kB, with the failure mode to process fractions of a paragraph. I imagine (without empirical evidence) that most paragraphs will be well under 4 kB.
~{%literal}
@doc.partialFactor "((a*b)+(c*d)) -- (b + d) (a + c)
~{%literal}
@doc.partition.l "(a+b)`L -- a`L b`L; lossy (loses info about interleave)
~{%literal}
@doc.partitionAppendReverse.l "a0`L b0`L (as+bs)`L -- (as(reverse)+a0)`L (bs(reverse)+b0)`L
~{%literal}
@doc.partitionBy.l "a`L a--Bool] -- a`L a`L; Copyable a
~{%literal}
@doc.partitionByKey.l "(k*v)`L k--Bool] -- (k*v)`L (k*v)`L; Copyable k
~{%literal}
@doc.partitionElem.l "a`L a(m) -- a(≤m)`L a(>m)`L; Comparable a
~{%literal}
@doc.partitionWith.l "a`L a--(b+c)] -- b`L c`L
~{%literal}
@doc.paste "paste object from hand onto top of stack (copy/paste metaphor)
~{%literal}
@doc.pick "(Copyable x) ⇒ x y z -- x y z x
~{%literal}
@doc.pmap.s "a`S a ↣ b] -- b`S; fold a process over a stream
~{%literal}
@doc.popEnv "E(a*stack) -- a E(stack); pop element from reified environment.
~{%literal}
@doc.postApply "((a*1)*(1*1))→a; unwrap result from `apply` environment
~{%literal}
@doc.preApply "a→((a*1)*(1*1)); wrap argument in `apply` environment
~{%literal}
@doc.prefix.bench "benchmarks; not part of the usual test suite
 
 note: these may cause trouble for partial evaluators (but they're also a nice validation that partial evaluators don't do too much work)
~{%literal}
@doc.prefix.doc "AO does not have 'comments' in the usual sense. Instead, a word that starts with `doc.` can document some aspect of a dictionary - e.g. a word, project, or convention. This makes documentation a first-class, computable value, though most of the time it will simply be some text.
 
 In some cases, developers will be tempted to inject remarks directly into a word. This is doable (just `"this is a comment" drop` would do) but discouraged. Instead, consider refactoring the definition into words that can be documented independently, or that have self-explanatory names.
 
 At the moment, documentation lacks a clear convention or format, just a pseudo-markdown. Most likely, this will be addressed when we start processing documentation into HTML pages or similar.
~{%literal}
@doc.prefix.eqv "There are many cases where two different expressions should be equivalent. Explicitly asserting so is useful! Not only may equivalencies serve as documentation, but they also can support automatic tests, and provide hints or tests for optimizers and refactoring tools. So prefix 'eqv' provides a generic way to suggest that two subprograms should be equivalent.
 
 The type of any 'eqv.foo' word should be:
 
         ( -- [a→b] [a→b]). 
 
 That is, developers should simply add two blocks to the current stack (in no particular order) which should have equivalent behavior modulo typeful identity. Use of the 'eqv' prefix enables external tools to systematically discover, document, and validate these assertions. Further, they may later prove useful to optimizers and code rewriting.
~{%literal}
@doc.prefix.test "Automated testing is an effective means to maintain software quality, avoid regressions, and achieve confidence in code. Test driven design can keep designs well grounded and incremental.  
 
 In AO, automatic testing is expressed simply by using the prefix 'test.' in the definitions of words. Test words can be systematically executed in a standard environment with a confined powerblock. A test can fail due to type errors, assertion failures, taking too much time or space, or emitting an error message effectfully through the powerblock.
 
 Testing has limits. You cannot prove, through testing, that bugs are absent. AO developers are encouraged also to leverage symbolic analysis, which is also expressed in a relatively dynamic manner in AO (e.g. use of the 'eqv.' or 'id.' prefixes).
~{%literal}
@doc.pushEnv "a E(stack) -- E(a*stack); push element into reified environment.
~{%literal}
@doc.put "move value at top of hand to top of stack
~{%literal}
@doc.put1st "put the first item from the hand; same as put
~{%literal}
@doc.put2nd "put the second item from the hand; same as 'hswap put'
~{%literal}
@doc.put3rd "put the third item from the hand; same as 'hrot put'
~{%literal}
@doc.put4th "put the fourth item from the hand; same as 'hroll put'
~{%literal}
@doc.putback.s "synonym for `cons.s`; adds element to front of stream
~{%literal}
@doc.putd "put below first item on stack
~{%literal}
@doc.quot.arity2 "(N(a)*N(b))→N(q); just quotient from divMod.arity2
~{%literal}
@doc.quote "x -- [--x]
~{%literal}
@doc.quote.abc "(a*e)→([s→(a*s)]*e); quote non-distributed value
~{%literal}
@doc.r "((x*y)*z) -- (x*(y*z))
~{%literal}
@doc.r.abc "((a*b)*c)→(a*(b*c)); associate right
~{%literal}
@doc.r_ "(((a*b)*c)*e)→((a*(b*c))*e); ~ `[%r]$`
~{%literal}
@doc.rawCompareNumbers "(Num*Num)→Ord
~{%literal}
@doc.rawCompareNumbers' "(Num(a)*Num(b))→((EQ(a*a))+(LT(a*b)+GT(b*a)))
~{%literal}
@doc.rawCompareToCompareOnStack "[(k*k)→Ord] -- k k -- Ord]
~{%literal}
@doc.reifyHand "hand becomes single object in fresh hand
~{%literal}
@doc.reifyStack "(s*e)→((s*Unit)*e) : stack becomes object on fresh stack
~{%literal}
@doc.rel.abc "([x→y]*e)→([x→y]k*e); adds relevance (no drop) attribute to block
~{%literal}
@doc.relevant "mark block on stack as relevant (not Droppable)
~{%literal}
@doc.rem.arity2 "(N(a)*N(b))→N(r); just remainder from divMod.arity2
~{%literal}
@doc.remove.l "a`L a -- a`L; removes values equal by simple comparison
~{%literal}
@doc.remove.m "Remove an element from a map by its key.
 
        (k,v)`M k -- (k,v)`M ((k*v)+1)
 
 We'll also return the value identified by this means. Use `remove_.m` if you don't care about value.
~{%literal}
@doc.removeK.rbt "Remove a value by key from the red-black binary search tree.
 
         (k*v)'RBT k [(k*k)→Ord] -- (k*v)'RBT ((k*v)+1)
 
 We'll return the removed element.
~{%literal}
@doc.removeK.t23 "Remove a value from a 2-3 search tree tree, by key.
 
        (k*v)'T23 k [(k*k)→Ord] -- (k*v)'T23 ((k*v)+1)
 
 Deletion in 2-3 trees is rather complicated. See `doc.Deletion.t23`.
~{%literal}
@doc.removeKV.AATree "Remove an element by key from a `(key*value)` AA tree. 
 
         (k*v)`AATree k [(k*k)→Ord] -- (k*v)`AATree ((k*v)+1)
 
 The removed element will be returned to the user, if it exists. This can be used for linear manipulations of the map. Though, it may be more efficient to use a zipper to navigate the tree to a target node, perform the manipulation locally, then restore the tree.
~{%literal}
@doc.removeKV.bst "Remove a `(k*v)` pair, given a key and an ordinal function on keys.
 
         (k*v)`BST k [(k*k)→Ord] -- (k*v)`BST ((k*v)+1)
 
 The removed value (if any) is returned. 
~{%literal}
@doc.removeLC.bst "Remove the leftmost child of a tree.
 
        e`BST -- e`BST (e+1)
 
 This operation is relatively straightforward :).
~{%literal}
@doc.remove_.m "(k,v)`M k -- (k,v)`M; remove and drop a value by key
~{%literal}
@doc.repN "[A] rep3 = A A A
~{%literal}
@doc.repeat "a [a -- a] n -- a; repeat block `n` times
~{%literal}
@doc.repeatUntil "[action(--)] [cond(--Bool)] N -- repeat N times or while some other condition
~{%literal}
@doc.repeatWhile "[action(--)] [cond(--Bool)] N -- repeat N times or until some other condition
~{%literal}
@doc.replaceTree.bst "After we remove an inner node from a tree, we're left with two children - a left child and a right child. We want to replace these two children with a singular, combined binary search tree. 
 
         (e`BST * e`BST) -- e`BST
 
 This is relatively simple:
 
 * take the successor, the leftmost of the right child, if it exists.
 * if no successor exists, use the left child.
~{%literal}
@doc.restoreHand "single object in hand becomes hand
~{%literal}
@doc.restoreStack "((s*Unit)*e)→(s*e) : single object on stack becomes stack
~{%literal}
@doc.reverse.l "a`L -- a`L; reverse order of elements in list
~{%literal}
@doc.reverseAppend.l "a1`L a2`L -- (reverse a2 ++ a1)`L; auxillary
~{%literal}
@doc.right.p0 "[b ↣ b'] -- [(a+b) ↣ (a+b')]; process right argument
~{%literal}
@doc.rights.s "(a+b)`S -- b`S; see `doc.lefts.s`
~{%literal}
@doc.rmx.z.rbt "Remove the current target of the zipper, then exit the zipper.
 
         e'Z.RBT -- e'RBT (e+1)
 
 Remove and exit are combined mostly because there isn't a well-defined
~{%literal}
@doc.rn.take.s "a`S count -- a`S a(reversed)`L count(remaining)
~{%literal}
@doc.roll "w x y z -- x y z w
~{%literal}
@doc.root.removeK.t23 "The inner function `root.removeK.t23` will preserve information about the hole.
 
        (k*v)'T23 k [(k*k)→Ord] -- ((k*v)'T23 + (k*v)'T23)) ((k*v)+1)
 
 The final removal of the root hole is left to `removeK.t23`.
~{%literal}
@doc.rot "x y z -- y z x
~{%literal}
@doc.roundToFrac "Align a number near an arbitrary fraction with rounding. For example:
 
     1/3 1/100 roundToFrac = 33/100
     2/3 1/100 roundToFrac = 67/100
     227 10    roundToFrac = 230
 
 Note: no special handling for negative numbers.
~{%literal}
@doc.rt2t.AATree "(Node + Tree) -- Tree
~{%literal}
@doc.run "[A] run = [A A]; equivalent to 'dup dip'
~{%literal}
@doc.runN "[A] run3 = [A A A A]
~{%literal}
@doc.scan.l "s a`L [s a -- s b] -- s b`L; simultaneous map & fold in limited env
~{%literal}
@doc.seal "a -- :a; anonymous discretionary seal; see doc.ValueSealing
~{%literal}
@doc.seal.bst "for debugging only; will probably remove seal later
~{%literal}
@doc.second.p0 "[b ↣ b'] -- [(a*b) ↣ (a*b')]; process second argument
~{%literal}
@doc.seek.z.rbt "Search down the zipper until we reach a tree with the requested key. 
 
         (k*v)'Z.RBT [k→Ord] -- (k*v)'Z.RBT
 
 Idempotent. If the key does not exist, we'll reach a leaf where the key could be placed.
~{%literal}
@doc.seekLL.z.rbt "e'Z.RBT -- e'Z.RBT; seek to leftmost leaf node
~{%literal}
@doc.setcar! "(a*b) a' -- (a'*b); droppable a (cf. wcar)
~{%literal}
@doc.setcdr! "(a*b) b' -- (a*b'); droppable b (cf. wcdr)
~{%literal}
@doc.singleton.AATree "elem -- elem`AATree
~{%literal}
@doc.singleton.bst "e -- e`BST
~{%literal}
@doc.singleton.rbt "e -- e'RBT
~{%literal}
@doc.singleton.s "a -- a`S; construct a single element stream
~{%literal}
@doc.singleton.t23 "e -- e'T23
~{%literal}
@doc.size.AATree "a`aaTree -- a`AATree Nat; O(N); count of elements
~{%literal}
@doc.size.bst "e`BST -- e`BST Nat
~{%literal}
@doc.size.m "(k,v)`M -- (k,v)`M Nat; count items in map. O(N).
~{%literal}
@doc.size.rbt "e'RBT -- e'RBT Nat; compute number of nodes in red-black tree
~{%literal}
@doc.size.t23 "a'T23 -- a'T23 Nat; find size (number of elements) of 2-3 tree
~{%literal}
@doc.snd "(x*y) -- y
~{%literal}
@doc.sortBy.l "a`L [lt(a a -- Bool)]; sort list of values given a less-than function (a a -- Bool)
~{%literal}
@doc.sortByKey.l "(k*v)`L [lt(k k -- Bool)]; sort a list by keys
~{%literal}
@doc.span.l "a`L [pred(a--PseudoBool)] -- a(rem)`L a`L; split prefix for which predicate holds
~{%literal}
@doc.spanP "a`L [a--(a+b)] -- a`L b`L; split longest sequence of `b` results (on right)
~{%literal}
@doc.spanRevAppP.l "b0`L a`L [a--(a+b)] -- (b(rev)++b0)`L a`L
~{%literal}
@doc.spanRevP.l "a`L [a--(a+b)] -- a`L b(rev)`L
~{%literal}
@doc.spin "x y z -- z y x
~{%literal}
@doc.split.l "a`L N -- a(minus first N)`L a(first N)`L; combines result of drop and take; linear.
~{%literal}
@doc.split.r "n`PRG -- n`PRG n`PRG
~{%literal}
@doc.splitReverse.l "a`L N -- a(minus first N)`L a(first N reversed)`L
~{%literal}
@doc.splitReverseAppendl.l "a0`L a`L N -- (first N from a ++ a0)`L a(minus first N)`L
~{%literal}
@doc.splitReverseN.l "a`L N -- a(minus first N)`L a(first N reversed)`L N(remaining; 0 if fully used)
~{%literal}
@doc.square.arity1 "N(a)→N(a^2)
~{%literal}
@doc.stackHand.env "Basic environment consisting of just stack and hand.
 
         (stack * (hand * unit))
 
 See @doc.std.env
~{%literal}
@doc.state.p0 "Generate a stateful process using a stack function.
 
     st [st a -- st b] -- [a ↣ b]
 
 This uses the 'apply' environment. 
 
 (Aside: Another interesting possibility is to keep state more implicitly using a whole environment (via introE). Develop this when it comes up.)
~{%literal}
@doc.static "The `{&static}` annotation is intended to guide partial evaluation. It indicates that a value should be computable and computed at compile-time. It should help when working with embedded DSLs and staged programs.
 
         {&static} :: (v*e) → (v*e); compute v statically
         static    :: v -- v
 
 A conforming compiler will take `{&static}` as a strong suggestion, computing the argument if possible and warning the developer otherwise. Even if an argument cannot be wholly evaluated, it might be partially evaluated or lifted out of a loop. More precise annotations may be necessary in some use cases. (Ideas on how to more precisely annotate partial evaluation within the constraints of ABC are welcome.)
~{%literal}
@doc.stats "Stats is a sealed structure that tracks a useful triple of values: 
 
  count, sum, sum of squares
 
 From these values, we can compute exact average and variance. Note: AO's use of exact rational numbers may become a performance problem here. (TODO: contemplate use of annotations or modulo arithmetic to control performance.)
 
 The structure is sealed to resist accidental confusions about which value is which, or enable later extension. Developers should mostly use the `.stats` suffix functions to observe the statistics. 
~{%literal}
@doc.std.env "The 'std' standard environment is just a layer of indirection to whichever environment model developers wish to experiment with. Definitions for std.env should generally be a single word from another environment model.
 
 TODO: separate operations into something much more fine grained.
  
         wrap       :: a → Env(a on stack)
         unwrap     :: Env(a on stack) → a
         wrapV      :: a -- Env(a on stack)
         unwrapV    :: Env(a on stack) -- a 
         wrapS      :: (s*e)→((Env(s)*1)*e); wrap current stack
         unwrapS    :: ((Env(s)*1)*e)→(s*e); unwrap current stack
         unwrapS    :: (fresh stack) Env
         intro      :: -- Env(empty)
         elim       :: Env(empty) --
 
 I might also want something for volatile wrappings just for one application. A feature I'd like to have is all the `applyKtoJ` functions be optimal from a small subset of fine-grained operations.
~{%literal}
@doc.stdgen.r "Generate a standard PRNG, seeded by a (usually small) natural number. In many cases, you might seed the number with the hash value of a string or value. In general, code that uses a random number generator should be separated from the code that provides the generator.
 
     seed -- PRNG
 
 The standard PRNG is insecure, and lacks a strong theoretical argument for robustness of its 'split' behavior. But it should be suitable for most use cases. It is translated directly from Haskell's standard random number generator (System.Random), and produces the same numbers under the hood. This in turn was transliterated by Lennart Augustsson from Pierre L'Ecuyer's Portable Combined Generator (1988).
~{%literal}
@doc.step.p0 "a [a↣b] -- b [a↣b]; run process one step
~{%literal}
@doc.stepLeft.z.rbt "e'Z.RBT -- e'Z.RBT; step to left child (if any)
~{%literal}
@doc.stepRight.z.rbt "e'Z.RBT -- e'Z.RBT; step to right child (if any)
~{%literal}
@doc.stepUp.z.rbt "e'Z.RBT -- e'Z.RBT; step upwards to parent (if any)
~{%literal}
@doc.sto.fixpoint "Simple implementations of fixpoint will tend to double the transport size for the naive bytecode representation of the resulting function. For example:
 
        fixpoint                r[^'ol]o^'ol
        incd                    rwr#1+lwl
        [incd] fixpoint         [[^'ol rwr#1+lwl]^'ol rwr#1+lwl]
 
 It is clear that the code for `incd` appears twice in the resulting fixpoint. For a small function like `incd`, this isn't a problem. But this doubling may be an issue for a larger function, especially in contexts of persistent storage, streaming, or distribution.
 
 Fortunately, there are variations of fixpoint with static transport overhead:
 
        sto.fixpoint            r'[^'ow^'zozlwvr$c]^'owol
        [incd] sto.fixpoint     [[rwr#1+lwl][^'ow^'zozlwvr$c]^'ow^'zozlwvr$c]
 
 For small functions like `incd`, the resulting block is a fair bit larger. However, the logic for `incd` appears only once, and this will also hold for large recursive process objects, streams, and so on. This is essentially achieved by applying the original fixpoint function to a separate function, independent of the target, which itself contains the logic to duplicate, bind, and apply the target.
 
 Note: at this point, all the normal fixpoint functions have been upgraded to static transport overhead variations. But I'm keeping this around to help document my reasoning.
~{%literal}
@doc.sub.arity2 "(N(a)*N(b))→N(a-b)
~{%literal}
@doc.suffix.AATree {%doc.AATree}
@doc.suffix.abc "A word for each of the ABC codes.
~{%literal}
@doc.suffix.b {%doc.Boolean}
@doc.suffix.bst {%doc.BinarySearchTree}
@doc.suffix.m {%doc.DataMaps}
@doc.suffix.p0 {%doc.Processes}
@doc.suffix.r {%doc.RandomNumberGeneration}
@doc.suffix.rbt {%doc.RedBlackTree}
@doc.suffix.s {%doc.Streams}
@doc.suffix.t23 {%doc.TwoThreeTree}
@doc.swap "y x -- x y
~{%literal}
@doc.swap2 "a b c d -- c d a b
~{%literal}
@doc.swap3 "a b c d e f -- d e f a b c
~{%literal}
@doc.swap4 "a b c d e f g h -- e f g h a b c d
~{%literal}
@doc.swapHands "swap reified hand on stack with current hand
~{%literal}
@doc.swapL.t23 "e'T23 e -- e'T23 (e+e); swap element with successor; returns in left on failure
~{%literal}
@doc.swapd "x y z -- y x z
~{%literal}
@doc.take "move value at top of stack to top of hand
~{%literal}
@doc.take.l "a`L N -- a`L; take first N elements of list (or the full list, if N >= length), drop rest of list
~{%literal}
@doc.take.s "a`S count -- a`S a`L; take count items from stream
~{%literal}
@doc.take1.s "a`S -- a`S (a+1); take a single element (left) or indicate empty (right)
~{%literal}
@doc.take1st "take the first item from the stack; same as take
~{%literal}
@doc.take2nd "take the second item from the stack; same as taked or swap take
~{%literal}
@doc.take3rd "take the third item from the stack; same as rot take
~{%literal}
@doc.take4th "take the fourth item from the stack; same as roll take
~{%literal}
@doc.takeExact.s "a`S count -- a`S a`L
 take exactly count items from stream, 
 or take none and return the empty list.
~{%literal}
@doc.taked "take second item from stack
~{%literal}
@doc.taking.s "a`S count -- (a`L)`S; form a stream of lists of size count (last list might be smaller)
~{%literal}
@doc.testing.bst "A simple (Nat*Nat)`BST for interactive testing purposes.
~{%literal}
@doc.text.abc "ABC has a simple block-like format for literal text.
 
     "This is example text.
      It may continue multiple lines.
      Each continuing line must begin with SP (32). 
      Terminate by starting the next line with `~`.
     ~
 
 By design, only LF (10) is to be escaped, and it is escaped by the continuing line. The final LF before `~` is not part of the text. Within an ABC stream, text should usually be formatted to start at a new line (to simplify debugging). ABC doesn't have a distinct 'text type'. Instead, literal text is shorthand for constructing a list of small integers, e.g. of type µT.((N*T)+1). The numbers correspond directly to the unicode codepoints, i.e. between 0 and 1114111 inclusive, though developers are discouraged from encoding non-character codepoints (such as 0xD800 or 0xFFFE). 
 
 Use cases for literal text include labels, embedded DSLs, human meaningful content, and potentially binary values (encoded in base64url, possibly pre-compressed). Binary representations are discouraged except for integration with non-Awelon systems. None of these normal use cases requires unusual codepoints.
~{%literal}
@doc.textBitsToList "textBits -- (1+1)`L; textBits is of form "01100001" (no other characters)
~{%literal}
@doc.toBoolean "(a+b) -- Bool; (droppable a, droppable b)
~{%literal}
@doc.toBoolean.arity1e "(a+b)*e → (1+1)*e; droppable a, droppable b
~{%literal}
@doc.toList.AATree "elem`AATree -- elem`List; access ordered list of elements
~{%literal}
@doc.toListL.bst "x`BST -- x`L; list elements starting with leftmost
~{%literal}
@doc.toListR.AATree "elem`AATree -- elem`List; access reverse-ordered list of elements
~{%literal}
@doc.toListR.bst "x`BST -- x`L; list elements starting with rightmost
~{%literal}
@doc.toListR.s "a`S -- a`L; reverse ordered list from finite stream
~{%literal}
@doc.toOrd "(eq+(lt+gt)) -- (1+(1+1)); droppable eq,lt,gt
~{%literal}
@doc.toOrd.arity1 "(eq+(lt+gt))→(1+(1+1))
~{%literal}
@doc.toStream.AATree "e`AATree -- e`Stream; stream data elements left to right
~{%literal}
@doc.toStream.arity1.l {%doc.fromList.arity1.s}
@doc.toStream.l {%doc.fromList.s}
@doc.toStream.r "n`PRG -- n`S
~{%literal}
@doc.toStreamL.bst "x`BST -- x`S; stream elements from left to right
~{%literal}
@doc.toStreamOfPrng.r "n`PRG -- (n`PRG)`S
~{%literal}
@doc.toStreamR.AATree "e`AATree -- e`Stream; stream data elements right to left
~{%literal}
@doc.toStreamR.bst "x`BST -- x`S; stream elements from right to left
~{%literal}
@doc.tree.insertKV.bst "(k*v) (k*v)`BST [insertKV] [k→Ord] -- (k*v)`BST ((k*v)+1)
~{%literal}
@doc.tree.insertKV.t23 "Documenting implementation details here... because this is relatively complex compared to most data structures.
 
        tree.insert  ::  (k*v)'T23 [tree.insert] [k→Ord] (hand: (k*v)) 
                     -- ((k*v)'T23 + Grow)  (hand: ((k*v)+1))
 
 Here we're returning either a tree OR a 'grow' proposition (along with the replaced element in the hand). The type of grow is the same as N2, indicating a new proposed tree of height one greater than the original tree. I.e. if we insert to a leaf, we always get the grow proposition. An N2 node will always absorb a 'grow' proposition by changing to an N3 node. If we attempt to grow an N3 node, the result is a new grow proposition. We can trivially grow the root, resulting in a new two-three tree.
~{%literal}
@doc.tri "[p] [q] [r] tri = [p] keep [q] keep r; apply 3 blocks to same 1 arg
~{%literal}
@doc.tri* "apply 3 blocks each to 1 respective input
~{%literal}
@doc.tri2 "apply 3 blocks to the same 2 args
~{%literal}
@doc.tri2* "apply 3 blocks each to 2 respective inputs
~{%literal}
@doc.tri2dup "apply a single block to three pairs of inputs
~{%literal}
@doc.tri3 "apply 3 blocks each to the same 3 args
~{%literal}
@doc.tri3* "apply 3 blocks each to 3 respective inputs
~{%literal}
@doc.tri3dup "apply a single block to three triples of inputs
~{%literal}
@doc.tridup "apply a single block to three different inputs
~{%literal}
@doc.trimBoolean "(x*1 + y*1) -- (x+y); may be useful after distrib
~{%literal}
@doc.tuck "(Copyable y) ⇒ x y -- y x y
~{%literal}
@doc.unless "..a (L+R) [..a L -- ..a] -- ..a
~{%literal}
@doc.unless_ "..a (L+R) [..a -- ..a] -- ..a
~{%literal}
@doc.unlessd "..a (L+R) [..a -- ..a] -- ..a (L+R)
~{%literal}
@doc.unlessk "..a (L+R) [..a L -- ..a] -- ..a (L+R)
~{%literal}
@doc.unquote "[--x] -- x
~{%literal}
@doc.unroll "x y z w -- w x y z
~{%literal}
@doc.unrot "y z x -- x y z
~{%literal}
@doc.unseal ":a -- a; unseal a value sealed by 'seal'; see doc.ValueSealing
~{%literal}
@doc.until "[action(--)] [cond(--Bool)] --; repeat action until boolean condition
~{%literal}
@doc.until1 "[action(--)] [cond(--Bool)] --; as untilCond, but act at least once
~{%literal}
@doc.until1Sum "a [a -- (a + b)] -- b
~{%literal}
@doc.untilSum "(a + b) [a -- (a + b)] -- b
~{%literal}
@doc.unzip.l "(a*b)`L -- a`L b`L
~{%literal}
@doc.v.abc "a→(a*1); intro unit right
~{%literal}
@doc.v_ "(a*e)→((a*1)*e); ~ `[%v]$`
~{%literal}
@doc.validateTree.t23 "(k*v)'T23 [(k*k)→Ord] -- (k*v)'T23; assert balanced and sorted
~{%literal}
@doc.w "(x*y) -- (y*x)
~{%literal}
@doc.w.abc "(a*(b*c))→(b*(a*c)); swap first
~{%literal}
@doc.w_ "((a*(b*c))*e)→((b*(a*c))*e); ~ `[%w]$`
~{%literal}
@doc.warn.test "warnMsg --; (io) emit message
~{%literal}
@doc.wc "(a*(b*c)) -- (b*(a*c))
~{%literal}
@doc.wcar "A variation on the Lisp-like car and cdr, 'wcaddar' will swap a value on the stack with a value deep within a data structure. 
 
         wcar :: (a*b) a' -- (a'*b) a
         wcaddar :: (a*(b*(c*d)))*e c' -- (a*(b*(c'*d)))*e c
 
 This is much more composable than car and cdr, at least in an ad-hoc sense (we can extract a deep structure, then perform further extractions on it). It is not as composable as true lenses. It is also used as the basis for the `setcar!` series of functions.
~{%literal}
@doc.wcdr {%doc.wcar}
@doc.when "..a (L+R) [..a R -- ..a] -- ..a
~{%literal}
@doc.when_ "..a (L+R) [..a -- ..a] -- ..a
~{%literal}
@doc.whend "..a (L+R) [..a -- ..a] -- ..a
~{%literal}
@doc.whenk "..a (L+R) [..a R -- ..a] -- ..a (L+R)
~{%literal}
@doc.while "[action(--)] [cond(--Bool)] --; repeat action while boolean condition
~{%literal}
@doc.while1 "[action(--)] [cond(--Bool)] --; as whileCond, but act at least once
~{%literal}
@doc.while1Sum "b [b -- (a + b)] -- a
~{%literal}
@doc.whileSum "(a + b) [b -- (a + b)] -- a
~{%literal}
@doc.whitespace.abc "ABC permits whitespace to simplify formatting. Only SP (32) and LF (10) are permitted. These are understood as operators with type (∀a.a→a). Whitespace may also express paragraphs (see @doc.paragraph.abc).
 
 AO doesn't offer direct access to ABC whitespace, though some parsers may translate AO's whitespace directly into ABC whitespace (doing so simplifies the AO parser). Paragraphs aren't useful in AO, so this whitespace will typically be eliminated.
 
 The main role of whitespace in ABC is to support formatting of ABC code for legibility.
~{%literal}
@doc.wordGenToBoolGen.r "Given a random number generator, which provides natural numbers greater than some predictable width, return a random boolean generator (per AO standard), by taking the K lowest bits of each number generated (i.e. as represented in base2).
        
     nat`PRG K -- PRNG
 
 In this case, the inner state is a triple (nat`PRG * (bitsEmitted * word)). We'll emit bits until we reach K output bits, then obtain the next word from the nat`PRG. In case of split, remaining bits will go to one of the two generators and the other will start on the next word.
~{%literal}
@doc.wordStreamToBitStream "word`S width -- bool`S (bigendian bit orientation)
~{%literal}
@doc.wordToBitList "Translate a word to a list of bits. 
 
     N(word) N(width) -- (1+1)`L
 
 A word of width N should be a value in the range 0 to 2^N - 1. For example, an octet is a word of width 8, encoding numbers in range 0..255. This function takes a single word and a given width, and produces a list of bits with big-endian orientation. Each bit is encoded as a (1+1) sum, in the left for a zero bit. 
~{%literal}
@doc.wrap.z.rbt "e'RBT -- e'Z.RBT; wrap tree in zipper
~{%literal}
@doc.wrapKeyObserver.b "[k--Bool] -- [(k*v)--((k*v)+(k*v))]; Copyable k
~{%literal}
@doc.wrapObserver.b "[a--Bool] -- [a--(a+a)]; Copyable a
~{%literal}
@doc.wrapfn "[x→y] [w→x] [y→z] -- [w→z]; wrap a function
~{%literal}
@doc.x "(x*y) -- y x
~{%literal}
@doc.xor.b "Bool Bool -- Bool; are the arguments distinct?
~{%literal}
@doc.z.abc "(a*(b*(c*d)))→(a*(c*(b*d))); swap second
~{%literal}
@doc.z_ "((a*(b*(c*d)))*e)→((a*(c*(b*d)))*e); ~ `[%z]$`
~{%literal}
@doc.zc "(a*(b*(c*d))) -- (a*(c*(b*d)))
~{%literal}
@doc.zesc.AATree "(elem`AATree * AATreeCx) -- elem`AATree; exit a zipper (assumes balanced)
~{%literal}
@doc.zfindKV.rbt "find using zipper (equivalent to findKV.rbt)
~{%literal}
@doc.zip.l "a`L b`L -- (a*b)`L; will truncate if one list is smaller than the other
~{%literal}
@doc.zip.s "a`S b`S -- (a*b)`S; truncate larger stream (which must be droppable)
~{%literal}
@doc.zip2 "(c*d) (a*b) -- (b*d) (a*c)
~{%literal}
@doc.zipRem.l "a`L b`L -- (a*b)`L a(rem)`L b(rem)`L; zip with remainder (in case lists not equal)
~{%literal}
@doc.zipRem.s "Zip two streams of unknown relative size. If they are of equal size, all elements will be returned in the left. If streams are of unequal size, we'll return the longer, remaining stream in the right (as the final element in the stream).
 
         a`S b`S -- ((a*b)+(a`S+b`S))`S 
 
 I have contemplated a variation on streams that always return a value on termination. However, it is not clear how one would go about composing those streams in other ways (e.g. `addend` is a little unclear). This results in an awkward construction to handle streams of different sizes.
~{%literal}
@doc.zwrap.AATree "elem`AATree -- (elem`AATree * AATreeCx); create a zipper
~{%literal}
@doc.÷ "This is unicode division, U+F7. Just because.
~{%literal}
@doc.− "unicode minus, U+2212
~{%literal}
@wcar {%dx}{%swap}{%dp}
@wcaar {%dx}{%wcar}{%dp}
@wcaaar {%dx}{%wcaar}{%dp}
@wcaaaar {%dx}{%wcaaar}{%dp}
@wcaaaaar {%dx}{%wcaaaar}{%dp}
@intro1d {%.rw}{%intro1}{%.wl}
@wcxxr→dpcxxr {%swap}{%.rw}{%dup}{%.rw}{%intro1d}{%inline}{%swap}{%.wl}{%pw}{%.wl}{%dip}{%wx}{%swapd}{%inline}{%elim1}
@dpcaaaaar [{%wcaaaaar}]{%block}{%wcxxr→dpcxxr}
@wcaaaadr {%dwx}{%wcaaaar}{%dpw}
@dpcaaaadr [{%wcaaaadr}]{%block}{%wcxxr→dpcxxr}
@dpcaaaar [{%wcaaaar}]{%block}{%wcxxr→dpcxxr}
@wcaaadr {%dwx}{%wcaaar}{%dpw}
@wcaaadar {%dx}{%wcaaadr}{%dp}
@dpcaaadar [{%wcaaadar}]{%block}{%wcxxr→dpcxxr}
@wcaaaddr {%dwx}{%wcaaadr}{%dpw}
@dpcaaaddr [{%wcaaaddr}]{%block}{%wcxxr→dpcxxr}
@dpcaaadr [{%wcaaadr}]{%block}{%wcxxr→dpcxxr}
@dpcaaar [{%wcaaar}]{%block}{%wcxxr→dpcxxr}
@wcaadr {%dwx}{%wcaar}{%dpw}
@wcaadar {%dx}{%wcaadr}{%dp}
@wcaadaar {%dx}{%wcaadar}{%dp}
@dpcaadaar [{%wcaadaar}]{%block}{%wcxxr→dpcxxr}
@wcaadadr {%dwx}{%wcaadar}{%dpw}
@dpcaadadr [{%wcaadadr}]{%block}{%wcxxr→dpcxxr}
@dpcaadar [{%wcaadar}]{%block}{%wcxxr→dpcxxr}
@wcaaddr {%dwx}{%wcaadr}{%dpw}
@wcaaddar {%dx}{%wcaaddr}{%dp}
@dpcaaddar [{%wcaaddar}]{%block}{%wcxxr→dpcxxr}
@wcaadddr {%dwx}{%wcaaddr}{%dpw}
@dpcaadddr [{%wcaadddr}]{%block}{%wcxxr→dpcxxr}
@dpcaaddr [{%wcaaddr}]{%block}{%wcxxr→dpcxxr}
@dpcaadr [{%wcaadr}]{%block}{%wcxxr→dpcxxr}
@dpcaar [{%wcaar}]{%block}{%wcxxr→dpcxxr}
@wcadr {%dwx}{%wcar}{%dpw}
@wcadar {%dx}{%wcadr}{%dp}
@wcadaar {%dx}{%wcadar}{%dp}
@wcadaaar {%dx}{%wcadaar}{%dp}
@dpcadaaar [{%wcadaaar}]{%block}{%wcxxr→dpcxxr}
@wcadaadr {%dwx}{%wcadaar}{%dpw}
@dpcadaadr [{%wcadaadr}]{%block}{%wcxxr→dpcxxr}
@dpcadaar [{%wcadaar}]{%block}{%wcxxr→dpcxxr}
@wcadadr {%dwx}{%wcadar}{%dpw}
@wcadadar {%dx}{%wcadadr}{%dp}
@dpcadadar [{%wcadadar}]{%block}{%wcxxr→dpcxxr}
@wcadaddr {%dwx}{%wcadadr}{%dpw}
@dpcadaddr [{%wcadaddr}]{%block}{%wcxxr→dpcxxr}
@dpcadadr [{%wcadadr}]{%block}{%wcxxr→dpcxxr}
@dpcadar [{%wcadar}]{%block}{%wcxxr→dpcxxr}
@wcaddr {%dwx}{%wcadr}{%dpw}
@wcaddar {%dx}{%wcaddr}{%dp}
@wcaddaar {%dx}{%wcaddar}{%dp}
@dpcaddaar [{%wcaddaar}]{%block}{%wcxxr→dpcxxr}
@wcaddadr {%dwx}{%wcaddar}{%dpw}
@dpcaddadr [{%wcaddadr}]{%block}{%wcxxr→dpcxxr}
@dpcaddar [{%wcaddar}]{%block}{%wcxxr→dpcxxr}
@wcadddr {%dwx}{%wcaddr}{%dpw}
@wcadddar {%dx}{%wcadddr}{%dp}
@dpcadddar [{%wcadddar}]{%block}{%wcxxr→dpcxxr}
@wcaddddr {%dwx}{%wcadddr}{%dpw}
@dpcaddddr [{%wcaddddr}]{%block}{%wcxxr→dpcxxr}
@dpcadddr [{%wcadddr}]{%block}{%wcxxr→dpcxxr}
@dpcaddr [{%wcaddr}]{%block}{%wcxxr→dpcxxr}
@dpcadr [{%wcadr}]{%block}{%wcxxr→dpcxxr}
@dpcar {%dwx}{%dip}{%pw}
@wcdr {%dwx}{%swap}{%dpw}
@wcdar {%dx}{%wcdr}{%dp}
@wcdaar {%dx}{%wcdar}{%dp}
@wcdaaar {%dx}{%wcdaar}{%dp}
@wcdaaaar {%dx}{%wcdaaar}{%dp}
@dpcdaaaar [{%wcdaaaar}]{%block}{%wcxxr→dpcxxr}
@wcdaaadr {%dwx}{%wcdaaar}{%dpw}
@dpcdaaadr [{%wcdaaadr}]{%block}{%wcxxr→dpcxxr}
@dpcdaaar [{%wcdaaar}]{%block}{%wcxxr→dpcxxr}
@wcdaadr {%dwx}{%wcdaar}{%dpw}
@wcdaadar {%dx}{%wcdaadr}{%dp}
@dpcdaadar [{%wcdaadar}]{%block}{%wcxxr→dpcxxr}
@wcdaaddr {%dwx}{%wcdaadr}{%dpw}
@dpcdaaddr [{%wcdaaddr}]{%block}{%wcxxr→dpcxxr}
@dpcdaadr [{%wcdaadr}]{%block}{%wcxxr→dpcxxr}
@dpcdaar [{%wcdaar}]{%block}{%wcxxr→dpcxxr}
@wcdadr {%dwx}{%wcdar}{%dpw}
@wcdadar {%dx}{%wcdadr}{%dp}
@wcdadaar {%dx}{%wcdadar}{%dp}
@dpcdadaar [{%wcdadaar}]{%block}{%wcxxr→dpcxxr}
@wcdadadr {%dwx}{%wcdadar}{%dpw}
@dpcdadadr [{%wcdadadr}]{%block}{%wcxxr→dpcxxr}
@dpcdadar [{%wcdadar}]{%block}{%wcxxr→dpcxxr}
@wcdaddr {%dwx}{%wcdadr}{%dpw}
@wcdaddar {%dx}{%wcdaddr}{%dp}
@dpcdaddar [{%wcdaddar}]{%block}{%wcxxr→dpcxxr}
@wcdadddr {%dwx}{%wcdaddr}{%dpw}
@dpcdadddr [{%wcdadddr}]{%block}{%wcxxr→dpcxxr}
@dpcdaddr [{%wcdaddr}]{%block}{%wcxxr→dpcxxr}
@dpcdadr [{%wcdadr}]{%block}{%wcxxr→dpcxxr}
@dpcdar [{%wcdar}]{%block}{%wcxxr→dpcxxr}
@wcddr {%dwx}{%wcdr}{%dpw}
@wcddar {%dx}{%wcddr}{%dp}
@wcddaar {%dx}{%wcddar}{%dp}
@wcddaaar {%dx}{%wcddaar}{%dp}
@dpcddaaar [{%wcddaaar}]{%block}{%wcxxr→dpcxxr}
@wcddaadr {%dwx}{%wcddaar}{%dpw}
@dpcddaadr [{%wcddaadr}]{%block}{%wcxxr→dpcxxr}
@dpcddaar [{%wcddaar}]{%block}{%wcxxr→dpcxxr}
@wcddadr {%dwx}{%wcddar}{%dpw}
@wcddadar {%dx}{%wcddadr}{%dp}
@dpcddadar [{%wcddadar}]{%block}{%wcxxr→dpcxxr}
@wcddaddr {%dwx}{%wcddadr}{%dpw}
@dpcddaddr [{%wcddaddr}]{%block}{%wcxxr→dpcxxr}
@dpcddadr [{%wcddadr}]{%block}{%wcxxr→dpcxxr}
@dpcddar [{%wcddar}]{%block}{%wcxxr→dpcxxr}
@wcdddr {%dwx}{%wcddr}{%dpw}
@wcdddar {%dx}{%wcdddr}{%dp}
@wcdddaar {%dx}{%wcdddar}{%dp}
@dpcdddaar [{%wcdddaar}]{%block}{%wcxxr→dpcxxr}
@wcdddadr {%dwx}{%wcdddar}{%dpw}
@dpcdddadr [{%wcdddadr}]{%block}{%wcxxr→dpcxxr}
@dpcdddar [{%wcdddar}]{%block}{%wcxxr→dpcxxr}
@wcddddr {%dwx}{%wcdddr}{%dpw}
@wcddddar {%dx}{%wcddddr}{%dp}
@dpcddddar [{%wcddddar}]{%block}{%wcxxr→dpcxxr}
@wcdddddr {%dwx}{%wcddddr}{%dpw}
@dpcdddddr [{%wcdddddr}]{%block}{%wcxxr→dpcxxr}
@dpcddddr [{%wcddddr}]{%block}{%wcxxr→dpcxxr}
@dpcdddr [{%wcdddr}]{%block}{%wcxxr→dpcxxr}
@dpcddr [{%wcddr}]{%block}{%wcxxr→dpcxxr}
@dpcdr {%dx}{%dip}{%p}
@r rrrwzlwll
@dr {%.rw}{%r}{%.wl}
@split.l {%splitReverse.l}{%reverse.l}
@drop.l {%split.l}{%drop}
@drop7 {%drop4}{%drop3}
@drop8 {%drop4}{%drop4}
@drop9 {%drop6}{%drop3}
@dup2.alt {%.rw}{%dup}{%.wl}{%dup}{%unroll2d}
@dup3.alt {%.rw}{%dup2.alt}{%.wl}{%dup}{%unroll3d}
@dup4.alt {%.rw}{%dup3.alt}{%.wl}{%dup}{%unroll4d}
@dup5.alt {%.rw}{%dup4.alt}{%.wl}{%dup}{%unroll5d}
@dup6.alt {%.rw}{%dup5.alt}{%.wl}{%dup}{%unroll6d}
@dup7.alt {%.rw}{%dup6.alt}{%.wl}{%dup}{%unroll7d}
@dup8 {%pw}{%pw}{%pw}{%pw}{%pw}{%pw}{%pw}{%dup}{%dwx}{%dwx}{%dwx}{%dwx}{%dwx}{%dwx}{%dwx}{%wx}{%wx}{%wx}{%wx}{%wx}{%wx}{%wx}
@dupdd {%.rw}{%dupd}{%.wl}
@dupsnd {%wx}{%dup}{%dpw}
@dw {%.rw}{%w}{%.wl}
@wc rrwrwzwlwll
@dwc {%.rw}{%wc}{%.wl}
@zc rrwrwrwzwlwlwll
@dzc {%.rw}{%zc}{%.wl}
@foreach.s.onElem {%wx}wlwl{%dpw}{%dip}{%wx}{%inline}
@foreach.s.onFini {%elim1}wl{%drop}wl{%drop}
@foreach.s.step wzw{%intro1}{%.applyd}[{%foreach.s.onElem}]{%block}[{%foreach.s.onFini}]{%block}{%if}
@foreach.s [{%foreach.s.step}]{%block}{%.bind}{%.fixfirst}{%inline}
@each.s {%foreach.s}
@eachWhile.l [{%not.b}]{%block}{%compose}{%eachUntil.l}
@elemAtHead.l [{%x}{%dup}{%dp}{%inL}{%.rw}{%inL}{%.wl}]{%block}[{%inR}{%dup}]{%block}{%if}
@elemAt.l {%assertNatural+}{%dec}{%splitReverse.l}{%swap}{%elemAtHead.l}{%take}{%swap}{%reverseAppend.l}{%put}
@elim.stackHand.env rvrwlcllccc
@elim1d {%.rw}{%elim1}{%.wl}
@raw.empty.bst {%intro1}{%inL}
@seal.bst r{:bst}l
@empty.bst {%raw.empty.bst}{%seal.bst}
@seal.m r{:m}l
@empty.m {%empty.bst}{%p}{%seal.m}
@fromLeaf.rbt {%inL}{%seal.rbt}
@empty.rbt {%intro1}{%fromLeaf.rbt}
@r.fromLeaf.t23 {%inL}
@seal.t23 r{:t23}l
@fromLeaf.t23 {%r.fromLeaf.t23}{%seal.t23}
@empty.t23 {%intro1}{%fromLeaf.t23}
@mkCompareNums [{%rawCompareNumbers}]{%block}
@emptyNumMap.m {%mkCompareNums}{%empty.m}
@mkCompareTexts [{%compareTexts}]{%block}{%compareOnStackToRawCompare}
@emptyTextMap.m {%mkCompareTexts}{%empty.m}
@enumFrom.s [v^#1+wlVc]{%block}{%fromState.s}
@enum.s #1{%integer}{%enumFrom.s}
@enumFromUntil {%dupd}{%swap}{%.sub}{%rot}[{%keep}{%inc}]{%block}{%bind}{%swap}{%repeat}{%drop}
@enumFromTo {%inc}{%enumFromUntil}
@r.fromN2.t23 {%inRL}
@fromN2.t23 {%r.fromN2.t23}{%seal.t23}
@eq.n2.insertKV.t23 {%discard}{%put}{%wcadr}{%inL}{%take}{%fromN2.t23}
@eq.node.findKV.rbt {%discard}{%dupfst}{%inL}{%take}
@fromNode.rbt {%inR}{%seal.rbt}
@eq.node.seek.z.rbt {%fromNode.rbt}{%discard}
@neqb {%neq}{%toBoolean}
@eqb {%neqb}{%not}
@inRR {%inR}{%inR}
@r.fromN3.t23 {%inRR}
@fromN3.t23 {%r.fromN3.t23}{%seal.t23}
@eqk1.n3.insertKV.t23 {%discard2}{%put}{%wcadr}{%inL}{%take}{%fromN3.t23}{%inL}
@eqk2.n3.insertKV.t23 {%discard}{%put}{%wcadr}{%inL}{%take}{%pw}{%pw}{%fromN3.t23}{%inL}
@eqv.WZW.ZWZ [ZWZ]{%block}[WZW]{%block}
@eqv.addendEmpty.s.1 [{%empty.s}{%addend.s}]{%block}[]{%block}
@eqv.addendEmpty.s.2 [{%empty.s}{%swap}{%addend.s}]{%block}[]{%block}
@eqv.appTwice.compApp [{%compose}{%apply}]{%block}[{%unrot}{%apply}{%swap}{%apply}]{%block}
@eqv.apply [{%apply}]{%block}[{%apply.alt}]{%block}
@eqv.apply1.intro1Appd [{%.apply1}]{%block}[{%intro1}{%.applyd}]{%block}
@eqv.bindKVCmp.AATree [{%bindKVCmp.AATree}]{%block}[{%.rw}{%x}{%dup}{%dp}{%.wl}{%.bind}]{%block}
@toListR.s {%empty.l}{%swap}[{%cons.l}]{%block}{%foreach.s}
@toList.s {%toListR.s}{%reverse.l}
@fromStream.l {%toList.s}
@eqv.bitStreamText [{%bitStreamToText}{%fromStream.l}]{%block}[{%fromStream.l}{%bitListToText}]{%block}
@eqv.caaar [{%caaar}]{%block}[{%r}{%r}{%car}{%dl}{%dl}]{%block}
@eqv.caar [{%caar}]{%block}[{%r}{%car}{%dl}]{%block}
@eqv.cca [{%.both}]{%block}[{%swap}{%take2}{%pw}{%put2}{%.both}{%pw}]{%block}
@eqv.cca+ [{%.either}]{%block}[{%swap}{%take2}{%not}{%put2}{%.either}{%not}]{%block}
@relevant rkl
@eqv.commutative.affrel [{%affine}{%relevant}]{%block}[{%relevant}{%affine}]{%block}
@eqv.commutative.and.b [{%and.b}]{%block}[{%swap}{%and.b}]{%block}
@or.b {%distrib}r[c]?RVRW[v%]?WLCl
@eqv.commutative.or.b [{%or.b}]{%block}[{%swap}{%or.b}]{%block}
@xor.b {%distrib}r[c]?VRW[c]?LCRWZLVR[vMc]?W[vMc]?WLCl
@eqv.commutative.xor.b [{%xor.b}]{%block}[{%swap}{%xor.b}]{%block}
@eqv.deMorgans.1 [{%and.b}{%not.b}]{%block}[{%not.b}{%swap}{%not.b}{%swap}{%or.b}]{%block}
@eqv.deMorgans.2 [{%or.b}{%not.b}]{%block}[{%not.b}{%swap}{%not.b}{%swap}{%and.b}]{%block}
@eqv.decimal6_12.6 [{%decimal6}]{%block}[{%decimal12}{%decimal6}]{%block}
@eqv.decimal6_6 [{%decimal6}]{%block}[{%decimal6}{%decimal6}]{%block}
@eqv.decimal6_6.12 [{%decimal6}]{%block}[{%decimal6}{%decimal12}]{%block}
@eqv.dropReverse.l [{%drop}]{%block}[{%reverse.l}{%drop}]{%block}
@eqv.dup2 [{%dup2}]{%block}[{%dup2.alt}]{%block}
@eqv.dup3 [{%dup3}]{%block}[{%dup3.alt}]{%block}
@eqv.dup4 [{%dup4}]{%block}[{%dup4.alt}]{%block}
@eqv.dup5 [{%dup5}]{%block}[{%dup5.alt}]{%block}
@eqv.dup6 [{%dup6}]{%block}[{%dup6.alt}]{%block}
@eqv.dup7 [{%dup7}]{%block}[{%dup7.alt}]{%block}
@eqv.dupSwap [{%dup}{%swap}]{%block}[{%dup}]{%block}
@eqv.fst.wxdrop [{%fst}]{%block}[{%wx}{%drop}]{%block}
@hdrop {%hsw}{%drop}{%hsw}
@eqv.hdrop.discard [{%hdrop}]{%block}[{%put}{%drop}]{%block}
@eqv.id..assertUnit [{%.assertUnit}]{%block}[]{%block}
@eqv.id..lw³ [l{%.swap}l{%.swap}l{%.swap}]{%block}[]{%block}
@eqv.id..rw³ [r{%.swap}r{%.swap}r{%.swap}]{%block}[]{%block}
@eqv.id..wl³ [{%.swap}l{%.swap}l{%.swap}l]{%block}[]{%block}
@eqv.id..wr³ [{%.swap}r{%.swap}r{%.swap}r]{%block}[]{%block}
@eqv.id.CV [CV]{%block}[]{%block}
@eqv.id.LR [LR]{%block}[]{%block}
@eqv.id.RL [RL]{%block}[]{%block}
@eqv.id.VC [VC]{%block}[]{%block}
@eqv.id.WW [WW]{%block}[]{%block}
@eqv.id.ZZ [ZZ]{%block}[]{%block}
@eqv.id.abc.cv [cv]{%block}[]{%block}
@eqv.id.abc.lr [lr]{%block}[]{%block}
@eqv.id.abc.rl [rl]{%block}[]{%block}
@eqv.id.abc.vc [vc]{%block}[]{%block}
@eqv.id.abc.ww [ww]{%block}[]{%block}
@eqv.id.abc.zz [zz]{%block}[]{%block}
@eqv.id.add0 [#{%integer}{%.add}]{%block}[]{%block}
@eqv.id.append.l.empty [{%empty.l}{%append.l}]{%block}[]{%block}
@eqv.id.appendl.l.empty [{%empty.l}{%appendl.l}]{%block}[]{%block}
@id 
@eqv.id.apply.id [[{%id}]{%block}{%apply}]{%block}[]{%block}
@eqv.id.assertBoolean [{%assertBoolean}]{%block}[]{%block}
@eqv.id.assertChar [{%assertChar}]{%block}[]{%block}
@eqv.id.assertEQ.n [{%assertEQ.n}]{%block}[]{%block}
@eqv.id.assertEQz [{%assertEQz}]{%block}[]{%block}
@eqv.id.assertGT [{%assertGT}]{%block}[]{%block}
@eqv.id.assertGTE [{%assertGTE}]{%block}[]{%block}
@eqv.id.assertGTEz [{%assertGTEz}]{%block}[]{%block}
@eqv.id.assertGTz [{%assertGTz}]{%block}[]{%block}
@eqv.id.assertInR [{%inR}{%assert}]{%block}[]{%block}
@eqv.id.assertInteger [{%assertInteger}]{%block}[]{%block}
@eqv.id.assertLT [{%assertLT}]{%block}[]{%block}
@eqv.id.assertLTE [{%assertLTE}]{%block}[]{%block}
@eqv.id.assertLTEz [{%assertLTEz}]{%block}[]{%block}
@eqv.id.assertLTz [{%assertLTz}]{%block}[]{%block}
@eqv.id.assertNEQ.n [{%assertNEQ.n}]{%block}[]{%block}
@eqv.id.assertNatural [{%assertNatural}]{%block}[]{%block}
@eqv.id.assertNatural+ [{%assertNatural+}]{%block}[]{%block}
@eqv.id.assertProb [{%assertProb}]{%block}[]{%block}
@eqv.id.assertUniform [{%assertUniform}]{%block}[]{%block}
@eqv.id.compose [[{%id}]{%block}{%compose}]{%block}[]{%block}
@eqv.id.composel [[{%id}]{%block}{%composel}]{%block}[]{%block}
@eqv.id.copyDiscard [{%copy}{%discard}]{%block}[]{%block}
@eqv.id.div1 [#1{%integer}{%.div}]{%block}[]{%block}
@eqv.id.dup2drop2 [{%dup2}{%drop2}]{%block}[]{%block}
@eqv.id.dupSwapDrop [{%dup}{%swap}{%drop}]{%block}[]{%block}
@eqv.id.dupSwapdDropSwap [{%dup}{%swapd}{%drop}{%swap}]{%block}[]{%block}
@eqv.id.dupdrop [{%dup}{%drop}]{%block}[]{%block}
@eqv.id.elimIntro [{%elim1}{%intro1}]{%block}[]{%block}
@eqv.id.inline.id [[{%id}]{%block}{%inline}]{%block}[]{%block}
@eqv.id.introElim [{%intro1}{%elim1}]{%block}[]{%block}
@juggle3 {%hsw}{%roll3}{%hsw}
@eqv.id.juggle3 [{%juggle3}{%juggle3}{%juggle3}]{%block}[]{%block}
@length.l #{%integer}{%empty.l}{%rot}[{%cons.l}{%incd}]{%block}[{%each.l}]{%block}{%apply4to2}{%reverse.l}{%swap}
@eqv.id.length.l [{%length.l}{%drop}]{%block}[]{%block}
@eqv.id.listToStreamToList [{%fromList.s}{%toList.s}]{%block}[]{%block}
@eqv.id.lr [{%l}{%r}]{%block}[]{%block}
@eqv.id.lvrrwllcrw [lvrrwllcrw]{%block}[]{%block}
@eqv.id.lvrrwzlwlc [lvrrwzlwlc]{%block}[]{%block}
@eqv.id.lvrrzlwlcw [lvrrzlwlcw]{%block}[]{%block}
@eqv.id.lw³ [{%l}{%w}{%l}{%w}{%l}{%w}]{%block}[]{%block}
@eqv.id.mul1 [#1{%integer}{%.mul}]{%block}[]{%block}
@eqv.id.not.b [{%not.b}{%not.b}]{%block}[]{%block}
@eqv.id.notnot [{%not}{%not}]{%block}[]{%block}
@eqv.id.pasteDiscardTake [{%paste}{%discard}{%take}]{%block}[]{%block}
@eqv.id.putTake [{%put}{%take}]{%block}[]{%block}
@eqv.id.pwxswap [{%p}{%w}{%x}{%swap}]{%block}[]{%block}
@eqv.id.px [{%p}{%x}]{%block}[]{%block}
@quote r'[l]wol
@unquote {%apply0to1}
@eqv.id.quoteUnquote [{%quote}{%unquote}]{%block}[]{%block}
@reifyStack {%intro1}rwl
@reifyHand {%hsw}{%reifyStack}{%hsw}
@restoreStack rwl{%elim1}
@restoreHand {%hsw}{%restoreStack}{%hsw}
@eqv.id.reifyRestoreHand [{%reifyHand}{%restoreHand}]{%block}[]{%block}
@eqv.id.reverse.l [{%reverse.l}{%reverse.l}]{%block}[]{%block}
@eqv.id.rl [{%r}{%l}]{%block}[]{%block}
@eqv.id.roll [{%roll}{%roll}{%roll}{%roll}]{%block}[]{%block}
@eqv.id.rot [{%rot}{%rot}{%rot}]{%block}[]{%block}
@eqv.id.rrwllzrrwllz [rrwllzrrwllz]{%block}[]{%block}
@eqv.id.rrzllzrrzllz [rrzllzrrzllz]{%block}[]{%block}
@eqv.id.rwlvrrwllc [rwlvrrwllc]{%block}[]{%block}
@eqv.id.rwlzrwlz [rwlzrwlz]{%block}[]{%block}
@eqv.id.rwvrwrzllc [rwvrwrzllc]{%block}[]{%block}
@eqv.id.rw³ [{%r}{%w}{%r}{%w}{%r}{%w}]{%block}[]{%block}
@eqv.id.rzlzrzlzrzlz [rzlzrzlzrzlz]{%block}[]{%block}
@spin {%swap}{%swapd}{%swap}
@eqv.id.spin [{%spin}{%spin}]{%block}[]{%block}
@eqv.id.streamToListToStream [{%toList.s}{%fromList.s}]{%block}[]{%block}
@eqv.id.sub0 [#{%integer}{%.sub}]{%block}[]{%block}
@eqv.id.swap [{%swap}{%swap}]{%block}[]{%block}
@eqv.id.swapd [{%swapd}{%swapd}]{%block}[]{%block}
@eqv.id.swappwx [{%swap}{%p}{%w}{%x}]{%block}[]{%block}
@put3 {%put2}{%put}
@eqv.id.take3put3 [{%take3}{%put3}]{%block}[]{%block}
@juggle2 {%hsw}{%roll2}{%hsw}
@eqv.id.takeJugglePutSwap [{%take2}{%juggle2}{%put2}{%swap}]{%block}[]{%block}
@eqv.id.takePut [{%take}{%put}]{%block}[]{%block}
@eqv.id.takeSwapPutSwapd [{%take}{%swap}{%put}{%swapd}]{%block}[]{%block}
@eqv.id.textDrop ["text
~{%literal}{%drop}]{%block}[]{%block}
@eqv.id.unroll [{%unroll}{%unroll}{%unroll}{%unroll}]{%block}[]{%block}
@eqv.id.unrot [{%unrot}{%unrot}{%unrot}]{%block}[]{%block}
@inner.unzipReverseAppend.l [{%bicons.unzipReverseAppend.l}]{%block}{%each.l}
@unzipReverseAppend.l [{%inner.unzipReverseAppend.l}]{%block}{%apply3to2}
@unzipReverse.l {%empty.l}{%empty.l}{%rot}{%unzipReverseAppend.l}
@unzip.l {%unzipReverse.l}{%swap}{%reverse.l}{%swap}{%reverse.l}
@zip.l {%zipRevRem.l}{%drop}{%drop}{%reverse.l}
@eqv.id.unzip.zip.l [{%unzip.l}{%zip.l}]{%block}[]{%block}
@eqv.id.wc [{%wc}{%wc}]{%block}[]{%block}
@eqv.id.wl³ [{%w}{%l}{%w}{%l}{%w}{%l}]{%block}[]{%block}
@eqv.id.wr³ [{%w}{%r}{%w}{%r}{%w}{%r}]{%block}[]{%block}
@eqv.id.ww [{%w}{%w}]{%block}[]{%block}
@eqv.id.xp [{%x}{%p}]{%block}[]{%block}
@eqv.id.zc [{%zc}{%zc}]{%block}[]{%block}
@eqv.id.zip2 [{%zip2}{%zip2}]{%block}[]{%block}
@eqv.id.zipRem.unzip.l [{%zipRem.l}{%rot}{%unzip.l}{%swapd}{%appendl.l}{%unrot}{%appendl.l}{%swap}]{%block}[]{%block}
@eqv.id.zrwlzrwl [zrwlzrwl]{%block}[]{%block}
@eqv.id.zrzlzrzlzrzl [zrzlzrzlzrzl]{%block}[]{%block}
@eqv.idempotent.affine [{%affine}{%affine}]{%block}[{%affine}]{%block}
@linear {%relevant}{%affine}
@eqv.idempotent.linear [{%linear}{%linear}]{%block}[{%linear}]{%block}
@eqv.idempotent.nubList [{%nub.l}]{%block}[{%nub.l}{%nub.l}]{%block}
@eqv.idempotent.relevant [{%relevant}{%relevant}]{%block}[{%relevant}]{%block}
@eqv.idempotent.toBoolean [{%toBoolean}]{%block}[{%toBoolean}{%toBoolean}]{%block}
@eqv.inline.c [{%c$}]{%block}[{%c_}]{%block}
@l$ [l]$
@eqv.inline.l [{%l$}]{%block}[{%l_}]{%block}
@r$ [r]$
@eqv.inline.r [{%r$}]{%block}[{%r_}]{%block}
@v$ [v]$
@eqv.inline.v [{%v$}]{%block}[{%v_}]{%block}
@w$ [w]$
@eqv.inline.w [{%w$}]{%block}[{%w_}]{%block}
@z$ [z]$
@eqv.inline.z [{%z$}]{%block}[{%z_}]{%block}
@eqv.inlineTwice.compInline [{%compose}{%inline}]{%block}[{%swap}{%dip}{%inline}]{%block}
@eqv.inner.c_ [r{%c_}l]{%block}[{%c__}]{%block}
@eqv.inner.c__ [r{%c__}l]{%block}[{%c___}]{%block}
@eqv.inner.l_ [r{%l_}l]{%block}[{%l__}]{%block}
@z__ {%r_}{%w_}{%w__}{%w_}{%l_}
@l___ {%r__}{%w__}{%r__}{%z__}{%w__}{%l__}{%l__}
@eqv.inner.l__ [r{%l__}l]{%block}[{%l___}]{%block}
@eqv.inner.r_ [r{%r_}l]{%block}[{%r__}]{%block}
@r___ {%r__}{%r__}{%w__}{%z__}{%l__}{%w__}{%l__}
@eqv.inner.r__ [r{%r__}l]{%block}[{%r___}]{%block}
@eqv.inner.v_ [r{%v_}l]{%block}[{%v__}]{%block}
@v___ {%v__}{%r__}{%w__}{%v__}{%r__}{%w__}{%l__}{%c__}
@eqv.inner.v__ [r{%v__}l]{%block}[{%v___}]{%block}
@eqv.inner.w_ [r{%w_}l]{%block}[{%w__}]{%block}
@w___ {%r__}{%w__}{%r__}{%w__}{%z__}{%w__}{%l__}{%w__}{%l__}
@eqv.inner.w__ [r{%w__}l]{%block}[{%w___}]{%block}
@eqv.inner.z_ [r{%z_}l]{%block}[{%z__}]{%block}
@z___ {%r__}{%w__}{%w___}{%w__}{%l__}
@eqv.inner.z__ [r{%z__}l]{%block}[{%z___}]{%block}
@intro.stackHand.env vvvrrvrwlcl
@pushEnv rrzwrzlzll
@wrapV.stackHand.env rvrwvvrrvrwlcl
@eqv.introPush.wrapV.stackHand.env [{%intro.stackHand.env}{%pushEnv}]{%block}[{%wrapV.stackHand.env}]{%block}
@keep6 {%.rw}{%dup6}{%pw}{%pw}{%pw}{%pw}{%pw}{%.wl}{%dip}{%wx}{%wx}{%wx}{%wx}{%wx}
@eqv.keep6 [{%take}{%dup6}{%put}{%dip6}]{%block}[{%keep6}]{%block}
@eqv.mapStreamOrList [{%map.s}{%fromStream.l}]{%block}[{%swap}{%fromStream.l}{%swap}{%map.l}]{%block}
@mapP.l [{%apply}]{%block}{%bind}[{%map.l}]{%block}{%apply2to1}
@eqv.mapTwice.compMap [{%compose}{%mapP.l}]{%block}[{%unrot}{%mapP.l}{%swap}{%mapP.l}]{%block}
@eqv.p1drop2 [{%p}{%drop}]{%block}[{%drop2}]{%block}
@eqv.p2drop3 [{%p}{%p}{%drop}]{%block}[{%drop3}]{%block}
@eqv.p3drop4 [{%p}{%p}{%p}{%drop}]{%block}[{%drop4}]{%block}
@popEnv rrzrzlwzll
@unwrapV.stackHand.env rvrwlcllccwlcl
@eqv.popElim.unwrapV.stackHand.env [{%popEnv}{%elim.stackHand.env}]{%block}[{%unwrapV.stackHand.env}]{%block}
@hdup {%hsw}{%dup}{%hsw}
@eqv.putDupTake2.hdup [{%put}{%dup}{%take2}]{%block}[{%hdup}]{%block}
@eqv.pw2drop3 [{%pw}{%pw}{%drop}]{%block}[{%drop3}]{%block}
@run0 
@rep1 {%run0}{%inline}
@eqv.rep1 [{%inline}]{%block}[{%rep1}]{%block}
@run rvr^z$wlcl
@run1 {%run0}{%run}
@run2 {%run1}{%run}
@run3 {%run2}{%run}
@rep4 {%run3}{%inline}
@eqv.rep4 [{%dup}{%dip}{%dup}{%dip}{%dup}{%dip}{%inline}]{%block}[{%rep4}]{%block}
@eqv.rrrwlll.xwp [rrrwlll]{%block}[{%x}{%w}{%p}]{%block}
@snd rr%l
@eqv.snd.xdrop [{%snd}]{%block}[{%x}{%drop}]{%block}
@eqv.swap.pwx [{%p}{%w}{%x}]{%block}[{%swap}]{%block}
@hswap {%hsw}{%swap}{%hsw}
@eqv.takeHswapPut.putSwapTake [{%take}{%hswap}{%put}]{%block}[{%put}{%swap}{%take}]{%block}
@eqv.takeSwapPut.swapd [{%take}{%swap}{%put}]{%block}[{%swapd}]{%block}
@eqv.tuck.v1 [{%tuck}]{%block}[{%dup}{%unrot}]{%block}
@eqv.tuck.v2 [{%tuck}]{%block}[{%swap}{%over}]{%block}
@vrwlc__ {%v__}{%r__}{%w__}{%l__}{%c__}
@eqv.vrwlc__.rrwll [rrwll]{%block}[{%vrwlc__}]{%block}
@vrwlc___ {%v___}{%r___}{%w___}{%l___}{%c___}
@eqv.vrwlc___.rrrwlll [rrrwlll]{%block}[{%vrwlc___}]{%block}
@eqv.wc.lxwpr [{%wc}]{%block}[{%l}{%x}{%w}{%p}{%r}]{%block}
@eqv.wzw.zwz [zwz]{%block}[wzw]{%block}
@eqv.zc.3wx_swapd_3pw [{%zc}]{%block}[{%wx}{%wx}{%wx}{%swapd}{%pw}{%pw}{%pw}]{%block}
@eqv.zc.wxwcpw [{%zc}]{%block}[{%wx}{%wc}{%pw}]{%block}
@wrap.z.rbt {%empty.l}{%pw}
@wrapd.z.rbt {%.rw}{%wrap.z.rbt}{%.wl}
@leaf.seek.z.rbt {%fromLeaf.rbt}{%discard2}
@nodeLeft.z.rbt {%wc}{%l}{%w}{%r}{%wx}{%w}{%r}{%dirLeft.z.rbt}{%p}{%pw}
@lt.node.seek.z.rbt {%nodeLeft.z.rbt}{%wx}{%consd.l}{%hap}
@nodeRight.z.rbt {%wc}{%l}{%w}{%r}{%wc}{%wx}{%w}{%r}{%dirRight.z.rbt}{%p}{%pw}
@gt.node.seek.z.rbt {%nodeRight.z.rbt}{%wx}{%consd.l}{%hap}
@ordSelect {%pw}{%pw}{%.rw}[{%drop}{%.wl}{%fst}]{%block}[{%.wl}{%snd}{%wx}{%condSelect_}]{%block}{%if}
@ordCase {%ordSelect}{%inline}
@node.seek.z.rbt {%caar}{%put}{%.apply}[{%eq.node.seek.z.rbt}]{%block}[{%lt.node.seek.z.rbt}]{%block}[{%gt.node.seek.z.rbt}]{%block}{%ordCase}
@tree.seek.z.rbt {%swap}{%take2}{%unseal.rbt}[{%leaf.seek.z.rbt}]{%block}[{%node.seek.z.rbt}]{%block}{%if}
@seek.z.rbt {%dx}[{%tree.seek.z.rbt}]{%block}{%bind}{%fixpoint}{%inline}{%p}
@tree.zfindKV.rbt {%unseal.rbt}[{%intro1}{%inR}{%take}{%inL}]{%block}[{%dupfst}{%inL}{%take}{%inR}]{%block}{%if}{%seal.rbt}
@putd {%put}{%swap}
@exit.z.rbt.step {%x}{%dwc}{%dl}{%dwx}{%putd}[{%p}]{%block}[{%pw}]{%block}{%if_}{%pw}{%r}{%fromNode.rbt}{%take}
@exit.z.rbt {%x}{%take}[{%exit.z.rbt.step}]{%block}{%each.l}{%put}
@zfindKV.rbt {%.bind}{%wrapd.z.rbt}{%seek.z.rbt}{%x}{%tree.zfindKV.rbt}{%p}{%exit.z.rbt}{%put}
@leaf.findKV.rbt {%discard2}{%intro1}{%inR}{%take}
@lt.node.findKV.rbt {%wx}{%wx}{%x}{%hap}{%p}{%pw}{%pw}
@gt.node.findKV.rbt {%wx}{%wx}{%wx}{%hap}{%pw}{%pw}{%pw}
@node.findKV.rbt {%caar}{%put}{%.apply}[{%eq.node.findKV.rbt}]{%block}[{%lt.node.findKV.rbt}]{%block}[{%gt.node.findKV.rbt}]{%block}{%ordCase}
@tree.findKV.rbt {%swap}{%take2}{%unseal.rbt}[{%leaf.findKV.rbt}{%inL}]{%block}[{%node.findKV.rbt}{%inR}]{%block}{%if}{%seal.rbt}
@findKV.rbt {%.bind}[{%tree.findKV.rbt}]{%block}{%bind}{%fixpoint}{%inline}{%put}
@eqv.zfind.find.rbt [{%zfindKV.rbt}]{%block}[{%findKV.rbt}]{%block}
@eqv.zwz_.wzw_ [{%w_}{%z_}{%w_}]{%block}[{%z_}{%w_}{%z_}]{%block}
@eqv.zwzc.wzwc [{%wc}{%zc}{%wc}]{%block}[{%zc}{%wc}{%zc}]{%block}
@error.test "error
~{%literal}{%p}{%cmd.test}{%drop}
@exitrb.z.rbt {%exit.z.rbt}
@exp10 
@factorial.fixpoint.step {%take}#2{%integer}{%lt}[{%snd}{%dup}{%dec}{%put}{%apply}{%.mul}]{%block}[{%fst}{%discard}]{%block}{%if}
@factorial.fixpoint {%assertNatural}[{%factorial.fixpoint.step}]{%block}{%fixpoint}{%apply}
@false {%false.b}
@fibonacci #1{%integer}#{%integer}[{%dup}{%swapd}{%.add}]{%block}{%roll}{%repeat}{%dropd}
@filterBy.l {%partitionBy.l}{%dropd}
@singleton.s {%empty.s}{%swap}{%cons.s}
@toS.filterBy.s [{%drop}{%empty.s}]{%block}[{%singleton.s}]{%block}{%if_}
@flatten.s [{%flatten.s.step}]{%block}{%.fixfirst}{%.bind}
@filterBy.s [{%dup}]{%block}[{%toS.filterBy.s}]{%block}{%wrapfn}{%map.s}{%flatten.s}
@toS.rights.s [{%drop}{%empty.s}]{%block}[{%singleton.s}]{%block}{%if}
@filterWith.s [{%toS.rights.s}]{%block}{%compose}{%map.s}{%flatten.s}
@find.findKV.bst {%discard}{%dupfst}{%inL}
@find.insertKV.bst {%x}{%dpw}{%inL}{%discard}
@unseal.bst r{.bst}l
@leaf.removeLC.bst {%inL}{%seal.bst}{%intro1}{%inR}{%discard}
@seald.bst {%.rw}{%seal.bst}{%.wl}
@node.removeLC.bst {%wx}{%x}{%hap}[{%dp}{%dpw}{%inRd}{%seald.bst}]{%block}[{%drop2}{%swap}]{%block}{%if}{%inL}
@tree.removeLC.bst {%unseal.bst}[{%leaf.removeLC.bst}]{%block}[{%node.removeLC.bst}]{%block}{%if}
@removeLC.bst [{%tree.removeLC.bst}]{%block}{%take}{%hfix}{%hap}
@replaceTree.bst {%wx}{%removeLC.bst}[{%dpw}{%p}{%inR}{%seal.bst}]{%block}[{%drop2}]{%block}{%if}
@find.removeKV.bst {%discard}{%x}{%inL}{%take}{%replaceTree.bst}{%put}
@leaf.findKV.bst {%discard2}{%intro1}{%inR}
@put2nd {%hswap}{%put}
@left.findKV.bst {%wx}{%x}{%hap}{%dp}{%dpw}
@right.findKV.bst {%wx}{%wx}{%hap}{%dpw}{%dpw}
@seek.findKV.bst [{%left.findKV.bst}]{%block}[{%right.findKV.bst}]{%block}{%if_}
@node.findKV.bst {%caar}{%put2nd}{%.apply}[{%drop}{%find.findKV.bst}]{%block}[{%seek.findKV.bst}]{%block}{%if}
@tree.findKV.bst {%unseal.bst}[{%leaf.findKV.bst}{%inLd}]{%block}[{%node.findKV.bst}{%inRd}]{%block}{%if}{%seald.bst}
@findKV.bst {%.bind}[{%take2}{%tree.findKV.bst}]{%block}{%bind}{%fixpoint}{%inline}
@step.first.p0 wz$rz'o
@first.p0 [{%step.first.p0}]{%block}{%.fixfirst}{%.bind}
@fixpoint.v1 [{%dup}{%bind}]{%block}{%composel}{%dup}{%bind}
@fixpoint.v2 r[^'ol]o^'ol
@fixpoint.v3 r'[^'ow^'zozlwvr$c]^'owol
@t.fmap.AATree {%take}[{%put}{%inline}{%inL}]{%block}[{%discard}{%inR}]{%block}{%if}
@rt.fmap.AATree {%take}[{%put}{%inline}{%inL}]{%block}[{%put}{%t.fmap.AATree}{%inR}]{%block}{%if}
@n.fmap.AATree {%take2}{%wx}{%x}{%paste}{%t.fmap.AATree}{%swap}{%put}{%rt.fmap.AATree}{%pw}{%swap}{%put}{%.apply}{%p}
@r.fmap.AATree [{%n.fmap.AATree}]{%block}{%bind}{%fixpoint}{%t.fmap.AATree}
@fmap.AATree [{%r.fmap.AATree}]{%block}{%apply2to1}
@node.fmap.bst {%wx}{%x}{%hapc}{%rot}{%put2nd}{%.apply}{%rot}{%hap}{%rot}{%p}{%pw}
@tree.fmap.bst {%unseal.bst}[{%discard2}{%inL}]{%block}[{%node.fmap.bst}{%inR}]{%block}{%if}{%seal.bst}
@fmap.bst [{%take2}{%tree.fmap.bst}]{%block}{%bind}{%fixpoint}{%inline}
@n2.fmap.t23 "TODO!t23
~{%literal}
@n3.fmap.t23 "TODO!t23
~{%literal}
@nn.fmap.t23 [{%n2.fmap.t23}{%inL}]{%block}[{%n3.fmap.t23}{%inR}]{%block}{%if}
@t.fmap.t23 [{%inL}]{%block}[{%nn.fmap.t23}{%inR}]{%block}{%if}
@fmap.t23 [{%t.fmap.t23}]{%block}{%bind}{%fixpoint}{%inline}
@forCount.l.stopOnCount {%put}{%inL}{%discard2}
@forCount.l.action {%dec}{%put}{%x}{%unrot}{%put2}{%dip3}{%inline}
@forCount.l.onElem {%take}{%dup}#{%integer}{%.gt}[{%forCount.l.stopOnCount}]{%block}[{%forCount.l.action}]{%block}{%if_}
@forCount.l.stopOnEmpty {%inR}{%discard2}
@forCount.l.step {%take2}[{%forCount.l.onElem}]{%block}[{%forCount.l.stopOnEmpty}]{%block}{%if}
@forCount.l {%assertNatural}{%unrot}[{%forCount.l.step}]{%block}{%bind}{%fixpoint}{%inline}{%swap}
@foreach.l {%each.l}
@found.indexOf.l #1{%integer}{%unrot}{%swap}[{%cons.l}{%incd}]{%block}{%foreach.l}{%swap}{%inL}
@fromList.arity1.s vv{%fromList.s}cc
@fromN2d.t23 {%.rw}{%fromN2.t23}{%.wl}
@pwWrap.fromStateSplitNext.r r[{%preApply}]o[{%pw}{%postApply}]wol
@wrapNext.fromStateSplitNext.r {%pwWrap.fromStateSplitNext.r}
@wrapSplit.fromStateSplitNext.r {%pwWrap.fromStateSplitNext.r}
@fromStateSplitNext.r {%wrapNext.fromStateSplitNext.r}rw{%wrapSplit.fromStateSplitNext.r}wl{%.fromStateSplitNext.r}
@toList.arity1.s vv{%toList.s}cc
@fromStream.arity1.l {%toList.arity1.s}
@fullSwapEnv rvrwlcl
@grow.gt.n2.insertKV.t23 {%pw}{%pw}
@grow.gtk2.n3.insertKV.t23 {%fromN2.t23}{%pw}{%dpw}{%dpw}{%fromN2d.t23}{%pw}
@grow.lt.n2.insertKV.t23 {%l}{%x}{%dp}{%p}{%r}
@grow.ltk1.n3.insertKV.t23 {%fromN2.t23}{%swap}{%wx}{%fromN2.t23}{%pw}{%pw}
@grow.ltk2.n3.insertKV.t23 {%l}{%x}{%dp}{%swap}{%fromN2.t23}{%dwx}{%pw}{%dpw}{%dpw}{%fromN2d.t23}{%pw}
@gt.n2.insertKV.t23 {%wx}{%wx}{%hap}[{%pw}{%pw}{%fromN2.t23}]{%block}[{%grow.gt.n2.insertKV.t23}{%fromN3.t23}]{%block}{%if}
@gt1 {%.gt1}
@gtb {%.gtb}
@gte1 {%.gte1}
@gteb {%.gteb}
@ltk2.n3.insertKV.t23 {%x}{%hap}[{%p}{%pw}{%pw}{%fromN3.t23}{%inL}]{%block}[{%grow.ltk2.n3.insertKV.t23}{%inR}]{%block}{%if}
@gtk2.n3.insertKV.t23 {%wx}{%wx}{%hap}[{%pw}{%pw}{%pw}{%pw}{%fromN3.t23}{%inL}]{%block}[{%grow.gtk2.n3.insertKV.t23}{%inR}]{%block}{%if}
@neqk2.n3.insertKV.t23 [{%ltk2.n3.insertKV.t23}]{%block}[{%gtk2.n3.insertKV.t23}]{%block}{%if_}
@gtk1.n3.insertKV.t23 {%wx}{%wx}{%caadr}{%put}{%.apply}[{%drop}{%eqk2.n3.insertKV.t23}]{%block}[{%neqk2.n3.insertKV.t23}]{%block}{%if}
@hdip {%reifyHand}{%putd}{%dip}{%take}{%restoreHand}
@hdl {%hsw}{%dl}{%hsw}
@hdp {%hsw}{%dp}{%hsw}
@hdpw {%hsw}{%dpw}{%hsw}
@hdr {%hsw}{%dr}{%hsw}
@hdropd {%hsw}{%dropd}{%hsw}
@hdupd {%hsw}{%dupd}{%hsw}
@hdw {%hsw}{%dw}{%hsw}
@hdwx {%hsw}{%dwx}{%hsw}
@hdx {%hsw}{%dx}{%hsw}
@hfix.v1 {%put}[{%take}]{%block}{%composel}{%fixpoint}{%take}
@hfix.v2 {%put}r[^'ol{%take}]o^'ol{%take}
@hl {%hsw}{%l}{%hsw}
@hnip {%hsw}{%nip}{%hsw}
@hnip2 {%hsw}{%nip2}{%hsw}
@hover {%hsw}{%over}{%hsw}
@hp {%hsw}{%p}{%hsw}
@pick {%.rw}{%over}{%.wl}{%swap}
@hpick {%hsw}{%pick}{%hsw}
@hpw {%hsw}{%pw}{%hsw}
@hr {%hsw}{%r}{%hsw}
@hroll {%hsw}{%roll}{%hsw}
@hrot {%hsw}{%rot}{%hsw}
@hspin {%hsw}{%spin}{%hsw}
@hswapd {%hsw}{%swapd}{%hsw}
@htuck {%hsw}{%tuck}{%hsw}
@hunroll {%hsw}{%unroll}{%hsw}
@hunrot {%hsw}{%unrot}{%hsw}
@hw {%hsw}{%w}{%hsw}
@hwx {%hsw}{%wx}{%hsw}
@hx {%hsw}{%x}{%hsw}
@i.rt2t.AATree VVRRZLLCM
@ifd {%condSwap}{%drop}{%dip}
@ifk {%dupdd}{%eitherBind}{%merge}{%dip}
@inLL {%inL}{%inL}
@inLLL {%inLL}{%inL}
@inLLLL {%inLLL}{%inL}
@inLLLLL {%inLLLL}{%inL}
@inLR {%inR}{%inL}
@inLLR {%inLR}{%inL}
@inLLLR {%inLLR}{%inL}
@inLLLLR {%inLLLR}{%inL}
@inLRL {%inRL}{%inL}
@inLLRL {%inLRL}{%inL}
@inLLLRL {%inLLRL}{%inL}
@inLRR {%inRR}{%inL}
@inLLRR {%inLRR}{%inL}
@inLLLRR {%inLLRR}{%inL}
@inRLL {%inLL}{%inR}
@inLRLL {%inRLL}{%inL}
@inLLRLL {%inLRLL}{%inL}
@inRLR {%inLR}{%inR}
@inLRLR {%inRLR}{%inL}
@inLLRLR {%inLRLR}{%inL}
@inRRL {%inRL}{%inR}
@inLRRL {%inRRL}{%inL}
@inLLRRL {%inLRRL}{%inL}
@inRRR {%inRR}{%inR}
@inLRRR {%inRRR}{%inL}
@inLLRRR {%inLRRR}{%inL}
@inRLLL {%inLLL}{%inR}
@inLRLLL {%inRLLL}{%inL}
@inRLLR {%inLLR}{%inR}
@inLRLLR {%inRLLR}{%inL}
@inRLRL {%inLRL}{%inR}
@inLRLRL {%inRLRL}{%inL}
@inRLRR {%inLRR}{%inR}
@inLRLRR {%inRLRR}{%inL}
@inRRLL {%inRLL}{%inR}
@inLRRLL {%inRRLL}{%inL}
@inRRLR {%inRLR}{%inR}
@inLRRLR {%inRRLR}{%inL}
@inRRRL {%inRRL}{%inR}
@inLRRRL {%inRRRL}{%inL}
@inRRRR {%inRRR}{%inR}
@inLRRRR {%inRRRR}{%inL}
@inRLLLL {%inLLLL}{%inR}
@inRLLLR {%inLLLR}{%inR}
@inRLLRL {%inLLRL}{%inR}
@inRLLRR {%inLLRR}{%inR}
@inRLRLL {%inLRLL}{%inR}
@inRLRLR {%inLRLR}{%inR}
@inRLRRL {%inLRRL}{%inR}
@inRLRRR {%inLRRR}{%inR}
@inRRLLL {%inRLLL}{%inR}
@inRRLLR {%inRLLR}{%inR}
@inRRLRL {%inRLRL}{%inR}
@inRRLRR {%inRLRR}{%inR}
@inRRRLL {%inRRLL}{%inR}
@inRRRLR {%inRRLR}{%inR}
@inRRRRL {%inRRRL}{%inR}
@inRRRRR {%inRRRR}{%inR}
@inc.arity1 v#1+c
@lift.p0 {%.bsecond}{%.fixfirst}
@inc.p0 [{%inc.arity1}]{%block}{%lift.p0}
@notFound.indexOf.l {%swap}{%reverseAppend.l}{%intro1}{%inR}
@indexOf.l {%wrapObserver.b}{%breakRevP.l}{%swap}[{%inL}{%found.indexOf.l}]{%block}[{%inR}{%notFound.indexOf.l}]{%block}{%if}
@unseal.m r{.m}l
@unseald.m {%.rw}{%unseal.m}{%.wl}
@node.singleton.bst {%empty.bst}{%dup}{%pw}{%pw}
@raw.singleton.bst {%node.singleton.bst}{%inR}
@leaf.insertKV.bst {%discard2}{%inR}{%.rw}{%raw.singleton.bst}{%.wl}
@left.insertKV.bst {%swap}{%dwx}{%dx}{%swap}{%hap}{%dp}{%dpw}
@right.insertKV.bst {%swap}{%dwx}{%dwx}{%swap}{%hap}{%dpw}{%dpw}
@seek.insertKV.bst [{%left.insertKV.bst}]{%block}[{%right.insertKV.bst}]{%block}{%if_}
@node.insertKV.bst {%caar}{%put2nd}{%.apply}[{%drop}{%find.insertKV.bst}]{%block}[{%seek.insertKV.bst}]{%block}{%if}
@tree.insertKV.bst {%take2}{%unseal.bst}[{%leaf.insertKV.bst}]{%block}[{%node.insertKV.bst}{%inRd}]{%block}{%if}{%seald.bst}
@insertKV.bst {%bindK.insertKV.bst}{%swapd}[{%tree.insertKV.bst}]{%block}{%bind}{%fixpoint}{%inline}
@seald.m {%.rw}{%seal.m}{%.wl}
@insert.m {%unseald.m}{%dwx}{%swap}{%copy}[{%insertKV.bst}]{%block}{%apply3to2}{%putd}{%dpw}{%seald.m}
@insertK.m {%intro1}{%pw}{%insert.m}
@insertKV.AATree [{%apEnv.insertKV.AATree}]{%block}{%apply3to2}
@red.rbt {%intro1}{%inR}
@leaf.inx.z.rbt {%fromLeaf.rbt}{%dup}{%p}{%red.rbt}{%p}{%put}{%p}{%intro1}{%inR}{%take}
@node.inx.z.rbt {%put}{%wcar}{%inL}{%take}
@tree.inx.z.rbt {%unseal.rbt}[{%leaf.inx.z.rbt}]{%block}[{%node.inx.z.rbt}]{%block}{%if}{%fromNode.rbt}
@prc.inx.z.rbt {%take}{%x}{%tree.inx.z.rbt}{%p}{%exitrb.z.rbt}{%put}
@setcadr! {%wcadr}{%drop}
@n.paintItBlack.rbt {%black.rbt}{%setcadr!}
@r.paintItBlack.rbt [{%inL}]{%block}[{%n.paintItBlack.rbt}{%inR}]{%block}{%if}
@paintItBlack.rbt {%unseal.rbt}{%r.paintItBlack.rbt}{%seal.rbt}
@inx.z.rbt {%prc.inx.z.rbt}{%take}{%paintItBlack.rbt}{%put}
@insertKV.rbt {%bindK.insertKV.rbt}{%taked}{%wrapd.z.rbt}{%seek.z.rbt}{%put}{%inx.z.rbt}
@take2nd {%swap}{%take}
@unseal.t23 r{.t23}l
@leaf.insertKV.t23 {%discard2}{%put}{%empty.t23}{%dup}{%dpw}{%p}{%inR}{%swap}{%inR}{%take}
@lt.n2.insertKV.t23 {%x}{%hap}[{%p}{%fromN2.t23}]{%block}[{%grow.lt.n2.insertKV.t23}{%fromN3.t23}]{%block}{%if}
@neq.n2.insertKV.t23 [{%lt.n2.insertKV.t23}]{%block}[{%gt.n2.insertKV.t23}]{%block}{%if_}
@n2.insertKV.t23 {%caadr}{%put}{%.apply}[{%drop}{%eq.n2.insertKV.t23}]{%block}[{%neq.n2.insertKV.t23}]{%block}{%if}{%inL}
@ltk1.n3.insertKV.t23 {%x}{%discard}{%hap}[{%p}{%fromN3.t23}{%inL}]{%block}[{%grow.ltk1.n3.insertKV.t23}{%inR}]{%block}{%if}
@neqk1.n3.insertKV.t23 [{%ltk1.n3.insertKV.t23}]{%block}[{%gtk1.n3.insertKV.t23}]{%block}{%if_}
@n3.insertKV.t23 {%caadr}{%paste}{%.apply}[{%drop}{%eqk1.n3.insertKV.t23}]{%block}[{%neqk1.n3.insertKV.t23}]{%block}{%if}
@node.insertKV.t23 [{%n2.insertKV.t23}]{%block}[{%n3.insertKV.t23}]{%block}{%if}
@tree.insertKV.t23 {%swap}{%take2}{%unseal.t23}[{%leaf.insertKV.t23}]{%block}[{%node.insertKV.t23}]{%block}{%if}
@repairRoot.insertKV.t23 []{%block}[{%fromN2.t23}]{%block}{%if}
@insertKV.t23 {%bindK.insertKV.t23}{%take2nd}[{%tree.insertKV.t23}]{%block}{%bind}{%fixpoint}{%inline}{%repairRoot.insertKV.t23}{%put}
@insertK_.m {%insertK.m}{%drop}
@insert_.m {%insert.m}{%drop}
@juggle4 {%hsw}{%roll4}{%hsw}
@juggle5 {%hsw}{%roll5}{%hsw}
@juggle6 {%hsw}{%roll6}{%hsw}
@keep0 {%inline}
@keep1 {%keep}
@keep4 {%.rw}{%dup4}{%pw}{%pw}{%pw}{%.wl}{%dip}{%wx}{%wx}{%wx}
@keep5 {%.rw}{%dup5}{%pw}{%pw}{%pw}{%pw}{%.wl}{%dip}{%wx}{%wx}{%wx}{%wx}
@keep7 {%.rw}{%dup7}{%pw}{%pw}{%pw}{%pw}{%pw}{%pw}{%.wl}{%dip}{%wx}{%wx}{%wx}{%wx}{%wx}{%wx}
@keep8 {%.rw}{%dup8}{%pw}{%pw}{%pw}{%pw}{%pw}{%pw}{%pw}{%.wl}{%dip}{%wx}{%wx}{%wx}{%wx}{%wx}{%wx}{%wx}
@lastElem.zipRem.s {%empty.s}{%dup}{%pw}{%pw}{%inL}
@lazy r{&lazy}l
@leaf.removeK.t23 {%fromLeaf.t23}{%inL}{%intro1}{%inR}{%discard2}
@leaf.removeKV.bst {%discard2}{%inL}{%seal.bst}{%intro1}{%inR}
@leaf.toStreamL.bst {%elim1}{%discard}{%empty.s}
@leaf.toStreamR.bst {%elim1}{%discard}{%empty.s}
@step.left.p0 vrwrD[vr$c]?FMz'olc
@left.p0 [{%step.left.p0}]{%block}{%.fixfirst}{%.bind}
@left.removeKV.bst {%wx}{%x}{%hap}{%dp}{%dpw}
@toS.lefts.s [{%singleton.s}]{%block}[{%drop}{%empty.s}]{%block}{%if}
@lefts.s [{%toS.lefts.s}]{%block}{%map.s}{%flatten.s}
@lt1 {%.lt1}
@lte1 {%.lte1}
@lteb {%.lteb}
@map.p0 {%applyWrap}{%lift.p0}
@merged {%.rw}{%merge}{%.wl}
@mkCompareLists [{%compareLists}]{%block}{%bind}{%compareOnStackToRawCompare}
@mkCompareProds [{%compareProds}]{%block}{%bind2}{%compareOnStackToRawCompare}
@mkCompareStreams [{%compareStreams}]{%block}{%bind}{%compareOnStackToRawCompare}
@mkCompareSums [{%compareSums}]{%block}{%bind2}{%compareOnStackToRawCompare}
@mkCompareUnits [{%compareUnits}]{%block}
@mkSt.stdgen.r {%assertNatural}#2147483562{%integer}{%.divMod}#2147483398{%integer}{%.rem}{%incd}{%inc}{%pw}
@mul.arity2 vr*c
@mul2.arity1 v#2*c
@n*.swapL.t23 {%x}{%hap}{%dp}[{%wcadr}]{%block}[]{%block}{%if}{%inR}
@n.paintItRed.rbt {%red.rbt}{%setcadr!}
@t.size.AATree {%take}[{%put}{%inline}{%inLd}]{%block}[{%discard}{%inR}#{%integer}]{%block}{%if}
@rt.size.AATree {%take}[{%put}{%inline}{%inLd}]{%block}[{%put}{%t.size.AATree}{%inRd}]{%block}{%if}
@n.size.AATree {%take}{%wx}{%wx}{%paste}{%rt.size.AATree}{%rot}{%put}{%t.size.AATree}{%swapd}{%.add}{%inc}{%take}{%p}{%pw}{%put}
@n.size.bst {%wx}{%x}{%hapc}{%rot}{%hap}{%swapd}{%.add}{%inc}{%dpw}{%dpw}
@n.size.rbt {%wx}{%wx}{%x}{%hapc}{%rot}{%hap}{%swapd}{%.add}{%inc}{%dpw}{%dpw}{%dpw}
@when_ []{%block}{%swap}{%if_}
@next_s2.stdgen.r #52774{%integer}{%.divMod}#3791{%integer}{%.mul}rw#40692{%integer}{%.mul}wl{%.sub}{%dup}#{%integer}{%lt}[#2147483399{%integer}{%.add}]{%block}{%when_}
@new_s2.stdgen.r {%dec}{%dup}#1{%integer}{%lt}[{%drop}#2147483398{%integer}]{%block}{%when_}
@next_s1.stdgen.r #53668{%integer}{%.divMod}#12211{%integer}{%.mul}rw#40014{%integer}{%.mul}wl{%.sub}{%dup}#{%integer}{%lt}[#2147483563{%integer}{%.add}]{%block}{%when_}
@unless_ []{%block}{%if_}
@new_s1.stdgen.r {%inc}{%dup}#2147483563{%integer}{%lt}[{%drop}#1{%integer}]{%block}{%unless_}
@split.stdgen.r {%wx}[{%next_s2.stdgen.r}]{%block}[{%new_s2.stdgen.r}]{%block}{%bi}{%take2}[{%next_s1.stdgen.r}]{%block}[{%new_s1.stdgen.r}]{%block}{%bi}{%put}{%pw}{%swap}{%put}{%pw}
@next.stdgen.r {%wx}{%next_s2.stdgen.r}{%take}{%next_s1.stdgen.r}{%dup}{%paste}{%pw}{%swap}{%put}{%.sub}{%dup}#1{%integer}{%lt}[#2147483562{%integer}{%.add}]{%block}{%when_}
@n.stdgen.r {%mkSt.stdgen.r}[{%split.stdgen.r}]{%block}[{%next.stdgen.r}]{%block}{%fromStateSplitNext.r}
@rt2t.AATree r{%i.rt2t.AATree}l
@n.toStream.AATree {%preApply}{%x}{%take}{%wx}{%wx}{%rt2t.AATree}{%paste}{%.bind}{%unrot}{%put}{%.bind}{%unrot}{%cons.s}{%addend.s}{%postApply}
@n.toStreamR.AATree {%preApply}{%x}{%take}{%wx}{%wx}{%rt2t.AATree}{%paste}{%.bind}{%unrot}{%put}{%.bind}{%unrot}{%swapd}{%cons.s}{%addend.s}{%postApply}
@n2.removeK.t23 "TODO!t23
~{%literal}
@n2.swapL.t23 {%n*.swapL.t23}
@n3.removeK.t23 "TODO!t23
~{%literal}
@n3.swapL.t23 {%n*.swapL.t23}
@nand.b {%and.b}{%not.b}
@neg.arity1 v-c
@neq.old {%gt}[vr>c]{%block}{%.left}rRl
@new.stats #{%integer}#{%integer}#{%integer}{%pw}{%pw}{%seal.stats}
@next.r {%false.b}{%.applyd}{%x}
@nextWord.wordGenToBoolGen.r {%drop2}{%next.r}{%swap}#{%integer}
@next.wordGenToBoolGen.r {%take}{%wx}{%x}{%dup}{%put}{%lt}[{%nextWord.wordGenToBoolGen.r}]{%block}{%unless_}{%inc}{%swap}#2{%integer}{%.divMod}{%swap}#{%integer}{%gtb}{%take}{%pw}{%pw}{%put}
@nip4 {%.rw}{%drop4}{%.wl}
@noAB.zipRem.s {%drop2}{%intro1}{%inR}
@node.removeK.t23 [{%n2.removeK.t23}]{%block}[{%n3.removeK.t23}]{%block}{%if}
@right.removeKV.bst {%wx}{%wx}{%hap}{%dpw}{%dpw}
@seek.removeKV.bst [{%left.removeKV.bst}]{%block}[{%right.removeKV.bst}]{%block}{%if_}{%inRd}{%seald.bst}
@node.removeKV.bst {%caar}{%put2nd}{%.apply}[{%drop}{%find.removeKV.bst}]{%block}[{%seek.removeKV.bst}]{%block}{%if}
@node.seekLL.z.rbt {%nodeLeft.z.rbt}{%wx}{%consd.l}
@node.stepLeft.z.rbt {%nodeLeft.z.rbt}{%wx}{%swapd}{%cons.l}{%pw}
@node.stepRight.z.rbt {%nodeRight.z.rbt}{%wx}{%swapd}{%cons.l}{%pw}
@node.swapL.t23 [{%n2.swapL.t23}{%inLd}]{%block}[{%n3.swapL.t23}{%inRd}]{%block}{%if}
@node.toListL.bst {%wx}{%wx}{%rotd}{%hapc}{%rot}{%cons.l}{%swap}{%hap}
@node.toListR.bst {%wx}{%x}{%rotd}{%hapc}{%rot}{%cons.l}{%swap}{%hap}
@node.toStreamL.bst {%wx}{%x}{%paste}{%.bind}{%unrot}{%put}{%.bind}{%swap}{%cons.s}{%addend.s}
@node.toStreamR.bst {%wx}{%wx}{%paste}{%.bind}{%unrot}{%put}{%.bind}{%swap}{%cons.s}{%addend.s}
@wrapKeyObserver.b {%quote}[{%dupfst}{%swap}]{%block}{%composel}[{%dip}{%distrib}[c]{%block}{%.left}[c]{%block}{%.right}]{%block}{%compose}
@partitionByKey.l {%wrapKeyObserver.b}{%partitionWith.l}
@nonEmpty.sortByKey.l {%x}{%dupfst}{%swapd}{%put}{%bind}{%partitionByKey.l}{%swap}{%put}{%bidup}{%rot}{%cons.l}{%append.l}
@nubBy.l.action {%x}{%copy}{%rot}{%bind}{%partitionBy.l}{%drop}{%swap}{%apply}{%put}{%cons.l}
@nubBy.l.step {%rot}[{%nubBy.l.action}]{%block}[{%nip2}{%inR}]{%block}{%if}
@nubBy.l [{%nubBy.l.step}]{%block}{%bind}{%fixpoint}{%apply}
@true.b {%intro1}{%inR}
@null.l {%false.b}{%true.b}{%condSwap}{%drop}
@pushBit.wordToBitList r#2Q#>l{%toBoolean}rzwrzwlVlwl
@octetToBitList {%assertOctet}{%empty.l}{%swap}{%pushBit.wordToBitList}{%pushBit.wordToBitList}{%pushBit.wordToBitList}{%pushBit.wordToBitList}{%pushBit.wordToBitList}{%pushBit.wordToBitList}{%pushBit.wordToBitList}{%pushBit.wordToBitList}{%drop}
@octetStreamToBitStream [{%octetToBitList}{%fromList.s}]{%block}{%map.s}{%flatten.s}
@over2 {%roll2}{%dup}{%unroll2d}
@over3 {%roll3}{%dup}{%unroll3d}
@over4 {%roll4}{%dup}{%unroll4d}
@over5 {%roll5}{%dup}{%unroll5d}
@over6 {%roll6}{%dup}{%unroll6d}
@over7 {%roll7}{%dup}{%unroll7d}
@r.paintItRed.rbt [{%inL}]{%block}[{%n.paintItRed.rbt}{%inR}]{%block}{%if}
@paintItRed.rbt {%unseal.rbt}{%r.paintItRed.rbt}{%seal.rbt}
@pangram.1 "pack my box with five dozen liquor jugs
~{%literal}
@pangram.2 "a quick brown fox jumped over the lazy dog
~{%literal}
@partialFactor rFll{%x}
@partition.l {%partitionReverse.l}{%reverse.l}{%swap}{%reverse.l}{%swap}
@partitionElem.l [{%lte1}]{%block}{%bind}{%partitionWith.l}{%swap}
@paste2 {%hsw}{%copy2}{%hsw}
@paste3 {%hsw}{%copy3}{%hsw}
@paste4 {%hsw}{%copy4}{%hsw}
@paste5 {%hsw}{%copy5}{%hsw}
@paste6 {%hsw}{%copy6}{%hsw}
@paste7 {%hsw}{%copy7}{%hsw}
@pick1 {%dup}
@pick2 {%.rw}{%pick1}{%.wl}{%swap}
@pick3 {%.rw}{%pick2}{%.wl}{%swap}
@pick4 {%.rw}{%pick3}{%.wl}{%swap}
@pick5 {%.rw}{%pick4}{%.wl}{%swap}
@pick6 {%.rw}{%pick5}{%.wl}{%swap}
@pick7 {%.rw}{%pick6}{%.wl}{%swap}
@pmap.s [{%pmap.s.step}]{%block}{%.fixfirst}{%.bind}{%.bind}
@prc.rmx.z.rbt "todo: remove element red-black tree
~{%literal}
@prepose {%composel}
@put1st {%put}
@put3rd {%hrot}{%put}
@put4 {%put3}{%put}
@put4th {%hroll}{%put}
@put5 {%put4}{%put}
@put6 {%put5}{%put}
@put7 {%put6}{%put}
@putback.s {%cons.s}
@quot.arity2 vrwQ%c
@r.size.AATree [{%n.size.AATree}]{%block}{%fixpoint}{%t.size.AATree}
@ratio l
@rawCompareToCompareOnStack [{%dpw}{%.apply}]{%block}{%bind}
@rem.arity2 vrwQw%c
@tree.removeKV.bst {%take2}{%unseal.bst}[{%leaf.removeKV.bst}]{%block}[{%node.removeKV.bst}]{%block}{%if}
@removeKV.bst {%.bind}[{%tree.removeKV.bst}]{%block}{%bind}{%fixpoint}{%inline}
@remove.m {%unseald.m}{%dwx}{%swap}{%copy}[{%removeKV.bst}]{%block}{%apply3to2}{%putd}{%dpw}{%seald.m}
@rmx.z.rbt {%prc.rmx.z.rbt}{%take}{%paintItBlack.rbt}{%put}
@removeK.rbt {%.bind}{%wrapd.z.rbt}{%seek.z.rbt}{%rmx.z.rbt}
@tree.removeK.t23 {%swap}{%take2}{%unseal.t23}[{%leaf.removeK.t23}]{%block}[{%node.removeK.t23}]{%block}{%if}{%seal.t23}
@root.removeK.t23 {%.bind}[{%tree.removeK.t23}]{%block}{%bind}{%fixpoint}{%inline}{%put}
@removeK.t23 {%root.removeK.t23}{%take}{%merge}{%put}
@remove_.m {%remove.m}{%drop}
@rep0 {%drop}
@rep2 {%run1}{%inline}
@rep3 {%run2}{%inline}
@run4 {%run3}{%run}
@rep5 {%run4}{%inline}
@run5 {%run4}{%run}
@rep6 {%run5}{%inline}
@run6 {%run5}{%run}
@rep7 {%run6}{%inline}
@run7 {%run6}{%run}
@rep8 {%run7}{%inline}
@repeatP [{%repeat}]{%block}{%apply3to1}
@tryCond.repeatUntil {%dip3}{%roll}[{%body.repeatUntil}]{%block}[{%drop3}]{%block}{%if_}
@tryCount.repeatUntil {%over4}#{%integer}{%gt}[{%drop4}]{%block}[{%tryCond.repeatUntil}]{%block}{%if_}
@repeatUntil {%assertNatural}{%unrot}[{%tryCount.repeatUntil}]{%block}{%bind2}{%fixpoint}{%inline}
@repeatWhile {%swap}[{%not}]{%block}{%compose}{%swap}{%repeatUntil}
@step.right.p0 vrwrDVRW[vr$c]?WLCFMz'olc
@right.p0 [{%step.right.p0}]{%block}{%.fixfirst}{%.bind}
@rights.s [{%toS.rights.s}]{%block}{%map.s}{%flatten.s}
@rn.take.s {%inner.take.s}{%swapd}
@run8 {%run7}{%run}
@scan.l [{%map.l}]{%block}{%apply3to2}
@seal r{:s}l
@seald.t23 {%.rw}{%seal.t23}{%.wl}
@step.second.p0 vrwrwrwzw$rwzwlwz'olc
@second.p0 [{%step.second.p0}]{%block}{%.fixfirst}{%.bind}
@tree.seekLL.z.rbt {%unseal.rbt}[{%fromLeaf.rbt}]{%block}[{%node.seekLL.z.rbt}]{%block}{%if}
@seekLL.z.rbt {%x}[{%tree.seekLL.z.rbt}]{%block}{%take}{%hfix}{%hap}{%discard}{%p}
@setcaaaaar! {%wcaaaaar}{%drop}
@setcaaaadr! {%wcaaaadr}{%drop}
@setcaaaar! {%wcaaaar}{%drop}
@setcaaadar! {%wcaaadar}{%drop}
@setcaaaddr! {%wcaaaddr}{%drop}
@setcaaadr! {%wcaaadr}{%drop}
@setcaaar! {%wcaaar}{%drop}
@setcaadaar! {%wcaadaar}{%drop}
@setcaadadr! {%wcaadadr}{%drop}
@setcaadar! {%wcaadar}{%drop}
@setcaaddar! {%wcaaddar}{%drop}
@setcaadddr! {%wcaadddr}{%drop}
@setcaaddr! {%wcaaddr}{%drop}
@setcaadr! {%wcaadr}{%drop}
@setcaar! {%wcaar}{%drop}
@setcadaaar! {%wcadaaar}{%drop}
@setcadaadr! {%wcadaadr}{%drop}
@setcadaar! {%wcadaar}{%drop}
@setcadadar! {%wcadadar}{%drop}
@setcadaddr! {%wcadaddr}{%drop}
@setcadadr! {%wcadadr}{%drop}
@setcadar! {%wcadar}{%drop}
@setcaddaar! {%wcaddaar}{%drop}
@setcaddadr! {%wcaddadr}{%drop}
@setcaddar! {%wcaddar}{%drop}
@setcadddar! {%wcadddar}{%drop}
@setcaddddr! {%wcaddddr}{%drop}
@setcadddr! {%wcadddr}{%drop}
@setcaddr! {%wcaddr}{%drop}
@setcar! {%wcar}{%drop}
@setcdaaaar! {%wcdaaaar}{%drop}
@setcdaaadr! {%wcdaaadr}{%drop}
@setcdaaar! {%wcdaaar}{%drop}
@setcdaadar! {%wcdaadar}{%drop}
@setcdaaddr! {%wcdaaddr}{%drop}
@setcdaadr! {%wcdaadr}{%drop}
@setcdaar! {%wcdaar}{%drop}
@setcdadaar! {%wcdadaar}{%drop}
@setcdadadr! {%wcdadadr}{%drop}
@setcdadar! {%wcdadar}{%drop}
@setcdaddar! {%wcdaddar}{%drop}
@setcdadddr! {%wcdadddr}{%drop}
@setcdaddr! {%wcdaddr}{%drop}
@setcdadr! {%wcdadr}{%drop}
@setcdar! {%wcdar}{%drop}
@setcddaaar! {%wcddaaar}{%drop}
@setcddaadr! {%wcddaadr}{%drop}
@setcddaar! {%wcddaar}{%drop}
@setcddadar! {%wcddadar}{%drop}
@setcddaddr! {%wcddaddr}{%drop}
@setcddadr! {%wcddadr}{%drop}
@setcddar! {%wcddar}{%drop}
@setcdddaar! {%wcdddaar}{%drop}
@setcdddadr! {%wcdddadr}{%drop}
@setcdddar! {%wcdddar}{%drop}
@setcddddar! {%wcddddar}{%drop}
@setcdddddr! {%wcdddddr}{%drop}
@setcddddr! {%wcddddr}{%drop}
@setcdddr! {%wcdddr}{%drop}
@setcddr! {%wcddr}{%drop}
@setcdr! {%wcdr}{%drop}
@singleton.bst {%raw.singleton.bst}{%seal.bst}
@singleton.rbt {%black.rbt}{%empty.rbt}{%dup}{%pw}{%pw}{%pw}{%fromNode.rbt}
@singleton.t23 {%empty.t23}{%dup}{%dpw}{%p}{%fromN2.t23}
@size.AATree [{%r.size.AATree}]{%block}{%apply1to2}
@t.size.bst {%unseal.bst}[{%inL}#{%integer}{%discard}]{%block}[{%n.size.bst}{%inRd}]{%block}{%if}{%seald.bst}
@size.bst [{%t.size.bst}]{%block}{%take}{%hfix}{%hap}
@size.m {%unseal.m}{%x}[{%size.bst}]{%block}{%apply1to2}{%dp}{%seald.m}
@t.size.rbt {%unseal.rbt}[{%inL}#{%integer}{%discard}]{%block}[{%n.size.rbt}{%inRd}]{%block}{%if}{%seald.rbt}
@size.rbt [{%t.size.rbt}]{%block}{%take}{%hfix}{%hap}
@step.sortByKey.l {%swap}{%take2}[{%nonEmpty.sortByKey.l}]{%block}[{%inR}{%discard2}]{%block}{%if}
@sortByKey.l [{%step.sortByKey.l}]{%block}{%bind}{%fixpoint}{%apply}
@split.r {%true.b}{%.applyd}{%x}
@split.wordGenToBoolGen.r {%take}{%x}{%split.r}{%take}{%p}{%put}{%put}#{%integer}{%pw}{%pw}
@square.arity1 v^*c
@static r{&static}l
@wordGenToBoolGen.r {%assertNatural+}{%copy}#{%integer}{%pw}{%pw}{%paste}[{%split.wordGenToBoolGen.r}]{%block}{%bind}{%put}[{%next.wordGenToBoolGen.r}]{%block}{%bind}{%fromStateSplitNext.r}
@stdgen.r {%n.stdgen.r}#23{%integer}{%wordGenToBoolGen.r}
@step.p0 {%.apply}{%x}
@stepLeft.z.rbt {%x}{%unseal.rbt}[{%fromLeaf.rbt}{%p}]{%block}[{%node.stepLeft.z.rbt}]{%block}{%if}
@stepRight.z.rbt {%x}{%unseal.rbt}[{%fromLeaf.rbt}{%p}]{%block}[{%node.stepRight.z.rbt}]{%block}{%if}
@stepUp.z.rbt {%x}{%take}[{%x}{%exit.z.rbt.step}]{%block}[{%inR}]{%block}{%if}{%put}{%p}
@sto.fixpoint.v1 r'[^'ow^'zozlwvr$c]^'owol
@sto.fixpoint {%sto.fixpoint.v1}
@sto.fixpoint.v0 [{%dupd}{%bind}{%swap}{%inline}]{%block}{%fixpoint.v2}{%bind}
@sto.fixpoint.v2 r'[[^'ow^'zozlwvr$c]^'ow^'zozlwvr$c]wol
@sub.arity2 vrw-+c
@sumsq.stats {%unseal.stats}{%wx}{%wx}{%copy}{%pw}{%pw}{%seal.stats}{%put}
@swap2 {%p}{%dp}{%swap}{%dx}{%x}
@swap3 {%p}{%p}{%dp}{%dp}{%swap}{%dx}{%dx}{%x}{%x}
@swap4 {%p}{%p}{%p}{%dp}{%dp}{%dp}{%swap}{%dx}{%dx}{%dx}{%x}{%x}{%x}
@swapHands rwzwl
@tree.swapL.t23 {%unseal.t23}[{%inL}{%discard}{%put}{%inL}]{%block}[{%node.swapL.t23}{%inRd}]{%block}{%if}{%seald.t23}
@swapL.t23 {%take}[{%tree.swapL.t23}]{%block}{%take}{%hfix}{%hap}
@t.toStream.AATree D[{%n.toStream.AATree}{%.app1}]?VRW[%{%.inR}]?WLCMc
@t.toStreamR.AATree D[{%n.toStreamR.AATree}{%.app1}]?VRW[%{%.inR}]?WLCMc
@take.l {%split.l}{%dropd}
@take1.s {%intro1}{%.applyd}[{%x}{%inL}]{%block}[{%.rw}{%empty.s}{%.wl}{%inR}]{%block}{%if}
@take1st {%take}
@take3rd {%rot}{%take}
@take4th {%roll}{%take}
@undo.takeExact.s {%swap}[{%cons.s}]{%block}{%each.l}{%empty.l}{%swap}
@takeExact.s {%empty.l}{%unrot}[{%cons.l}]{%block}{%swap}{%forCount.s}#{%integer}{%gt}[{%undo.takeExact.s}]{%block}{%when_}{%swap}{%reverse.l}
@test..bfirst {%intro1}{%intro1}#7{%integer}{%p}{%p}[#6*]{%block}{%.bfirst}{%.apply}{%x}{%x}#42{%integer}{%assertEQ}{%drop2}{%elim1}{%elim1}
@test..bi #5{%integer}#7{%integer}[{%mul2.arity1}]{%block}{%.bi}#14{%integer}{%assertEQ1.n}#10{%integer}{%assertEQ1d.n}
@test..bidup #3{%integer}#4{%integer}[{%inc.arity1}]{%block}{%.bidup}#4{%integer}{%assertEQ1d.n}#5{%integer}{%assertEQ1.n}
@test..bleft.inL {%intro1}#7{%integer}{%p}{%inL}[#6*]{%block}{%.bleft}{%.apply}{%not}{%assert}{%x}#42{%integer}{%assertEQ}{%drop2}{%elim1}
@test..bleft.inR {%intro1}#7{%integer}{%p}{%inR}[#6*]{%block}{%.bleft}{%.apply}{%assert}{%x}#7{%integer}{%assertEQ}{%drop2}{%elim1}
@test..bright.inL {%intro1}#7{%integer}{%p}{%inL}[#6*]{%block}{%.bright}{%.apply}{%not}{%assert}{%x}#7{%integer}{%assertEQ}{%drop2}{%elim1}
@test..bright.inR {%intro1}#7{%integer}{%p}{%inR}[#6*]{%block}{%.bright}{%.apply}{%assert}{%x}#42{%integer}{%assertEQ}{%drop2}{%elim1}
@test..bsecond {%intro1}{%intro1}#7{%integer}{%p}{%pw}[#6*]{%block}{%.bsecond}{%.apply}{%wx}{%x}#42{%integer}{%assertEQ}{%drop2}{%elim1}{%elim1}
@test..tri #5{%integer}#6{%integer}#7{%integer}[{%mul2.arity1}]{%block}{%.tri}#14{%integer}{%assertEQ1.n}#12{%integer}{%assertEQ1d.n}#10{%integer}{%assertEQ1dd.n}
@test..tridup #2{%integer}#3{%integer}#4{%integer}[{%mul2.arity1}]{%block}{%.tridup}#4{%integer}{%assertEQ1dd.n}#6{%integer}{%assertEQ1d.n}#8{%integer}{%assertEQ1.n}
@test.abs.arity1 #3-{%integer}[{%abs.arity1}]{%block}{%.apply}#3{%integer}{%assertEQ1}
@test.add.arity2 #6{%integer}#7{%integer}{%pw}[{%add.arity2}]{%block}{%.apply}#13{%integer}{%assertEQ}
@test.addend.s "hello,
~{%literal}" world!
~{%literal}[{%fromList.s}]{%block}{%bidup}{%addend.s}{%toList.s}"hello, world!
~{%literal}{%assertTextEQ1}
@test.addend.s.empty {%empty.s}{%empty.s}{%addend.s}{%intro1}{%.applyd}{%assertInR}{%elim1}
@test.alignToFrac #1{%integer}#3{%integer}{%ratio}#1{%integer}#2{%integer}{%decimal}{%alignToFrac}#33{%integer}#2{%integer}{%decimal}{%assertEQ1.n}#2{%integer}#3{%integer}{%ratio}#1{%integer}#2{%integer}{%decimal}{%alignToFrac}#66{%integer}#2{%integer}{%decimal}{%assertEQ1.n}#227{%integer}#10{%integer}{%alignToFrac}#220{%integer}{%assertEQ1.n}
@test.and.b {%false.b}{%false.b}{%and.b}{%false.b}{%assertEQ1}{%false.b}{%true.b}{%and.b}{%false.b}{%assertEQ1}{%true.b}{%true.b}{%and.b}{%true.b}{%assertEQ1}{%true.b}{%false.b}{%and.b}{%false.b}{%assertEQ1}
@test.append.l "hello, 
~{%literal}"World!
~{%literal}{%append.l}"hello, World!
~{%literal}{%assertTextEQ1}
@test.apply4to2 #2{%integer}#3{%integer}#4{%integer}#5{%integer}[{%.add}{%unrot}{%.add}]{%block}{%apply4to2}#5{%integer}{%assertEQ1.n}{%swap}#9{%integer}{%assertEQ1.n}
@test.apply4to2d [{%.add}{%.mul}{%.add}#42{%integer}]{%block}#2{%integer}#3{%integer}#4{%integer}#5{%integer}{%apply4to2d}#42{%integer}{%assertEQ1.n}#29{%integer}{%assertEQ1d.n}
@test.bi #6{%integer}[#5{%integer}{%.add}]{%block}[#7{%integer}{%.mul}]{%block}{%bi}#42{%integer}{%assertEQ1}{%swap}#11{%integer}{%assertEQ1}{%swap}
@test.bi2 #6{%integer}#7{%integer}[{%.add}]{%block}[{%.mul}]{%block}{%bi2}#42{%integer}{%assertEQ1}{%swap}#13{%integer}{%assertEQ1}{%swap}
@test.bidup #4{%integer}#7{%integer}[#6{%integer}{%.mul}]{%block}{%bidup}#42{%integer}{%assertEQ1}{%swap}#24{%integer}{%assertEQ1}{%swap}
@test.bitStreamToOctetStream "pack my box with five dozen liquor jugs
~{%literal}{%dup}{%fromList.s}{%octetStreamToBitStream}{%bitStreamToOctetStream}{%fromStream.l}{%assertTextEQ1}
@test.compose.p0 #{%integer}[{%inc}]{%block}{%map.p0}[{%mul2}]{%block}{%map.p0}{%compose.p0}{%step.p0}{%step.p0}{%step.p0}{%step.p0}#30{%integer}{%assertEQ1d.n}{%step.p0}{%step.p0}{%step.p0}{%step.p0}#510{%integer}{%assertEQ1d.n}
@test.constant.s #111{%integer}{%constant.s}{%copy}#4{%integer}{%take.s}"oooo
~{%literal}{%assertTextEQ1}{%put}{%assertEQ1d}
@test.copy.l "hello world!
~{%literal}#5{%integer}{%copy.l}"hello
~{%literal}{%assertTextEQ1}{%swap}"hello world!
~{%literal}{%assertTextEQ1}{%swap}
@test.count.p0 #{%integer}#11{%integer}{%countFrom.p0}[{%step.p0}]{%block}#7{%integer}{%repeat}#17{%integer}{%assertEQ1d.n}
@test.drop.l "hello world!
~{%literal}#6{%integer}{%drop.l}"world!
~{%literal}{%assertTextEQ1}
@test.each.l #{%integer}"World
~{%literal}[{%.add}]{%block}{%fold.l}#520{%integer}{%assertEQ1}
@test.eachUntil.l.haltOnCond #{%integer}"hello, world!
~{%literal}[{%.add}]{%block}[{%dup}#600{%integer}{%gtb}]{%block}{%eachUntil.l}"world!
~{%literal}{%assertTextEQ1}{%swap}#608{%integer}{%assertEQ1}
@test.eachUntil.l.haltOnLength #{%integer}"hello, world!
~{%literal}[{%.add}]{%block}[{%dup}#1200{%integer}{%gtb}]{%block}{%eachUntil.l}{%empty.l}{%assertTextEQ1}{%swap}#1193{%integer}{%assertEQ1}{%swap}
@test.enum.s #{%integer}{%enum.s}[{%.add}]{%block}#20{%integer}{%forCount.s}{%drop2}#210{%integer}{%assertEQ1.n}
@test.enumFrom.s #97{%integer}{%enumFrom.s}#26{%integer}{%take.s}"abcdefghijklmnopqrstuvwxyz
~{%literal}{%assertTextEQ1}
@test.factorial.fixpoint #6{%integer}{%factorial.fixpoint}#720{%integer}{%assertEQ}
@test.fibonacci #11{%integer}{%fibonacci}#89{%integer}{%assertEQ1.n}
@test.filterBy.s "Hello, World!
~{%literal}{%fromList.s}[#108{%integer}{%.ltb}]{%block}{%filterBy.s}{%toList.s}"He, Wd!
~{%literal}{%assertTextEQ1}
@test.filterWith.s "Hello, World!
~{%literal}{%fromList.s}[#108{%integer}{%.gte1}]{%block}{%filterWith.s}{%toList.s}"lloorl
~{%literal}{%assertTextEQ1}
@test.first.p0 #{%integer}#{%integer}{%p}{%inc.p0}{%first.p0}{%step.p0}{%step.p0}{%step.p0}{%step.p0}{%swap}{%x}#4{%integer}{%assertEQ1.n}#{%integer}{%assertEQ1d.n}
@test.flatten.s {%empty.l}"
~{%literal}{%cons.l}"!
~{%literal}{%cons.l}"
~{%literal}{%cons.l}"
~{%literal}{%cons.l}"world
~{%literal}{%cons.l}", 
~{%literal}{%cons.l}"hello
~{%literal}{%cons.l}[{%fromList.s}]{%block}{%map.l}{%fromList.s}{%flatten.s}{%toList.s}"hello, world!
~{%literal}{%assertTextEQ1}
@test.fmap.s "hello
~{%literal}{%fromList.s}#4{%integer}[{%add.arity2}]{%block}{%.bind}{%fmap.s}{%toList.s}"lipps
~{%literal}{%assertEQ1}
@test.forCount.l.stopOnCount {%empty.l}"hello world
~{%literal}[{%cons.l}]{%block}#5{%integer}{%forCount.l}#{%integer}{%assertEQ1.n}{%drop}" world
~{%literal}{%assertEQ1}"olleh
~{%literal}{%assertEQ1d}
@test.forCount.l.stopOnEmpty {%empty.l}"hello world
~{%literal}[{%cons.l}]{%block}#15{%integer}{%forCount.l}#4{%integer}{%assertEQ1.n}{%drop}{%assertInR}{%elim1}"dlrow olleh
~{%literal}{%assertEQ1}
@test.forCount.s.stopOnCount {%empty.l}"hello world
~{%literal}{%fromList.s}[{%cons.l}]{%block}#4{%integer}{%forCount.s}#{%integer}{%assertEQ1.n}"o world
~{%literal}{%fromList.s}{%assertEQ1d}"lleh
~{%literal}{%assertEQ1dd}
@test.forCount.s.stopOnElem {%empty.l}"hello world
~{%literal}{%fromList.s}[{%cons.l}]{%block}#15{%integer}{%forCount.s}#4{%integer}{%assertEQ1.n}{%empty.s}{%assertEQ1d}"dlrow olleh
~{%literal}{%assertEQ1dd}
@test.foreach.s "hello, world!
~{%literal}{%fromList.s}#{%integer}[{%.add}]{%block}{%swapd}{%foreach.s}#1193{%integer}{%assertEQ1.n}
@test.fromStateSplitNext.r.next #{%integer}[{%dup}]{%block}[{%inc}{%dup}]{%block}{%fromStateSplitNext.r}{%next.r}{%next.r}{%next.r}{%next.r}#4{%integer}{%assertEQ1d.n}
@test.gratuitousDeepShuffle #5{%integer}#6{%integer}{%pw}{%dup}{%vrwlc__}{%w}{%assertEQ1}
@test.gratuitousDeeperShuffle #4{%integer}#5{%integer}#6{%integer}{%pw}{%p}{%dup}{%vrwlc___}{%x}{%w}{%p}{%assertEQ1}
@test.gt #12{%integer}#11{%integer}{%.gt}{%assert}
@test.gt.sort.a #5{%integer}#3{%integer}{%.gt}{%merge}{%x}#3{%integer}{%assertEQ1.n}#5{%integer}{%assertEQ1d.n}
@test.gt.sort.b #3{%integer}#5{%integer}{%.gt}{%merge}{%x}#3{%integer}{%assertEQ1.n}#5{%integer}{%assertEQ1d.n}
@test.gte.e #12{%integer}#12{%integer}{%.gte}{%assert}
@test.gte.g #12{%integer}#11{%integer}{%.gte}{%assert}
@test.if #3{%integer}{%inL}[{%inc}]{%block}[{%mul2}]{%block}{%if}#4{%integer}{%assertEQ1.n}#3{%integer}{%inR}[{%inc}]{%block}[{%mul2}]{%block}{%if}#6{%integer}{%assertEQ1.n}
@test.if_ #3{%integer}{%false.b}[{%inc}]{%block}[{%mul2}]{%block}{%if_}#4{%integer}{%assertEQ1.n}#3{%integer}{%true.b}[{%inc}]{%block}[{%mul2}]{%block}{%if_}#6{%integer}{%assertEQ1.n}
@test.ifd #3{%integer}{%false.b}[{%inc}]{%block}[{%mul2}]{%block}{%ifd}{%false.b}{%assertEQ1}#4{%integer}{%assertEQ1d.n}#3{%integer}{%true.b}[{%inc}]{%block}[{%mul2}]{%block}{%ifd}{%true.b}{%assertEQ1}#6{%integer}{%assertEQ1d.n}
@test.ifk #3{%integer}{%inL}[{%inc}]{%block}[{%mul2}]{%block}{%ifk}#3{%integer}{%inL}{%assertEQ1}#4{%integer}{%assertEQ1d.n}#3{%integer}{%inR}[{%inc}]{%block}[{%mul2}]{%block}{%ifk}#3{%integer}{%inR}{%assertEQ1}#6{%integer}{%assertEQ1d.n}
@test.inc.p0 #11{%integer}{%inc.p0}[{%step.p0}]{%block}#16{%integer}{%repeat}{%swap}#27{%integer}{%assertEQ}
@test.left.p0.inL #{%integer}{%inL}{%inc.p0}{%left.p0}{%step.p0}{%step.p0}{%step.p0}{%step.p0}{%swap}{%assertInL}#4{%integer}{%assertEQ1.n}
@test.left.p0.inR #{%integer}{%inR}{%inc.p0}{%left.p0}{%step.p0}{%step.p0}{%step.p0}{%step.p0}{%swap}{%assertInR}#{%integer}{%assertEQ1.n}
@test.lefts.s "Hello, World!
~{%literal}{%fromList.s}[#108{%integer}{%.lt1}]{%block}{%map.s}{%lefts.s}{%toList.s}"lloorl
~{%literal}{%assertTextEQ1}
@test.length.l "hello
~{%literal}{%length.l}#5{%integer}{%assertEQ1}{%swap}"hello
~{%literal}{%assertTextEQ1}{%swap}
@test.lt #11{%integer}#12{%integer}{%.lt}{%assert}
@test.lte.e #11{%integer}#11{%integer}{%.lte}{%assert}
@test.lte.l #11{%integer}#12{%integer}{%.lte}{%assert}
@test.map.l "hello
~{%literal}[#4{%integer}{%.add}]{%block}{%mapP.l}"lipps
~{%literal}{%assertTextEQ1}
@test.math.abs #3{%integer}{%.abs}#3{%integer}{%assertEQ1}#{%integer}{%.abs}#{%integer}{%assertEQ1}#3-{%integer}{%.abs}#3{%integer}{%assertEQ1}
@test.math.add #6{%integer}#7{%integer}{%.add}#13{%integer}{%assertEQ}
@test.math.div #42{%integer}#6{%integer}{%.div}#7{%integer}{%assertEQ}
@test.math.divFrac #42{%integer}#9{%integer}{%.div}#14{%integer}#3{%integer}{%ratio}{%assertEQ}
@test.math.mul #6{%integer}#7{%integer}{%.mul}#42{%integer}{%assertEQ}
@test.math.quotient #11{%integer}#3{%integer}{%.quot}#3{%integer}{%assertEQ}
@test.math.remainder #11{%integer}#3{%integer}{%.rem}#2{%integer}{%assertEQ}
@test.math.remainderFrac #10{%integer}#4{%integer}#3{%integer}{%ratio}{%.rem}#2{%integer}#3{%integer}{%ratio}{%assertEQ}
@test.math.square #7{%integer}{%.square}#49{%integer}{%assertEQ}
@test.math.sub #13{%integer}#6{%integer}{%.sub}#7{%integer}{%assertEQ}
@test.mul.arity2 #6{%integer}#7{%integer}{%pw}[{%mul.arity2}]{%block}{%.apply}#42{%integer}{%assertEQ}
@test.neg.arity1 #7{%integer}[{%neg.arity1}]{%block}{%.apply}#7-{%integer}{%assertEQ}
@test.not.b {%false.b}{%not.b}{%true.b}{%assertEQ1}{%true.b}{%not.b}{%false.b}{%assertEQ1}
@test.nub.l "hello, world!
~{%literal}{%nub.l}"helo, wrd!
~{%literal}{%assertTextEQ1}
@test.nubAndSort.l.pangram "pack my box with five dozen liquor jugs
~{%literal}{%nub.l}[{%ltb}]{%block}{%sortBy.l}" abcdefghijklmnopqrstuvwxyz
~{%literal}{%assertTextEQ1}
@test.nubBy.l "hello, world!
~{%literal}[{%eqb}]{%block}{%nubBy.l}"helo, wrd!
~{%literal}{%assertTextEQ1}
@test.octetStreamToBitStream "woman
~{%literal}{%dup}{%fromList.s}{%octetStreamToBitStream}{%bitStreamToText}{%fromStream.l}"0111011101101111011011010110000101101110
~{%literal}{%assertTextEQ1}
@wordToBitList {%.rw}{%assertNatural}{%empty.l}{%swap}[{%pushBit.wordToBitList}]{%block}{%.wl}{%repeat}{%assertEQz}{%drop}
@test.octetToBitList "Pack my box with five dozen liquor jugs.
~{%literal}{%copy}[[#8{%integer}{%wordToBitList}]{%block}{%map.l}]{%block}[[{%octetToBitList}]{%block}{%map.l}]{%block}{%bi}{%assertEQ1}[{%bitListToWord}]{%block}{%map.l}{%put}{%assertEQ1}
@test.or.b {%false.b}{%false.b}{%or.b}{%false.b}{%assertEQ1}{%false.b}{%true.b}{%or.b}{%true.b}{%assertEQ1}{%true.b}{%true.b}{%or.b}{%true.b}{%assertEQ1}{%true.b}{%false.b}{%or.b}{%true.b}{%assertEQ1}
@test.partition.l "hello, World!
~{%literal}[#106{%integer}{%gt1}]{%block}{%partitionWith.l}"lloorl
~{%literal}{%assertTextEQ1}
@test.quot.arity2 #11{%integer}#3{%integer}{%pw}[{%quot.arity2}]{%block}{%.apply}#3{%integer}{%assertEQ1}#11{%integer}#2{%integer}#3{%integer}{%ratio}{%pw}[{%quot.arity2}]{%block}{%.apply}#16{%integer}{%assertEQ1}#11{%integer}#2-{%integer}#3{%integer}{%ratio}{%pw}[{%quot.arity2}]{%block}{%.apply}#17-{%integer}{%assertEQ1}
@test.quote #7{%integer}{%dup}{%quote}{%unquote}{%assertEQ1}
@test.rem.arity2 #11{%integer}#3{%integer}{%pw}[{%rem.arity2}]{%block}{%.apply}#2{%integer}{%assertEQ1}#11{%integer}#2{%integer}#3{%integer}{%ratio}{%pw}[{%rem.arity2}]{%block}{%.apply}#1{%integer}#3{%integer}{%ratio}{%assertEQ1}#11{%integer}#2-{%integer}#3{%integer}{%ratio}{%pw}[{%rem.arity2}]{%block}{%.apply}#1-{%integer}#3{%integer}{%ratio}{%assertEQ1}
@test.remove.l "hello world
~{%literal}#108{%integer}{%remove.l}"heo word
~{%literal}{%assertTextEQ1}
@test.repeat #4{%integer}[{%inc}]{%block}#3{%integer}{%repeatP}#7{%integer}{%assertEQ.n}
@test.repeatWhile.haltOnCond {%new.stats}[#1{%integer}{%add.stats}]{%block}[{%count.stats}#15{%integer}{%lte}]{%block}#20{%integer}{%repeatWhile}{%count.stats}#16{%integer}{%assertEQ1.n}
@test.repeatWhile.haltOnCount {%new.stats}[#1{%integer}{%add.stats}]{%block}[{%count.stats}#15{%integer}{%lte}]{%block}#10{%integer}{%repeatWhile}{%count.stats}#10{%integer}{%assertEQ1.n}
@test.reverse.l "hello, World!
~{%literal}{%reverse.l}"!dlroW ,olleh
~{%literal}{%assertTextEQ1}
@test.reverseAppend.l " World!
~{%literal}",olleh
~{%literal}{%reverseAppend.l}"hello, World!
~{%literal}{%assertTextEQ1}
@test.right.p0.inL #{%integer}{%inL}{%inc.p0}{%right.p0}{%step.p0}{%step.p0}{%step.p0}{%step.p0}{%swap}{%assertInL}#{%integer}{%assertEQ1.n}
@test.right.p0.inR #{%integer}{%inR}{%inc.p0}{%right.p0}{%step.p0}{%step.p0}{%step.p0}{%step.p0}{%swap}{%assertInR}#4{%integer}{%assertEQ1.n}
@test.rights.s "Hello, World!
~{%literal}{%fromList.s}[#108{%integer}{%.lt1}]{%block}{%map.s}{%rights.s}{%toList.s}"He, Wd!
~{%literal}{%assertTextEQ1}
@test.roll7 #1{%integer}#2{%integer}#3{%integer}#4{%integer}#5{%integer}#6{%integer}#7{%integer}{%roll7}#1{%integer}{%assertEQ1}{%drop}#7{%integer}{%assertEQ1}{%drop}#6{%integer}{%assertEQ1}{%drop5}
@test.roundToFrac #1{%integer}#3{%integer}{%ratio}#1{%integer}#2{%integer}{%decimal}{%roundToFrac}#33{%integer}#2{%integer}{%decimal}{%assertEQ1.n}#2{%integer}#3{%integer}{%ratio}#1{%integer}#2{%integer}{%decimal}{%roundToFrac}#67{%integer}#2{%integer}{%decimal}{%assertEQ1.n}#227{%integer}#10{%integer}{%roundToFrac}#230{%integer}{%assertEQ1.n}
@test.scan.l #{%integer}"hello
~{%literal}[{%dup}{%rot}{%.add}{%swap}#4{%integer}{%.add}]{%block}{%scan.l}"lipps
~{%literal}{%assertTextEQ1}{%swap}#532{%integer}{%assertEQ1}{%swap}
@test.second.p0 #{%integer}#{%integer}{%p}{%inc.p0}{%second.p0}{%step.p0}{%step.p0}{%step.p0}{%step.p0}{%swap}{%x}#{%integer}{%assertEQ1.n}#4{%integer}{%assertEQ1d.n}
@test.sortBy.l "hello, World!
~{%literal}[{%ltb}]{%block}{%sortBy.l}" !,Wdehllloor
~{%literal}{%assertTextEQ1}{%dup}{%reverse.l}{%swap}[{%gtb}]{%block}{%sortBy.l}{%assertTextEQ1}
@test.sortByKey.l "acebdf
~{%literal}"gikhjl
~{%literal}{%zip.l}[{%ltb}]{%block}{%sortByKey.l}{%unzip.l}"abcdef
~{%literal}{%assertTextEQ1d}"ghijkl
~{%literal}{%assertTextEQ1}
@test.span.l.cut "hello, world!
~{%literal}[#32{%integer}{%neqb}]{%block}{%span.l}" world!
~{%literal}{%assertTextEQ1d}"hello,
~{%literal}{%assertTextEQ1}
@test.span.l.empty "hello, world!
~{%literal}[{%drop}{%false.b}]{%block}{%span.l}"hello, world!
~{%literal}{%assertTextEQ1d}{%empty.l}{%assertTextEQ1}
@test.span.l.full "hello, world!
~{%literal}[{%drop}{%true.b}]{%block}{%span.l}{%empty.l}{%assertTextEQ1d}"hello, world!
~{%literal}{%assertTextEQ1}
@test.square.arity1 #9{%integer}[{%square.arity1}]{%block}{%.apply}#81{%integer}{%assertEQ1}
@test.stats {%new.stats}[{%add.stats}]{%block}#1{%integer}#10{%integer}{%enumFromTo}{%count.stats}#10{%integer}{%assertEQ1}{%drop}{%sum.stats}#55{%integer}{%assertEQ1}{%drop}{%sumsq.stats}#385{%integer}{%assertEQ1}{%drop}
@test.sub.arity2 #13{%integer}#6{%integer}{%pw}[{%sub.arity2}]{%block}{%.apply}#7{%integer}{%assertEQ1}
@test.swap3 #1{%integer}#2{%integer}#3{%integer}#4{%integer}#5{%integer}#6{%integer}{%swap3}#3{%integer}{%assertEQ1}{%drop}#2{%integer}{%assertEQ1}{%drop}#1{%integer}{%assertEQ1}{%drop}#6{%integer}{%assertEQ1}{%drop}#5{%integer}{%assertEQ1}{%drop}#4{%integer}{%assertEQ1}{%drop}
@test.take.l "hello world!
~{%literal}#5{%integer}{%take.l}"hello
~{%literal}{%assertTextEQ1}
@test.textIsList "42
~{%literal}{%empty.l}#50{%integer}{%cons.l}#52{%integer}{%cons.l}{%assertTextEQ1}
@test.toList.s "hello, world!
~{%literal}{%dup}{%fromList.s}{%toList.s}{%assertEQ1}
@tri* [{%dip2}]{%block}{%dip2}{%bi*}
@test.tri* #6{%integer}#7{%integer}#8{%integer}[#9{%integer}{%.add}]{%block}[#10{%integer}{%.mul}]{%block}[#11{%integer}{%.sub}]{%block}{%tri*}#3-{%integer}{%assertEQ1}{%unrot}#70{%integer}{%assertEQ1}{%unrot}#15{%integer}{%assertEQ1}{%unrot}
@tri2 [{%keep2}]{%block}{%dip2}{%bi2}
@test.tri2 #6{%integer}#7{%integer}[{%.add}]{%block}[{%.mul}]{%block}[{%.square}{%swap}{%.square}{%.add}]{%block}{%tri2}#85{%integer}{%assertEQ1}{%unrot}#42{%integer}{%assertEQ1}{%unrot}#13{%integer}{%assertEQ1}{%unrot}
@tri2* [{%dip4}]{%block}{%dip2}{%bi2*}
@test.tri2* #6{%integer}#7{%integer}#8{%integer}#9{%integer}#10{%integer}#11{%integer}[{%.mul}]{%block}[{%.add}]{%block}[{%.div}]{%block}{%tri2*}#10{%integer}#11{%integer}{%ratio}{%assertEQ1}{%unrot}#17{%integer}{%assertEQ1}{%unrot}#42{%integer}{%assertEQ1}{%unrot}
@tri2dup {%dup}{%dup}{%tri2*}
@test.tri2dup #1{%integer}#2{%integer}#3{%integer}#4{%integer}#5{%integer}#6{%integer}[{%.mul}]{%block}{%tri2dup}#30{%integer}{%assertEQ1}{%unrot}#12{%integer}{%assertEQ1}{%unrot}#2{%integer}{%assertEQ1}{%unrot}
@test.unroll7 #1{%integer}#2{%integer}#3{%integer}#4{%integer}#5{%integer}#6{%integer}#7{%integer}{%unroll7}#6{%integer}{%assertEQ1}{%drop6}#7{%integer}{%assertEQ1}{%drop}
@until.step {%dip2}{%rot}[{%dip}{%inline}]{%block}[{%drop2}]{%block}{%if_}
@until [{%until.step}]{%block}{%bind2}{%fixpoint}{%inline}
@test.until #{%integer}[{%inc}]{%block}#10{%integer}[{%dupd}{%gtb}]{%block}{%bind}{%until}#11{%integer}{%assertEQ1.n}
@test.until1.0 #{%integer}[{%inc}]{%block}#{%integer}[{%dupd}{%gteb}]{%block}{%bind}{%until}#{%integer}{%assertEQ1.n}
@until1 {%over}{%dip2}{%until}
@test.until1.1 #{%integer}[{%inc}]{%block}#{%integer}[{%dupd}{%gteb}]{%block}{%bind}{%until1}#1{%integer}{%assertEQ1.n}
@untilSum.step {%composel}[]{%block}{%if}
@untilSum [{%untilSum.step}]{%block}{%bind}{%fixpoint}{%inline}
@until1Sum {%inLd}{%untilSum}
@test.until1Sum #{%integer}#10{%integer}{%pw}[{%wx}{%incd}{%gte}]{%block}{%until1Sum}{%x}{%assertEQ.n}
@test.unzip.l {%empty.l}#99{%integer}#102{%integer}{%pw}{%cons.l}#98{%integer}#101{%integer}{%pw}{%cons.l}#97{%integer}#100{%integer}{%pw}{%cons.l}{%unzip.l}"def
~{%literal}{%assertTextEQ1}{%swap}"abc
~{%literal}{%assertTextEQ1}{%swap}
@while [{%not.b}]{%block}{%compose}{%until}
@test.while #10{%integer}[{%dec}]{%block}#{%integer}[{%dupd}{%gtb}]{%block}{%bind}{%while}#{%integer}{%assertEQ1.n}
@whileSum {%notd}[{%not}]{%block}{%compose}{%untilSum}
@while1Sum {%inRd}{%whileSum}
@test.while1Sum #{%integer}#10{%integer}{%pw}[{%wx}{%incd}{%lt}]{%block}{%while1Sum}{%x}{%assertEQ.n}
@test.wordToBitList #165{%integer}#9{%integer}{%wordToBitList}{%bitListToText}"010100101
~{%literal}{%assertEQ}
@test.xor.b {%false.b}{%false.b}{%xor.b}{%false.b}{%assertEQ1}{%false.b}{%true.b}{%xor.b}{%true.b}{%assertEQ1}{%true.b}{%true.b}{%xor.b}{%false.b}{%assertEQ1}{%true.b}{%false.b}{%xor.b}{%true.b}{%assertEQ1}
@test.zip.l.eqSize "abcdef
~{%literal}"ghijkl
~{%literal}{%zip.l}{%unzip.l}"ghijkl
~{%literal}{%assertTextEQ1}{%swap}"abcdef
~{%literal}{%assertTextEQ1}{%swap}
@test.zip.l.truncateLeft "abcdef
~{%literal}"ghi
~{%literal}{%zip.l}{%unzip.l}"ghi
~{%literal}{%assertTextEQ1}{%swap}"abc
~{%literal}{%assertTextEQ1}{%swap}
@test.zip.l.truncateRight "abcdef
~{%literal}"ghijklmno
~{%literal}{%zip.l}{%unzip.l}"ghijkl
~{%literal}{%assertTextEQ1}{%swap}"abcdef
~{%literal}{%assertTextEQ1}{%swap}
@test.zip2 #5{%integer}#6{%integer}{%pw}#7{%integer}#8{%integer}{%pw}{%zip2}#7{%integer}#5{%integer}{%pw}{%assertEQ1}
@testing.bst {%pangram.1}{%dup}{%reverse.l}{%zip.l}{%empty.bst}{%swap}[{%mkCompareNums}{%insertKV.bst}{%drop}]{%block}{%each.l}
@textToTestTree.rbt {%dup}{%reverse.l}{%zip.l}{%empty.rbt}{%swap}[{%mkCompareNums}{%insertKV.rbt}{%drop}]{%block}{%each.l}
@testing.rbt {%pangram.1}{%textToTestTree.rbt}
@textToTestTree.t23 {%dup}{%reverse.l}{%zip.l}{%empty.t23}{%swap}[{%mkCompareNums}{%insertKV.t23}{%drop}]{%block}{%each.l}
@testing.t23 {%pangram.1}{%textToTestTree.t23}
@textBitsToList [{%chr:0}{%gtb}]{%block}{%map.l}
@textBitsToWord #{%integer}{%swap}[{%chr:0}{%gt}{%pushBit.bitListToWord}]{%block}{%each.l}
@toBoolean.arity1 v{%toBoolean.arity1e}c
@toStreamR.AATree [{%t.toStreamR.AATree}]{%block}{%.fixfirst}{%.bind}
@toList.AATree {%toStreamR.AATree}{%toListR.s}
@tree.toListL.bst {%unseal.bst}[{%elim1}{%discard}]{%block}[{%node.toListL.bst}]{%block}{%if}
@toListL.bst {%empty.l}{%swap}[{%take}{%tree.toListL.bst}]{%block}{%fixpoint}{%inline}
@toStream.AATree [{%t.toStream.AATree}]{%block}{%.fixfirst}{%.bind}
@toListR.AATree {%toStream.AATree}{%toListR.s}
@tree.toListR.bst {%unseal.bst}[{%elim1}{%discard}]{%block}[{%node.toListR.bst}]{%block}{%if}
@toListR.bst {%empty.l}{%swap}[{%take}{%tree.toListR.bst}]{%block}{%fixpoint}{%inline}
@toStream.arity1.l {%fromList.arity1.s}
@toStream.l {%fromList.s}
@toStream.r {%false.b}{%constant.s}{%swap}{%pmap.s}
@tree.toStreamL.bst {%take}{%unseal.bst}[{%leaf.toStreamL.bst}]{%block}[{%node.toStreamL.bst}]{%block}{%if}
@toStreamL.bst [vvr{%tree.toStreamL.bst}{%postApply}{%.app1}]{%block}{%.fixfirst}{%.bind}
@toStreamOfPrng.r {%true.b}{%constant.s}{%swap}{%pmap.s}
@tree.toStreamR.bst {%take}{%unseal.bst}[{%leaf.toStreamR.bst}]{%block}[{%node.toStreamR.bst}]{%block}{%if}
@toStreamR.bst [vvr{%tree.toStreamR.bst}{%postApply}{%.app1}]{%block}{%.fixfirst}{%.bind}
@tri [{%keep}]{%block}{%dip2}{%bi}
@tri3 [{%keep3}]{%block}{%dip2}{%bi3}
@tri3* [{%dip6}]{%block}{%dip2}{%bi3*}
@tri3dup {%dup}{%dup}{%tri3*}
@tridup {%dup}{%dup}{%tri*}
@true {%true.b}
@unit {%intro1}
@unless [{%drop}]{%block}{%if}
@unlessd []{%block}{%ifd}
@unlessk [{%drop}]{%block}{%ifk}
@unseal r{.s}l
@unseald.bst {%.rw}{%unseal.bst}{%.wl}
@unseald.rbt {%.rw}{%unseal.rbt}{%.wl}
@unseald.t23 {%.rw}{%unseal.t23}{%.wl}
@unwrapS.stackHand.env vrwlclcwllcc
@varianceNZ.stats {%unseal.stats}{%copy}{%seal.stats}{%put}{%x}{%take}{%x}{%.square}{%paste}{%.div}{%.sub}{%put}{%.div}
@variance.stats {%count.stats}#{%integer}{%gt}[#{%integer}]{%block}[{%varianceNZ.stats}]{%block}{%if_}
@warn.test "warn
~{%literal}{%p}{%cmd.test}{%drop}
@when [{%drop}]{%block}{%swap}{%if}
@whend []{%block}{%swap}{%ifd}
@whenk [{%drop}]{%block}{%swap}{%ifk}
@while1 {%over}{%dip2}{%while}
@wikilon.css "body {
  background: linear-gradient(#2e3436, #171A1B);
  background-attachment: fixed;
  color: #ecf0eb;
 }
 h1,h2,h3,h4,h5,h6,th {
  color: #d3d7cf;
 }
 a {
  color: #97c4f0;
  text-decoration: none;
 }
 a:hover, a:focus {
  text-decoration: underline;
 }
 strong, b {
  color: #d3d7cf;
  font-weight: bold;
 }
 a.refDictWord, .dictWord {
  color: #efd0a7;
 }
 a.refDictWordPrefix, .dictWordPrefix {
  color: #c17d11;
 }
 textarea {
  color: #ecf0eb;
  background-color: #2e3436;
  padding: 3px;
  overflow: auto;
  resize: both;
  border: 1px solid #888a85;
 }
 input[type="text"] {
  color: #ecf0eb;
  background-color: #2e3436;
  padding: 3px;
  border: 1px solid #888a85;
 }
 input[name="quota"] {
  text-align: right;
  color: #888a85;
 }
 input[name="editOrigin"] {
  color: #ce5c00;
 }
 input[type="submit"] {
  background-color: #888a85;
  color: #ecf0eb;
  font-weight: bold;
  text-shadow: 0px 0px 2px black;
  padding: 1px;
 }
 pre {
  color: #ecf0eb;
  background-color: #2e3436;
  padding: 3px;
  border: 1px solid #888a85;
  max-width: 640px;
  min-height: 16px;
  white-space: pre-wrap;
 }
 body.docs {
  margin: 0 auto;
  width: 640px;
 }
 div.docs {
  width: 640px;
 }
 span.parseError {
  background-color: #820000;
 }
 span.diffHead {
  background-color: #2a5703;
 }
 span.diffEdit {
  background-color: #371740;
 }
 span.diffOrig {
 }
 span.diffConflict {
  background-color: #8c3700;
 }
 span.diffConflictSep {
  color: #f57900;
  font-weight: bolder;
 }
 span.versionHash {
  color: #8f5902;
  font-size: x-small;
  font-family: "Lucida Console", Monaco, monospace;
 }
 .todo {
  color: #555753;
 }
~
@wordStreamToBitStream [{%wordToBitList}{%fromList.s}]{%block}{%bind}{%map.s}{%flatten.s}
@wrapS.stackHand.env vvrrwvrvrwlc
@x.pushBit.wordToBitList #2{%integer}{%.divMod}{%take}#{%integer}{%.gtb}{%cons.l}{%put}
@zip.s.onAB {%dx}{%x}{%swapd}{%pw}{%dpw}{%p}{%inL}
@zip.s.done {%drop2}{%intro1}{%inR}
@zip.s.onB {%.rw}{%intro1}{%.applyd}[{%.wl}{%zip.s.onAB}]{%block}[{%.wl}{%zip.s.done}]{%block}{%if}
@zip.s.next {%wx}{%intro1}{%.applyd}[{%zip.s.onB}]{%block}[{%zip.s.done}]{%block}{%if}
@zip.s {%pw}[{%zip.s.next}]{%block}{%fromStateE.s}
@zipRem.s.onAB {%dx}{%x}{%swapd}{%pw}{%inL}{%dpw}{%p}{%inL}
@zipRem.s.onB-A {%.rw}{%elim1}{%.wl}{%x}{%cons.s}{%inR}{%inR}{%lastElem.zipRem.s}
@zipRem.s.onB {%.rw}[{%.wl}{%zipRem.s.onAB}]{%block}[{%.wl}{%zipRem.s.onB-A}]{%block}{%if}
@zipRem.s.onA-B {%elim1}{%x}{%cons.s}{%inL}{%inR}{%lastElem.zipRem.s}
@zipRem.s.noB {%.rw}[{%.wl}{%zipRem.s.onA-B}]{%block}[{%.wl}{%noAB.zipRem.s}]{%block}{%if}
@zipRem.s.next {%wx}{%intro1}{%.applyd}{%.rw}{%intro1}{%.applyd}{%.wl}[{%zipRem.s.onB}]{%block}[{%zipRem.s.noB}]{%block}{%if}
@zipRem.s {%pw}[{%zipRem.s.next}]{%block}{%fromStateE.s}
@zwrap.AATree {%empty.l}{%pw}
